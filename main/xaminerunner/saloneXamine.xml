<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>Background SpecTcl</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>December 26, 2019</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction and Motivation</title>
        <para>
            This manual describes a capability added to SpecTcl/Xamine in
            SpecTcl version 5.5 and later.  This capability is intended to be
            used with the experiment manager in NSCLDAQ 12.0 and later, however
            it may also be used to attach a displayer to any running SpecTcl.
        </para>
        <para>
            The remainder of this document is organized as follows:
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  First we describe, how to run SpecTcl headless.  Note that
                  while this is not necessary (the software described in this)
                  manual can also be used to run a 'hydra' or multiheaded
                  SpecTcl. Nonetheless, using SpecTcl within the program
                  manager requires that it run headless.
               </para>
            </listitem>
            <listitem>
               <para>
                  Next we provide recipes for starting user interfaces off
                  for SpecTcl that run detached from SpecTcl.  We give,
                  as an example, how to run the tree GUI.
               </para>
            </listitem>
            <listitem>
               <para>
                  Finally, we describe the <literal>xaminerunner</literal>
                  program and how to use it to attache a free standing Xamine
                  to SpecTcl either providing an initial or additiona display
                  <firstterm>head</firstterm>.
               </para>
            </listitem>
            <listitem>
               <para>
                  Finally, we describe some techniques that may be useful
                  for SpecTcl running containerized within the
                  experiment manager.
               </para>
            </listitem>
        </itemizedlist>
    </chapter>
    <chapter>
       <title>Preparing Headless SpecTcl</title>
       <para>
        In order to run headless SpecTcl you must:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Tell SpecTcl to run without a displayer. 
           </para>
        </listitem>
        <listitem>
           <para>
              Use a minimal SpecTclRC.tcl such that no graphical user interface
              is loaded.
           </para>
        </listitem>
        <listitem>
           <para>
              Typically, you should enable the SpecTcl REST server so that
              you can bring up remote user interfaces and use <literal>xaminerunner</literal>
              or some other remote graphical user interface to view your
              data.
           </para>
        </listitem>
       </itemizedlist>
       <formalpara>
        <title>Running SpecTcl with out a displayer</title>
        <para>
            The <varname>DisplayType</varname> variable in
            <filename>SpecTclInit.tcl</filename> determines the type of displayer
            SpecTcl uses.  To run without a displayer, set the value of this
            to <literal>none</literal>.  For example:
        </para>
       </formalpara>
       <example>
        <title>Setting the display type in SpecTclInit.tcl</title>
        <programlisting>
set DisplayType none
        </programlisting>
       </example>
       <para>
        Note again, this is set in <filename>SpecTclInit.tcl</filename> not
        <filename>SpecTclRC.tcl</filename> which is run after the spectrum
        display interface is set up.
        Note that all SpecTcl displayers, including
       </para>
       <para>
        <literal>none</literal> create shared memory into which spectra can
        be bound via the <command>sbind</command> command. This allows
        local displayers to gain high performance access to spectrum data.
        A mirroring program allows this access by remote displayers as well.
        The size of this shared memory region is controlled by the
        <varname>DisplayMegabytes</varname> variable set in
        <filename>SpecTclRC.tcl</filename> which can be set to the number of
        megabytes of spectrum storage required in the shared memory region.
        There are also system imposed limits on shared memory sizes. 
       </para>
       <formalpara>
        <title>Use a minimal SpecTclRC.tcl</title>
        <para>
            <filename>SpecTclRC.tcl</filename> and scripts included from within that script are
            what normally start the graphical user interface (Tk) component
            of the SpecTcl command line interpreter.  For the most part,
            the standard <filename>SpecTclRC.tcl</filename> should be
            removed and replaced with a very minimal set of commands that
            do not require the Tk package.  You can, in fact, remove
            <filename>SpecTclRC.tcl</filename> completely in many cases.
        </para>
       </formalpara>
       <para>
        We will describe using graphical interfaces across the REST interface in
        a subsequent chapter.
       </para>
       <formalpara>
        <title>Initializing the SpecTcl REST server</title>
        <para>
            A headless SpecTcl, nonetheless, needs to be controlled. Users
            must make spectra, gates and apply them.  Furthermore,
            displayers will be required to examine the histograms spectra
            and gates SpecTcl is maintaining.  Finally SpecTcl will need
            to be connected to a data source.  The SpecTcl REST server
            provides the ability to do this via client programs.
        </para>
       </formalpara>
       <para>
        REST is an http protocol that was built for performing remote procedure
        like calls to a program that offers up a REST server.  SpecTcl 5.5
        and later provides an extensive REST interface, client API and
        client simulations of all SpecTcl commands.  These allow users
        to connect existing GUIs to headless SpecTcl instances.
       </para>
       <para>
        The <varname>HTTPDPort</varname> variable, if defined
        in <filename>SpecTclInit.tcl</filename>, describes
        the service port on which the SpecTcl REST service listens for
        connections.  This can be hard coded to a constant (which must be
        unique system-wide), or in data acquisition environments,
        the NSCLDAQ Port allocator can be used to allocate a free port number
        and publish the service for lookup by clients.  
       </para>
       <para>
        Here's an example fragment from a <filename>SpecTclInit.tcl</filename>
        that checks to see if SpecTcl is running in the NSCLDAQ environment
        and, if so uses the DAQ Port manager to allocate a port or, if not,
        hard codes the port to <literal>8080</literal>:
       </para>
       <example>
        <title>Setting HTTPDPort  to enable the REST Server in SpecTclInit.tcl</title>
        <programlisting>
set NonDAQHTTPDPort 8080
lappend auto_path [file join $SpecTclHome TclLibs]     <co id='ex.REST.auto_path' />
if {[array names env DAQTCLLIBS]  ne ""} {             <co id='ex.REST.daqenvcheck' />
    lappend auto_path $env(DAQTCLLIBS)                 <co id='ex.REST.daqtcllibs' />
    package require DAQService                         <co id='ex.REST.daqService' />
    set HTTPDPort [SpecTcl::getServicePort SpecTcl_REST] <co id='ex.REST.publishPort' />
    
} else {
    set HTTDPort $NonDAQHTTPDPort                     <co id='ex.REST.hardcodedPort' />
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='ex.REST.auto_path' >
            <para>
                Adds the <filename>TclLibs</filename> subdirectory of the
                SpecTcl installation directory tree to the set of directory
                trees searched
                by Tcl by <command>package require</command>.  The
                <varname>SpecTclHome</varname> directory is defined by
                SpecTcl early in its initialization process to be the
                path to the SpecTcl installation top level directory.
            </para>
        </callout>
        <callout arearefs='ex.REST.daqenvcheck' >
            <para>
                The environment variable <literal>DAQTCLLIBS</literal> is
                defined by the <filename>daqsetup.bash</filename>  script
                from NSCLDAQ 12.0 and higher to point to the NSCLDAQ
                Tcl Library directory tree.  Prior to 12.0 you must look for
                <literal>DAQROOT</literal> to know if the NSCLDAQ
                environment variables have been defined.
            </para>
            <para>
                The true branch of code for this <command>if</command> command
                is executed only if this environment variable is true
                (NSCLDAQ environment).
            </para>
        </callout>
        <callout arearefs='ex.REST.daqtcllibs' >
            <para>
                Adds the NSCLDAQ Tcl library path to the set of libraries
                that are searched by the Tcl package loader.    If using
                a version of NSCLDAQ earlier than 12.0, you must
                replace <literal>$env(DAQTCLLIBS)</literal> with
                <literal>[file join $env(DAQROOT) TclLibs]</literal> since
                the <literal>DAQTCLLIBS</literal> environment variable is only
                defined in NSCLDAQ 12.0 and later.
            </para>
        </callout>
        <callout arearefs='ex.REST.daqService' >
            <para>
                SpecTcl provides a package named <literal>DAQService</literal>
                that interacts with the port manager to allocated a port
                and publish that allocation.  This pulls in that package.  This
                package can only be pulled in without error in the NSCLDAQ
                environment.
            </para>
        </callout>
        <callout arearefs='ex.REST.publishPort' >
            <para>
                <function>SpecTcl::getServicePort SpecTcl_REST</function>
                interacts with the NSCLDAQ Port manager to allocate a server port
                and advertise it using the named service
                (in this case <literal>SpecTcl_REST</literal>).  In the NSCLDAQ
                port manager advertisements are qualified by the user name in effect
                when the port was requested.
            </para>
        </callout>
        <callout arearefs='ex.REST.hardcodedPort' >
            <para>
                In the event the NSCLDAQ environment was not defined,
                a hardcoded port number defined at the top of this code segment
                is used.
            </para>
        </callout>
       </calloutlist>
    </chapter>
    <chapter>
       <title>Running GUIs on a headless SpecTcl</title>
       <para>
        Once a headless SpecTcli is running, it is normal to want to interact with
        it.  This is possible via clients to the SpecTcl REST server. 
       </para>
       <para>
        A pair of packages supports this and are documented in other manuals.
        The <literal>SpecTclRESTClient</literal> provides a bare bones
        REST client capable of making requests of the SpecTcl REST server
        and returning the results from the server in Tcl-ish form (generally
        as dicts).  More interesting is the  
        <literal>SpecTclRestCommand</literal> package which provides simulations
        of all of the SpecTcl Tcl command extension as REST clients.
       </para>
       <para>
        <literal>SpecTclRestCommand</literal> provides the ability to run
        SpecTcl scripts as clients to the SpecTcl REST server. In order to
        run a SpecTcl GUI simply
       </para>
       <orderedlist>
        <listitem>
           <para>
              Include the <literal>SpecTclRestCommand</literal>  package in a
              script.
           </para>
        </listitem>
        <listitem>
           <para>
              Initialize the <literal>SpecTclRestCommand</literal> package providing
              the host and port on which the SpecTcl instance you want
              is listening for REST requests.
           </para>
        </listitem>
        <listitem>
           <para>
              Source your GUI (this could mean simply sourcing the
              original <filename>SpecTclRC.tcl</filename> script).  
           </para>
        </listitem>
        
       </orderedlist>
       <para>
        The following example shows how to run the SpecTcl Tree parameter
        (standard) GUI.  The assumption in this script is that the
        user Fox started the SpecTcl headless under the NSCLDAQ environment
        advertising its REST interface as <literal>SpecTcl_REST</literal>.
        The assumption is that the NSCLDAQ environment, version 12.0 or later
        was set up when the script was run.
       </para>
       <example>
        <title>Running the Tree Parameter GUI as a REST client.</title>
        <programlisting>
lappend auto_path [file join $SpecTclHome TclLibs]   <co id='ex.treegui.pkgpath' />
lappend auto_path $env(DAQTCLLIBS)

package require portAllocator
set mgr [portAllocator %AUTO%];     # Could supply -hostname if different system. <co id='ex.treegui.findsvc' />
set port [$mgr findServer SpecTcl_REST fox];  # Could be different user!
$mgr destroy

if {$port eq ""} {                          <co id='ex.treegui.noserver' />
    error "There is no SpecTcl_REST service - perhaps SpecTcl isn't running"
}

package require SpecTclRestCommand
SpecTclRestCommand::initialize localhost  $port   <co id='ex.treegui.cmdsimulator' />

source $SpecTclHome/Script/SpecTclGui.tcl        <co id='ex.treegui.treegui' />
wm withdraw .                                    <co id='ex.treegui.withdraw' />

           
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='ex.treegui.pkgpath' >
            <para>
                Adds the SpecTcl and NSCLDAQ Tcl Library directory trees to the
                Tcl package search paths.  This code assumes that the
                NSCLDAQ 12.0 or higher <filename>daqsetup.tcl</filename>
                file was sourced.   Prior to NSCLDA 12.0, the second line should
                read : <literal>lappend auto_path [file join $env(DAQROOT) TclLibs]</literal>
             </para>
        </callout>
        <callout arearefs='ex.treegui.findsvc' >
            <para>
                Locates the port number associated with the
                service named <literal>SpecTcl_REST</literal> run by the user
                <literal>fox</literal> and assigns it to the <varname>port</varname>
                variable.  Note that this search, by default, is done in the
                local system.  If you want to  search in a different host,
                Make the second line of this segment of code read:
                <literal>set mgr [portAllocator %AUTO% -hostname otherhost</literal>
                replacing the text <literal>otherhost</literal> with the
                name of the host we're connecing with.
            </para>
        </callout>
        <callout arearefs='ex.treegui.noserve' >
            <para>
                If no matching service can be found the return value from
                <literal>$mgr findServer</literal> will be an empty string.
                This is treated as an error.
            </para>
        </callout>
        <callout arearefs='ex.treegui.cmdsimulator' >
            <para>
                Pulls in the SpecTcl command simulator and invokes its initializtion
                command supplying the host and numeric port returned from the
                service lookup. Naturally, if you are connecting to SpecTcl
                in a remote system, you'll supply the DNS name of that system
                rather than <literal>localhost</literal> in the second line of
                this code fragment.
            </para>
        </callout>
        <callout arearefs='ex.treegui.treegui' >
            <para>
                Sources the tree gui script from the SpecTcl script directory.
                This starts up the tree parameter GUI. Note that the Tree parameter
                GUI does not display in the <literal>.</literal> window.
            </para>
        </callout>
        <callout arearefs='ex.treegui.withdraw' >
            <para>
                Wthdraws the empty <literal>.</literal> window leaving only
                the tree gui displayed from this script.
            </para>
        </callout>
       </calloutlist>
    </chapter>
    <chapter>
       <title>xaminerunner - Attaching Xamine to a headless SpecTcl</title>
       <para>
        In the previous chapter we described how to attach a graphical
        user interface to a headless SpecTcl.  In addition to controlling SpecTcl
        through such an interface, it is also important to be able to run
        a visualizer that lets you see spectra, click in gates on it and otherwise
        interact with the data SpecTcl has analyzed. 
       </para>
       <para>
        This chapter describes how to start Xamine, one of SpecTcl's displayers,
        attaching it to a headless SpecTcl.  At the time this document is being
        written, SpecTcl must run in the same host as Xamine.  We intend to develop
        a shared memory mirroring system that will allows Xamine to view spectra
        from a remote SpecTcl. 
       </para>
       <para>
        The program <application>xaminerunner</application> is a combination of
        C++ code and Tcl scripts that:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Asks the SpecTc REST server for information about the
              shared displayed shared memory region and starts Xamine displaying
              data from that region.
           </para>
        </listitem>
        <listitem>
           <para>
              Accepts Xamine gate entries and converts them into the SpecTcl
              REST calls needed to enter those gaes in SpecTcl.
           </para>
        </listitem>
        <listitem>
           <para>
              Uses the SpecTcl REST interface to become aware of new gates, changes
              to existing gates and spectra being bound to or unbound from
              the shared memory subsequently interacting with the Xamine
              graphical object entry interface so that Xamine and SpecTcl
              both have consistent ideas of gates and where to display them
              as they do when Xamine is started by SpecTcl.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        The <application>xaminerunner</application> program is located in the
        <filename>bin</filename> directory of the SpecTcl installation, starting
        with version 5.5.  It's synopsis is:
       </para>
       <example>
        <title>xaminerunner Command Synopsis</title>
        <cmdsynopsis><command>
xaminerunner --host=hostname --port=portno-or-service
        </command></cmdsynopsis>
       </example>
    </chapter>
    <chapter>
       <title>Tips and Techniques for the Experiment Manager</title>
       <para>
       </para>
    </chapter>
</book>