<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CFit</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SpecTcl Programming Reference."
HREF="index.html"><LINK
REL="UP"
TITLE="CEventBuilderEventProcessor"
HREF="r8671.html"><LINK
REL="PREVIOUS"
TITLE="CGateObserver"
HREF="r17423.html"><LINK
REL="NEXT"
TITLE="Predefined CFit classes"
HREF="r17771.html"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SpecTcl Programming Reference.</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="r17423.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="r17771.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN17508"
></A
>CFit</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN17512"
></A
><H2
>Name</H2
>CFit&nbsp;--&nbsp;Base class for spectrum fitting subsystem.</DIV
><DIV
CLASS="refsynopsisdiv"
><A
NAME="AEN17515"
></A
><H2
>Synopsis</H2
><PRE
CLASS="synopsis"
>&#13;
#include &#60;CFit.h&#62;
class CFit : public  CNamedItem     
{
public:
  struct Point {		
    double x;
    double y;
    int operator==(const Point&#38; rhs) const;
    int operator!=(const Point&#38; rhs) const;
  };
  
  typedef std::vector&#60;Point&#62; PointArray; 
  typedef PointArray::iterator PointIterator;

  typedef std::pair&#60;std::string, double&#62; FitParameter;
  typedef std::vector&#60;FitParameter&#62; FitParameterList;
  typedef FitParameterList::iterator FitParameterIterator;

  typedef enum {
    Accepting,
    Performed
  } FitState;			//!&#60; State of the fit.

  

  void AddPoint (Point p)   ; 
  PointIterator begin ()   ; 
  PointIterator end ()   ; 
  size_t size ()   ; 
  FitState GetState ()  const ; 

  virtual CFit* clone() = 0;
  virtual   void Perform ()   = 0 ; 
  virtual  double operator() (double x)  =0 ; 
  virtual  FitParameterList GetParameters () =0  ; 
  virtual  std::string Type() const  = 0;
 
protected:
  void SetFitState(FitState state) ;
};

        </PRE
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN17517"
></A
><H2
>DESCRIPTION</H2
><P
>&#13;            SpecTcl has an extensible fitting program.  Fits can be
            created and updated based on the current data.  SpecTcl
            also interacts with the display program to display any fits
            on appropriate spectra, if that display program is capable of that.
        </P
><P
>&#13;            The core of the fitting subsystem is the <CODE
CLASS="classname"
>CFit</CODE
>
            abstract base class.  Each object that performs a fit must be a
            concrete class derived from <CODE
CLASS="classname"
>CFit</CODE
>
        </P
><P
>&#13;            Fits are stateful objects.   There are two states a fit can
            be in.  The <TT
CLASS="literal"
>Accepting</TT
> state means that the
            fit has had at least one point added without a call to
            <CODE
CLASS="methodname"
>Perform</CODE
>.  In this state the fit parameters
            cannot be retrieved.  Once <CODE
CLASS="methodname"
>Perform</CODE
> is called,
            the fit is in the <TT
CLASS="literal"
>Performed</TT
> state and the fit
            parameters can be extracted from the object.
        </P
><P
>&#13;            Note that since <CODE
CLASS="classname"
>CFit</CODE
> is a
            <CODE
CLASS="classname"
>CNamedItem</CODE
>, it inherits a constructor
            that have name and id as parameters.
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN17531"
></A
><H2
>DATA TYPES</H2
><P
>&#13;            The class defines a few contained data types.  By contained,
            we mean a data type that is defined inside the class definition.
            Contained data type names must be resolved in the scope of the
            class.  E.g. <FONT
COLOR="RED"
>PointArray a;</FONT
> will cause a compiler
            error but <FONT
COLOR="RED"
>CFit::PointArray a;</FONT
> will not.
        </P
><DIV
CLASS="refsect2"
><A
NAME="AEN17536"
></A
><H3
><CODE
CLASS="structname"
>Point</CODE
> a data point.</H3
><P
>&#13;                The <CODE
CLASS="structname"
>Point</CODE
> struct represents a point
                of data that needs to be fitted.  For spectrum fits, each
                point is a channel coordinate (<CODE
CLASS="structfield"
>x</CODE
>)
                and the counts in that channel (<CODE
CLASS="structfield"
>y</CODE
>).
                At present, SpecTcl fits are restricted to 1-d data sets.
            </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><SPAN
CLASS="type"
>double </SPAN
><CODE
CLASS="structfield"
>x</CODE
></DT
><DD
><P
>&#13;                            The X coordinate of the point. Normally this
                            represents a channel number in the spectrum
                            being fitted.
                        </P
></DD
><DT
><SPAN
CLASS="type"
>double</SPAN
> <CODE
CLASS="structfield"
> y</CODE
></DT
><DD
><P
>&#13;                            The Y coordinate of the point. Normally this is the
                            number of points in the channel selected by
                            <CODE
CLASS="structfield"
>x</CODE
>.
                        </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> const </span
><span
class="type"
>int  </span
>operator==(<span
class="methodparam"
><span
class="modifier"
>const </span
><span
class="type"
> Point&#38;  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                            Returns non zero (<TT
CLASS="literal"
>1</TT
>) if
                            the <CODE
CLASS="structfield"
>x</CODE
> and
                            <CODE
CLASS="structfield"
>y</CODE
> fields of the
                            <CODE
CLASS="structname"
>Point</CODE
> referred to by
                            <CODE
CLASS="parameter"
>rhs</CODE
> are equal to that of this
                            object.
                        </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
>const </span
><span
class="type"
>int  </span
>operator!=(<span
class="methodparam"
><span
class="modifier"
>const </span
><span
class="type"
> Point&#38; </span
><span
class="parameter"
> rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                            Inverse of <CODE
CLASS="methodname"
>operator==</CODE
>.
                        </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="refsect2"
><A
NAME="AEN17589"
></A
><H3
>Typedefs related to <CODE
CLASS="structname"
>Point</CODE
></H3
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><FONT
COLOR="RED"
>typedef std::vector&#60;Point&#62; PointArray</FONT
></DT
><DD
><P
>&#13;                            <SPAN
CLASS="type"
>PointArray</SPAN
> objects maintain the set
                            of points gathered for a fit. 
                        </P
></DD
><DT
><FONT
COLOR="RED"
>typedef PointArray::iterator PointIterator</FONT
></DT
><DD
><P
>&#13;                            Support iteration in the container that
                            defines <SPAN
CLASS="type"
>PointArray</SPAN
>.  Using iterators
                            rather than indexing allows software to be written
                            independent of the actual underlying container that
                            is <SPAN
CLASS="type"
>PointArray</SPAN
>.
                        </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="refsect2"
><A
NAME="AEN17606"
></A
><H3
>Fit parameter data types.</H3
><P
>&#13;                Fit parameters are a bit tricky.  Each fit type will have its
                own set of parameters.  Thus a fit parameter is defined not
                just by its value but by its meaning in the context of the
                fit type.
            </P
><P
>&#13;                <FONT
COLOR="RED"
>typedef std::pair&#60;std::string, double&#62; FitParameter</FONT
>
                represents a single fit parameter.  The first part of the pair
                is a name that identifies the meaning of the parameter.
                The second part of the pair is the value itself.  For example,
                for a linear fit, the first item of the pair might be the string
                <TT
CLASS="literal"
>slope</TT
> and the second part the fitted
                slope.
            </P
><P
>&#13;                Most fits have more than one parameter.   Therefore:
                <FONT
COLOR="RED"
>typedef std::vector&#60;FitParameter&#62; FitParameterList</FONT
>
                is a container of fit parameters.  
            </P
><P
>&#13;                In order to allow the container type to change later;
                <SPAN
CLASS="type"
>FitParameterList</SPAN
> instances should not be indexed.
                Instead, use iterators defined by
                <FONT
COLOR="RED"
>typedef FitParameterList::iterator FitParameterIterator</FONT
>.
                <SPAN
CLASS="type"
>FitParameterList</SPAN
> instances have the standard
                iterator support methods <CODE
CLASS="methodname"
>begin</CODE
>
                and <CODE
CLASS="methodname"
>end</CODE
> to support this.
            </P
></DIV
><DIV
CLASS="refsect2"
><A
NAME="AEN17620"
></A
><H3
>FitState</H3
><P
>&#13;                Fit objects are stateful.  They distinguish between accepting
                points and having fit those points.  The fit state is captured
                by <SPAN
CLASS="type"
>FitState</SPAN
> which is an enumerated type
                with the following values:
            </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
> Accepting</TT
></DT
><DD
><P
>&#13;                            The fit is in the process of accepting points.
                            If it has sufficient points;
                            <CODE
CLASS="methodname"
>Perform</CODE
> can be invoked.
                            In this state, the fit is not able to deliver fit parameters.
                        </P
></DD
><DT
><TT
CLASS="literal"
>Performed</TT
></DT
><DD
><P
>&#13;                            The fit has been performed and can deliver
                            parameters.  This is the state right after a call
                            to <CODE
CLASS="methodname"
>Perform</CODE
> and before the
                            fit is invalidated by adding more points.
                        </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN17637"
></A
><H2
>METHODS</H2
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>AddPoint (<span
class="methodparam"
><span
class="type"
>Point  </span
><span
class="parameter"
>p</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                        Adds a point to the internal list of points.  This
                        places the object in the <TT
CLASS="literal"
>Accepting</TT
>
                        state, if it's not already in that state.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>PointIterator </span
> begin();&#13;</code
>, <code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>PointIterator  </span
>end();&#13;</code
>, <code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>size_t  </span
>size();&#13;</code
></DT
><DD
><P
>&#13;                        These three methods support iteration over the internal
                        <SPAN
CLASS="type"
>PointArray</SPAN
>.  Iteration is supported in the
                        same sense as for C++ container types.  At present,
                        the iterator returned is a pointer like object that
                        points to a <CODE
CLASS="structname"
>Point</CODE
> struct.
                    </P
><P
>&#13;                        <CODE
CLASS="methodname"
>begin</CODE
> returns an iterator that
                        'points' to the beginning of the
                        <SPAN
CLASS="type"
>PointArray</SPAN
>.  <CODE
CLASS="methodname"
>end</CODE
>
                        returns an iterator pointing just off the end of the
                        <SPAN
CLASS="type"
>PointArray</SPAN
>.  <CODE
CLASS="methodname"
>size</CODE
>
                        returns the number of points in that container.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
>const </span
><span
class="type"
>FitState  </span
>GetState ();&#13;</code
></DT
><DD
><P
>&#13;                        Returns the current fit state.  This has been
                        previously described.  
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>virtual  </span
><span
class="modifier"
>= 0 </span
><span
class="type"
>CFit*  </span
>clone();&#13;</code
></DT
><DD
><P
>&#13;                        Pure virtual method that is supposed to dynamically
                        create a copy of this object.  If the object
                        supports copy construction, this is like a virtual
                        copy constructor and can be implemented like this:
                    </P
><PRE
CLASS="programlisting"
>&#13;CFit*
CMyFitType::clone()
{
    return new CMyFitType(*this);
}
                    </PRE
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>virtual    </span
><span
class="modifier"
> = 0  </span
><span
class="type"
>void  </span
>Perform();&#13;</code
></DT
><DD
><P
>&#13;                        Performs the fit with the set of points that
                        have been added to the object.  An exception
                        should be thrown if there are not sufficient points to
                        determine the fit.
                    </P
><P
>&#13;                        If the fit is successfully performed, this method
                        should invoke <CODE
CLASS="methodname"
>SetFitState</CODE
>
                        to set the new fit state to <TT
CLASS="literal"
>Performed</TT
>.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>virtual  </span
><span
class="modifier"
>=0 </span
><span
class="type"
> double  </span
>operator() (<span
class="methodparam"
><span
class="type"
>double  </span
><span
class="parameter"
>x</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                        If the fit is not in the <TT
CLASS="literal"
>Performed</TT
>
                        state this method should throw an exception.  If the
                        fit has been performed, this method should return the
                        value of the fit function evaluated at
                        <CODE
CLASS="parameter"
>x</CODE
>.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> virtual   </span
><span
class="modifier"
>=0 </span
><span
class="type"
>FitParameterList  </span
>GetParameters();&#13;</code
></DT
><DD
><P
>&#13;                        If the fit is not in the <TT
CLASS="literal"
>Performed</TT
>
                        state this should throw an exception.  Otherwise it
                        should return the fit specific list of fit parameters.
                        Note that one of them should always be (regardless
                        of fit type) <TT
CLASS="literal"
>chisquare</TT
>, the Chi Square
                        goodness of fit.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>virtual   </span
><span
class="modifier"
>const  = 0; </span
><span
class="type"
>std::string  </span
>Type();&#13;</code
></DT
><DD
><P
>&#13;                        Returns a textual fit type.   This should be
                        a string descriptive of the fit; e.g.
                        <TT
CLASS="literal"
>gaussian</TT
> is returned by
                        <CODE
CLASS="classname"
>CGaussianFit</CODE
>.
                    </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>protected </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>SetFitState(<span
class="methodparam"
><span
class="type"
>FitState  </span
><span
class="parameter"
>state</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                        Allows concrete subclasses to set the fit state.
                        In all cases, this should be used by
                        <CODE
CLASS="methodname"
>Perform</CODE
> to set the state to
                        <TT
CLASS="literal"
>Performed</TT
> once the fit is actually
                        computed.
                    </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="r17423.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="r17771.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CGateObserver</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="r8671.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Predefined CFit classes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>