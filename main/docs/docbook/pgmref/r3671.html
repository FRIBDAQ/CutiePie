<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CTreeVariable</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SpecTcl Programming Reference."
HREF="index.html"><LINK
REL="UP"
TITLE="Tree Parameter, Tree Variable API"
HREF="p2375.html"><LINK
REL="PREVIOUS"
TITLE="CTreeParameterArray"
HREF="r3194.html"><LINK
REL="NEXT"
TITLE="CTreeVariableProperites"
HREF="r4061.html"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SpecTcl Programming Reference.</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="r3194.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="r4061.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="AEN3671"
></A
>CTreeVariable</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN3675"
></A
><H2
>Name</H2
>CTreeVariable&nbsp;--&nbsp;Access to Tcl variables with metadata</DIV
><DIV
CLASS="refsynopsisdiv"
><A
NAME="AEN3678"
></A
><H2
>Synopsis</H2
><PRE
CLASS="synopsis"
>&#13;#include &#60;TreeParameter.h&#62;

class <CODE
CLASS="classname"
>CTreeVariable</CODE
>
{
  CTreeVariable();
  CTreeVariable(std::string name, double value, std::string units);
  CTreeVariable(const CTreeVariable&#38; rhs);

  void Initialize(std::string name, double value, std::string units);

  operator double() const;
  CTreeVariable&#38; operator=(double rhs);
  CTreeVariable&#38; operator=(const CTreeVariableamp; rhs);
  CTreeVariable&#38; operator+=(double rhs);
  CTreeVariable&#38; operator-=(double rhs);
  CTreeVariable&#38; operator*=(double rhs);
  CTreeVariable&#38; operator/=(double rhs);
  double operator++(int dummy);
  CTreeVariable&#38; operator++();
  double operator--(int dummy);
  CTreeVariable&#38; operator--();
  
  
  std::string getName();
  double getValue();
  std::string getUnit();
  bool hasChanged();
  bool valueChanged();
  void resetChanged();
  
  void Bind();
  static void BindVariables(CTCLInterpreter&#38; rInterp);
  static TreeVariableIterator begin();
  static TreeVariableIterator end();
  static TreeVariableIterator find(std::string name);
  static int size();
  
};
                </PRE
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN3681"
></A
><H2
>DESCRIPTION</H2
><P
>&#13;                    The <CODE
CLASS="classname"
>CTreeVariable</CODE
>  class provides
                    simplified access to Tcl intepreter variables.  These
                    variables are globally scoped variables in Tcl and
                    are defined in the interpreter that executes
                    SpecTcl commands.
                </P
><P
>&#13;                    The operations provided by the class are sufficient
                    to allow you to treat the tree variable as if it were
                    a simple <SPAN
CLASS="type"
>double</SPAN
> value, transparently fetching or
                    storing the underlying Tcl variable as needed.
                </P
><P
>&#13;                    Tree variables also have metadata.  Specifically each tree
                    variable can have a unit of measure property.
                </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN3688"
></A
><H2
>METHODS</H2
><P
>&#13;                    Constructors and initializers.  As with tree parameters,
                    tree variables support both one and two step
                    construction.
                </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><code
class="constructorsynopsis"
>&#13;  CTreeVariable();&#13;</code
></DT
><DD
><P
>&#13;                                This default constructor will require that
                                you later invoke
                                <CODE
CLASS="methodname"
>Initialize</CODE
>
                                to complete the two step construction of the
                                object.
                            </P
></DD
><DT
><code
class="constructorsynopsis"
>&#13;  CTreeVariable(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>std::string  </span
><span
class="parameter"
>name</span
></span
><span
class="methodparam"
>, <span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>value</span
></span
><span
class="methodparam"
>, <span
class="modifier"
> </span
><span
class="type"
>std::string  </span
><span
class="parameter"
>units</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                <CODE
CLASS="parameter"
>name</CODE
> is the name of
                                the Tcl variable this object is
                                associated with.  <CODE
CLASS="parameter"
>value</CODE
>
                                is an initial value the variable will be given.
                                <CODE
CLASS="parameter"
>units</CODE
> are the units
                                of measure metadata to be associated
                                with this variable.
                            </P
><P
>&#13;                                If there is already a Tcl variable, this does
                                not affect it.  The variable will need to be bound.
                                first.  If there is already a tree variable,
                                The previously established
                                initial value and units override the value and
                                units in this constructor.
                            </P
><P
>&#13;                                A bit of information about how all this works
                                that will help you to understand some of the
                                pathalogical cases.  Tcl supports linking
                                a C/C++ variable to a Tcl variable.  We
                                use this, however we have to do some fancy
                                footwork to support many to one mappings from
                                tree variables to Tcl variables.
                            </P
><P
>&#13;                                Associated with a tree variable name and,
                                therefore, with all tree variable objects
                                with the same name, is a properties object.
                                The properties object contains the name,
                                value and units metadata, shared between
                                all tree variables objects with the same name.
                                Binding at least one of the objects links the
                                C++ variable containing the value with the
                                Tcl variable with the same name as the
                                tree variable's name.
                            </P
><P
>&#13;                                Thus, unlike tree parameters, once a
                                tree variable is constructed, it can be set,
                                gotten, modified and queried without error.
                                What does not happen is for anything done to the
                                value of the tree variable to affect the
                                Tcl variable.  Binding the tree variable
                                links the data containing the value with the
                                Tcl variable and ensures that the Tcl variable
                                has the current value of the tree variable.
                            </P
><P
>&#13;                                A short code segment may be useful.
                            </P
><PRE
CLASS="programlisting"
>&#13;CTreeVariable t1("myvar", 1234, "arb");           // Tcl variable unchanged
CTreeVariable t2("myvar", 456, "inch");           // Tcl and tree variable unchanged.

t1 = 777;        // T1 and T2 are now 777, Tcl variable unchanged.
t2.Bind();       // Tcl variable now 777.

t1 = 0;          // Tcl, t1, and t2 vars are now 0.
                            </PRE
></DD
><DT
><code
class="constructorsynopsis"
>&#13;  CTreeVariable(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>const CTreeVariable&#38;  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Copy construction.  This allows tree variables
                                to be passed by value.  Since, however all like named
                                tree variables use the same underlying data,
                                Changes to the copy constructed object will be
                                reflected in all other like named tree variables and,
                                if the variable is bound, in the Tcl variable.
                            </P
><P
>&#13;                                Thus, while pass by value is legal, it has the
                                semantics of pass by reference.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>Initialize(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>std::string  </span
><span
class="parameter"
>name</span
></span
><span
class="methodparam"
>, <span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>value</span
></span
><span
class="methodparam"
>, <span
class="modifier"
> </span
><span
class="type"
>std::string  </span
><span
class="parameter"
>units</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Second step of two step initialization. The
                                parameters have the same meaning as in the one-step
                                construction constructor.
                            </P
></DD
></DL
></DIV
><P
>&#13;                    The next set of methods are provided so that, for the most part,
                    you can treat a <CODE
CLASS="classname"
>CTreeVariable</CODE
> as if it
                    were a Double precision variable.  The main contributor to this
                    is the <CODE
CLASS="methodname"
>operator double</CODE
> conversion
                    operator.  This operator allows a <CODE
CLASS="classname"
>CTreeVariable</CODE
>
                    variable in an expression to be converted to a double, supporting
                    its use on the right hand side (as an r-value) of assignments.
                </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
>const </span
><span
class="type"
> </span
>operator double();&#13;</code
></DT
><DD
><P
>&#13;                                In C++ this sort of method is called a
                                conversion operator, or casting operator.
                                It provides a method that allows
                                <CODE
CLASS="classname"
>CTreeVariable</CODE
>
                                objects to be treated as double variables
                                wherever appropriate.
                                The method returns the value of the
                                underlying variable.  Note that if the
                                object has not yet been bound, the value
                                returned is the most recently set value of
                                the object, which can differ from the
                                Tcl variable's value.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Assignment operator.  This is one of the
                                operators that allows
                                <CODE
CLASS="classname"
>CTreeVariable</CODE
> objects
                                top be used on the left hand side of
                                assignment operations (as an l-value).
                                The method assigns the
                                double <CODE
CLASS="parameter"
>rhs</CODE
>
                                to the value of the variable. If the
                                object has been bound, this will be the new
                                value of the Tcl variable.  If not, this value
                                will be held in the variable and will become
                                the value of the Tcl variable when it is bound.
                            </P
><P
>&#13;                                By returning a reference to the object, assignment
                                chaining is supported,  e.g. like
                            </P
><PRE
CLASS="programlisting"
>&#13;CTreeVariable t1("avar", 1.234, "arbitrary");
double        d1;

d1  = t1 = 5.6;             // d1 is 5.6 as is t1.
                            </PRE
><P
>&#13;                                The best way to read the last statement is
                                right to left.  First the tree variable is
                                given the value 5.6 and that assignment can be
                                thought of as being replaced by the
                                <CODE
CLASS="varname"
>t1</CODE
>  tree variable reference.
                            </P
><P
>&#13;                                To accomplish the assignment to <CODE
CLASS="varname"
>d1</CODE
>,
                                the <CODE
CLASS="methodname"
>operator double</CODE
>
                                is used to returne the value of
                                <CODE
CLASS="varname"
>t1</CODE
> to assign to
                                <CODE
CLASS="varname"
>d1</CODE
>
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>const CTreeVariableamp;  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Assigns the value of the <CODE
CLASS="parameter"
>rhs</CODE
>
                                tree variable to the value of this variable.
                                Once more returning a reference to the object
                                allows operator chaining.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator+=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>double </span
><span
class="parameter"
> rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Like assignment, but <CODE
CLASS="parameter"
>rhs</CODE
>
                                is added to the variable's value.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator-=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Like assignment but
                                <CODE
CLASS="parameter"
>rhs</CODE
> is subtracted
                                from the value of the object.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator*=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Like assignment but
                                <CODE
CLASS="parameter"
>rhs</CODE
> multiplies the
                                object's value.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator/=(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>double  </span
><span
class="parameter"
>rhs</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Like assignment but the value of the object is
                                divided by the <CODE
CLASS="parameter"
>rhs</CODE
>.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>double  </span
>operator++(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>int  </span
><span
class="parameter"
>dummy</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                This operator is the post-increment operator.
                                The value of the object prior to the increment
                                is returned.  Because of the binding to an underlying
                                Tcl variable, the normal semantics of  predecrementing
                                are not possible.
                            </P
><P
>&#13;                                Specifically  normally post-increments ill return
                                a copy of the object prior to the increment, while
                                here a double is returned instead.  In most cases
                                you won't notice the difference.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator++();&#13;</code
></DT
><DD
><P
>&#13;                                Pre-increment operator.  The variable's value is incremented
                                and then a reference to the object is returned.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>double  </span
>operator--(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>int  </span
><span
class="parameter"
>dummy</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Post decrement operator.  The value of the object
                                is decremented but the value returned is the
                                <SPAN
CLASS="type"
>double</SPAN
> value prior to the increment.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>CTreeVariable&#38;  </span
>operator--();&#13;</code
></DT
><DD
><P
>&#13;                                Pre decrement operator.  The object's value is
                                decremented after which a reference to the
                                decremented object is returned.
                            </P
></DD
></DL
></DIV
><P
>&#13;                    The next set of operations can be best described as
                    queries about the object.
                </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>std::string  </span
>getName();&#13;</code
></DT
><DD
><P
>&#13;                                Returns the name of the object, and hence
                                the Tcl variable the object represents.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>double  </span
>getValue();&#13;</code
></DT
><DD
><P
>&#13;                                The same as <CODE
CLASS="methodname"
>operator double</CODE
>.
                                The value of the object is returned.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>std::string  </span
>getUnit();&#13;</code
></DT
><DD
><P
>&#13;                                Returns the units of measure metadata for the
                                object.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>bool  </span
>hasChanged();&#13;</code
></DT
><DD
><P
>&#13;                                Each tree variable has an associated flag
                                that is set <TT
CLASS="literal"
>true</TT
>
                                when the definition of that variable
                                has changed.  This method returns the
                                value of that flag.
                            </P
><P
>&#13;                                The main purpose is to control which parameter
                                definitions might need to be written
                                to file during a state save operation.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>bool  </span
>valueChanged();&#13;</code
></DT
><DD
><P
>&#13;                                Each variable has a value changed
                                flag as well that is modified when the
                                value of the variable is modified.
                                This is normally used to fire traces
                                on a variable in Tcl.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>resetChanged();&#13;</code
></DT
><DD
><P
>&#13;                                Resets both changed flags described above and
                                fires any value changed Tcl traces.  Traces are
                                used by Tk widgets to know when to update
                                values they contain via <CODE
CLASS="option"
>-variable</CODE
>
                                and <CODE
CLASS="option"
>-textvariable</CODE
> options.
                                It is therefore important to ensure that
                                these traces get fired after C++ changes
                                to these values if there are user interface
                                elements that display these variables.
                            </P
></DD
></DL
></DIV
><P
>&#13;                    The remainder of the methods primarily relate to bindings,
                    the registry of variables,
                    and the interface of the variable to its Tcl counterpart.
                </P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
> </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>Bind();&#13;</code
></DT
><DD
><P
>&#13;                                Binds this variable to the Tcl variable of the
                                same name, creating it if necessary.  The
                                object's value will be put into the Tcl variable.
                                If the object is already bound this is a silent
                                No-op.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>static  </span
><span
class="modifier"
> </span
><span
class="type"
>void  </span
>BindVariables(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>CTCLInterpreter&#38;  </span
><span
class="parameter"
>rInterp</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                A registry is maintained of all tree variable
                                objects.  This method iterates this registry
                                and binds all tree variables to their underlying
                                Tcl variables.  You can think of this as
                                invoking <CODE
CLASS="methodname"
>Bind</CODE
> on every
                                tree parameter.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>static </span
><span
class="modifier"
> </span
><span
class="type"
> TreeVariableIterator  </span
>begin();&#13;</code
>, <code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>static </span
><span
class="modifier"
> </span
><span
class="type"
> TreeVariableIterator  </span
>end();&#13;</code
>, <code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>static </span
><span
class="modifier"
> </span
><span
class="type"
> TreeVariableIterator  </span
>find(<span
class="methodparam"
><span
class="modifier"
> </span
><span
class="type"
>std::string  </span
><span
class="parameter"
>name</span
></span
>);&#13;</code
></DT
><DD
><P
>&#13;                                Return pointer like objects that can be
                                used to iterate the tree varaible registry.
                                When dereferenced, the object returns a
                                <CODE
CLASS="classname"
>std::pair&#60;std::string, CTreeVariableProperties*&#62;</CODE
>
                                The first item of each pair is the name of the
                                tree variable.  The second are the set of
                                properties that are shared between all
                                variables of the same name.
                            </P
><P
>&#13;                                <CODE
CLASS="classname"
>CTreeVariableProperties</CODE
>
                                will be described later in this reference section.
                            </P
><P
>&#13;                                <CODE
CLASS="methodname"
>begin</CODE
> returns the
                                iterator 'pointing' to the first object in the
                                container.
                                Incrementing an iterator  'points' it to the
                                next tree variable in the container.  Incrementing
                                the iterator pointing at the last object in the
                                container returns a value equal to that returned
                                by <CODE
CLASS="methodname"
>end</CODE
>.
                            </P
><P
>&#13;                                <CODE
CLASS="methodname"
>find</CODE
> returns an iterator
                                that points to the item in  the container named
                                <CODE
CLASS="parameter"
>name</CODE
>.  Note that since
                                the registry contains <CODE
CLASS="classname"
>CTreeVariableProperties</CODE
>
                                objects, there won't be duplication.
                                I there is no entry in the registry with the
                                <CODE
CLASS="parameter"
>name</CODE
>, the value
                                returned from <CODE
CLASS="methodname"
>end</CODE
>
                                is returned.
                            </P
></DD
><DT
><code
class="methodsynopsis"
>&#13;  <span
class="modifier"
>static  </span
><span
class="modifier"
> </span
><span
class="type"
>int  </span
>size();&#13;</code
></DT
><DD
><P
>&#13;                                Returns the number of entries in the
                                registry.  Note that since the registry
                                contains
                                <CODE
CLASS="classname"
>CTreeVariablePropertiew</CODE
>
                                objects, the number of entries in the registry
                                may be less than the number of
                                <CODE
CLASS="classname"
>CTreeVariable</CODE
> objects that
                                have been created.
                            </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="r3194.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="r4061.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CTreeParameterArray</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p2375.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CTreeVariableProperites</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>