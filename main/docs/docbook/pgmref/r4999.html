<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CTCLObjectProcessor</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SpecTcl Programming Reference."
HREF="index.html"><LINK
REL="UP"
TITLE="Tcl++ classes"
HREF="p4402.html"><LINK
REL="PREVIOUS"
TITLE="CTCLException"
HREF="r4856.html"><LINK
REL="NEXT"
TITLE="CTCLProcessor"
HREF="r5114.html"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SpecTcl Programming Reference.</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="r4856.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="r5114.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="manpage.CTCLObjectProcessor"
></A
>CTCLObjectProcessor</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN5003"
></A
><H2
>Name</H2
>CTCLObjectProcessor&nbsp;--&nbsp;
            Abstract base class to encapsulate the Tcl object command interface exposed by
            <CODE
CLASS="function"
>Tcl_CreateObjCommand</CODE
>.
        </DIV
><DIV
CLASS="refsynopsisdiv"
><A
NAME="AEN5007"
></A
><H2
>Synopsis</H2
><PRE
CLASS="programlisting"
>&#13;#include &#60;TCLObjectProcessor.h&#62;
...
class CTCLObjectProcessor : public CTCLInterpreterObject
{
public:
  CTCLObjectProcessor(CTCLInterpreter&#38; interp,
                      std::string      name,
                      bool             registerMe=true);
  virtual ~CTCLObjectProcessor();

  void Register();              // Register command on the interpreter.
  void unregister();            // Unregister command from the interp.
  std::string getName() const;  // Return the name of the object.
  Tcl_CmdInfo getInfo() const;  // Return info about the command.

protected:
  virtual int operator()(CTCLInterpreter&#38; interp,
                         std::vector&#60;CTCLObject&#62;&#38; objv) = 0;
  virtual void onUnregister();

protected:
  void bindAll(CTCLInterpreter&#38; interp, std::vector&#60;CTCLObject&#62;&#38; objv);
  void requireAtLeast(std::vector&#62;CTCLObject&#60;&#38; objv, unsigned n, const char* msg=0) const;
  void requireAtMost(std::vector&#60;CTCLObject&#62;&#38; objv, unsigned n, const char* msg=0) const;
  void requireExactly(std::vector&#60;CTCLObject&#62;&#38; objv, unsigned n, const char* msg=0) const;



};

    </PRE
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN5009"
></A
><H2
>DESCRIPTION</H2
><P
>&#13;            Tcl supports the addition of commands to the interpreter.  <CODE
CLASS="classname"
>CTCLObjectProcessor</CODE
>
            supports an object oriented encapsulation of this part of the API.
            To add a command to an interpreter, write a subclass of
            <CODE
CLASS="classname"
>CTCLObjectProcessor</CODE
>.  This subclass should override
            <CODE
CLASS="function"
>operator()</CODE
>, and optionally <CODE
CLASS="function"
>onUnregister</CODE
>.
            to implement the desired behavior for the new command.
        </P
><P
>&#13;            Create an instance of this new class and invoke its
            <CODE
CLASS="function"
>Register</CODE
>
            member to add it to the interpreter onto which it is bound.  Whenever a
            script executes the new command that object's
            <CODE
CLASS="function"
>operator()</CODE
> is invoked to process the command.
            If the interpreter is destroyed, or if the command is ever unregistered,
            the <CODE
CLASS="function"
>onUnregister</CODE
> function is called to perform any
            required global cleanup.
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN5020"
></A
><H2
>METHODS</H2
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;<CODE
CLASS="function"
>CTCLObjectProcessor</CODE
>(<SPAN
CLASS="type"
>CTCLInterpreter</SPAN
>&#38; <CODE
CLASS="parameter"
>interp</CODE
>,
                    <SPAN
CLASS="type"
>std::string</SPAN
>      <CODE
CLASS="parameter"
>name</CODE
>,
                    <SPAN
CLASS="type"
>bool</SPAN
>             <CODE
CLASS="parameter"
>registerMe</CODE
>=<TT
CLASS="literal"
>true</TT
>);

        </PRE
>
        </P
><P
>&#13;            Constructs a new command processor.  <CODE
CLASS="parameter"
>interp</CODE
> is the
            interpreter on which the command will be registered when the
            <CODE
CLASS="function"
>Register</CODE
> member is invoked.
            <CODE
CLASS="parameter"
>name</CODE
> is the name of the command.
            If <CODE
CLASS="parameter"
>registerMe</CODE
> is not supplied or is supplied but is
            <TT
CLASS="literal"
>true</TT
>, the command will be registered as part of the construction process.
            If <CODE
CLASS="parameter"
>registerMe</CODE
> is supplied and is <TT
CLASS="literal"
>false</TT
>,
            the command is not immediately added, and <CODE
CLASS="function"
>Register</CODE
> must
            be called later to incorporate it into the interpreter.
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;<SPAN
CLASS="type"
>void</SPAN
> <CODE
CLASS="function"
>Register</CODE
>();
<SPAN
CLASS="type"
>void</SPAN
> <CODE
CLASS="function"
>unregister</CODE
>();
        </PRE
>
        </P
><P
>&#13;            <CODE
CLASS="function"
>Register</CODE
> incorporates the command into the
            interpreter.  If the command is already registered, a
            <CODE
CLASS="classname"
>CStateException</CODE
> is thrown.
        </P
><P
>&#13;            <CODE
CLASS="function"
>unRegister</CODE
> removes the command from the interpreter.
            This causes <CODE
CLASS="function"
>onUnregister</CODE
> to be called.
            if the command is registered at destruction time, destruction implies a call
            to <CODE
CLASS="function"
>unRegister</CODE
> (and therefore <CODE
CLASS="function"
>onUnregister</CODE
>).
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;<SPAN
CLASS="type"
>std::string</SPAN
> <CODE
CLASS="function"
>getName</CODE
>() const;
<SPAN
CLASS="type"
>Tcl_CmdInfo</SPAN
> <CODE
CLASS="function"
>getInfo</CODE
>() const;
        </PRE
>
        </P
><P
>&#13;            <CODE
CLASS="function"
>getName</CODE
> returns the name of the command
            that will invoke this object's <CODE
CLASS="function"
>operator()</CODE
>.
            If the command has been registered, and subsequently renamed at the
            script level, this function will reflect the rename.
        </P
><P
>&#13;            <CODE
CLASS="function"
>getInfo</CODE
> returns information about the command
            see <CODE
CLASS="function"
>Tcl_GetCommandInfo</CODE
> for more information about
            what is returned and what it means.
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;virtual <SPAN
CLASS="type"
>int</SPAN
> <CODE
CLASS="function"
>operator()</CODE
>(<SPAN
CLASS="type"
>CTCLInterpreter</SPAN
>&#38; <CODE
CLASS="parameter"
>interp</CODE
>,
                       <SPAN
CLASS="type"
>std::vector&#60;CTCLObject&#62;</SPAN
>&#38; <CODE
CLASS="parameter"
>objv</CODE
>) = 0;
        </PRE
>
        </P
><P
>&#13;            This pure virtual function must be overridden in concrete object command processors.
            The function is called to execute the command that this object is performing.
            <CODE
CLASS="parameter"
>interp</CODE
> provides a reference to the interpreter on which
            the command is being run. <CODE
CLASS="parameter"
>objv</CODE
> is a reference to a
            <SPAN
CLASS="type"
>std::vector&#60;CTCLObject&#62;</SPAN
>.
            Each element of <CODE
CLASS="parameter"
>objv</CODE
> is a <CODE
CLASS="classname"
>CTCLObject</CODE
>
            containing a word of the command line that invoked us.
        </P
><P
>&#13;            The function should return <TT
CLASS="literal"
>TCL_OK</TT
> on success and
            <TT
CLASS="literal"
>TCL_ERROR</TT
> on failure.  Other return values are possible
            for e.g. commands that implement new control structures however this is beyond
            the scope of this manpage.  If the command processor wants to make a result
            available to the interpreter, it can create a <CODE
CLASS="classname"
>CTCLResult</CODE
>
            object, fill it in and commit it.
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;virtual void onUnregister();
        </PRE
>
        </P
><P
>&#13;            This function is called when the interpreter is being destroyed or if the
            command is being unregistered either due to object destruction or a call to
            <CODE
CLASS="function"
>unregister</CODE
>.  The default behavior is to do nothing, but
            this can be overidden in your derived class if desired.
        </P
><PRE
CLASS="programlisting"
>&#13;void bindAll(CTCLInterpreter&#38; interp, std::vector&#60;CTCLObject&#62;&#38; objv);            
        </PRE
><P
>&#13;            This is a convenience method for derived classes.  It binds the
            interpreter to all of the elements of the
            <CODE
CLASS="parameter"
>objv</CODE
> vector.  Several of the methods of
            <CODE
CLASS="classname"
>CTCLObject</CODE
> require that an interpreter
            be bound.
        </P
><PRE
CLASS="programlisting"
>&#13;void requireAtLeast(std::vector&#62;CTCLObject&#60;&#38; objv, unsigned n, const char* msg=0) const;            
        </PRE
><P
>&#13;            Utility method.  Throws an <CODE
CLASS="classname"
>std::string</CODE
>
            exception if the <CODE
CLASS="parameter"
>objv</CODE
> vector does
            not have at least <CODE
CLASS="parameter"
>n</CODE
> elements.
            If <CODE
CLASS="parameter"
>msg</CODE
> is provided (non Null pointer),
            that string is incorporated in the exception string.
        </P
><PRE
CLASS="programlisting"
>&#13;void requireAtMost(std::vector&#60;CTCLObject&#62;&#38; objv, unsigned n, const char* msg=0) const;            
        </PRE
><P
>&#13;            If <CODE
CLASS="parameter"
>objv</CODE
> has more than
            <CODE
CLASS="parameter"
>n</CODE
> elements, an
            <CODE
CLASS="classname"
>std::string</CODE
> exception is thrown.  If
            <CODE
CLASS="parameter"
>msg</CODE
> is provided (not a null
            pointer) it is incorprorated into the exception string.
        </P
><PRE
CLASS="programlisting"
>&#13;void requireExactly(std::vector&#60;CTCLObject&#62;&#38; objv, unsigned n, const char* msg=0) const;            
        </PRE
><P
>&#13;            If the <CODE
CLASS="parameter"
>objv</CODE
> vector does not have exactly
            <CODE
CLASS="parameter"
>n</CODE
> elements, an <CODE
CLASS="classname"
>std::string</CODE
>
            exception is thrown.  If <CODE
CLASS="parameter"
>msg</CODE
> is supplied
            (not a null pointer), the exception string will incorporate it.
            
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN5111"
></A
><H2
>SEE ALSO</H2
><P
>&#13;CTCLCompatibilityProcessor(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
CTCLObject(3),
CTCLProcessor(3),
CTCLResult(3),
Tcl_CreateObjCommand(3tcl),
Tcl_GetCommandInfo(3tcl)
        </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="r4856.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="r5114.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CTCLException</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p4402.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CTCLProcessor</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>