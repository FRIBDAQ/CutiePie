<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CTCLHashTableIterator</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="SpecTcl Programming Reference."
HREF="index.html"><LINK
REL="UP"
TITLE="Tcl++ classes"
HREF="p4402.html"><LINK
REL="PREVIOUS"
TITLE="CTCLHashTableItem"
HREF="r6442.html"><LINK
REL="NEXT"
TITLE="CTCLString"
HREF="r6606.html"></HEAD
><BODY
CLASS="refentry"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>SpecTcl Programming Reference.</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="r6442.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="r6606.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="manpage.CTCLHashTableIterator"
></A
>CTCLHashTableIterator</H1
><DIV
CLASS="refnamediv"
><A
NAME="AEN6514"
></A
><H2
>Name</H2
>CTCLHashTableIterator&nbsp;--&nbsp;
            Iterator for visiting all elements of a <CODE
CLASS="classname"
>CTCLHashTable</CODE
>
        </DIV
><DIV
CLASS="refsynopsisdiv"
><A
NAME="AEN6518"
></A
><H2
>Synopsis</H2
><PRE
CLASS="programlisting"
>&#13;
#include &#62;TCLHashTableIterator.h&#62;
...
template &#60;class T&#62;
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator&#38; aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator&#38; aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator&#38; aCTCLHashTableIterator);
  CTCLHashTableItem&#60;T&#62;* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator&#38; operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem&#60;T&#62;&#38; operator* ();
  CTCLHashTableItem&#60;T&#62;* operator-&#62;();

};



    </PRE
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN6520"
></A
><H2
>DESCRIPTION</H2
><P
>&#13;            <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
> objects are created and returned
        by <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
>::<CODE
CLASS="function"
>begin</CODE
>
        and <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
>::<CODE
CLASS="function"
>end</CODE
>.
        These objects are pointer like objects to <CODE
CLASS="classname"
>CTCLHashTableItem</CODE
>
        objects within the hash table.
        </P
><P
>&#13;            If you imagine that all containers can have an ordering defined on them,
            iterators are like pointers to elements of this ordering.
            Dereference operators yield an element of the container, and increment operators
            make the iterator 'point' to the next element in the container according to the
            ordering.
        </P
><P
>&#13;            For more information on both hash tables and iterators see the
            REFERENCES.  For information about the classes that are related to this,
            consult manpages pointed to by the SEE ALSO section.
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN6531"
></A
><H2
>METHODS</H2
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;  <CODE
CLASS="function"
>CTCLHashTableIterator</CODE
> (<SPAN
CLASS="type"
>Tcl_HashTable</SPAN
>* <CODE
CLASS="parameter"
>pTable</CODE
>);
  <CODE
CLASS="function"
>CTCLHashTableIterator</CODE
>(const <SPAN
CLASS="type"
>CTCLHashTableIterator</SPAN
>&#38; <CODE
CLASS="parameter"
>rhs</CODE
>);
        </PRE
>
        </P
><P
>&#13;            Construct a hash table iterator.  Normally you will not need to use these
            constructors directly.  They will be created, instead by
            <CODE
CLASS="classname"
>CTCLHashTable</CODE
>::<CODE
CLASS="function"
>begin()</CODE
>
            or <CODE
CLASS="classname"
>CTCLHashTable</CODE
>::<CODE
CLASS="function"
>end()</CODE
>.
            <CODE
CLASS="parameter"
>pTable</CODE
> is a pointer to an existing <SPAN
CLASS="type"
>Tcl_HashTable</SPAN
>
            created via <CODE
CLASS="function"
>Tcl_InitHashTable</CODE
>.  <CODE
CLASS="parameter"
>rhs</CODE
>
            is an existing <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
> object whose state
            will be used to initialize the object under construction.
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;  <SPAN
CLASS="type"
>CTCLHashTableIterator</SPAN
> <CODE
CLASS="function"
>operator=</CODE
>
                     (const <SPAN
CLASS="type"
>CTCLHashTableIterator</SPAN
>&#38; <CODE
CLASS="parameter"
>rhs</CODE
>);
  <SPAN
CLASS="type"
>int</SPAN
> <CODE
CLASS="function"
>operator==</CODE
>(const <SPAN
CLASS="type"
>CTCLHashTableIterator</SPAN
>&#38; <CODE
CLASS="parameter"
>rhs</CODE
>);
        </PRE
>
        </P
><P
>&#13;            <CODE
CLASS="function"
>operator=</CODE
> allows you to assign the state of one <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
>
            to another.  When the assignment is complete, the left hand side object will
            be 'pointing' to the same object as the right hand side object but be separately
            incrementable.
        </P
><P
>&#13;            <CODE
CLASS="function"
>operator==</CODE
> allows you to compare two iterators for equality.
            equality is defined as the two iterators being defined on the same underlying
            hash table, pointing to the same element, and having the same increment context
            (e.g. an increment of both iterators will leave them both pointing to the
            same hash table item (different from the one prior to the increment).
        </P
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;<SPAN
CLASS="type"
>CTCLHashTableItem&#60;T&#62;</SPAN
>* <CODE
CLASS="function"
>getCurrentEntry</CODE
>() const;
<SPAN
CLASS="type"
>Tcl_HashTable</SPAN
>* <CODE
CLASS="function"
>getHashTable</CODE
>() const;
        </PRE
>
        </P
><P
>&#13;            These two functions get at the information the iterator is encapsulating.
            <CODE
CLASS="function"
>getCurrentEntry</CODE
> returns a pointer to the entry that
            the iterator si currently 'pointing' at.  This is identical to the
            <CODE
CLASS="function"
>operator-&#62;</CODE
> function.
            <CODE
CLASS="function"
>getHashTable</CODE
> returns a pointer to the underlying
            <SPAN
CLASS="type"
>Tcl_HashTable</SPAN
> created by <CODE
CLASS="function"
>Tcl_InitHashTable</CODE
>.
        </P
><P
>&#13;            <PRE
CLASS="programlisting"
>&#13;CTCLHashTableIterator&#38; operator++ ();
CTCLHashTableIterator operator++ (int i);
            </PRE
>
        </P
><P
>&#13;            These two function support both pre and post increment operations on an
            iterator.  There are slight differences in semantics between these
            operators best illustrated with a sample code fragment.  In the fragment
            below, i is an <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
>
            <PRE
CLASS="programlisting"
>&#13;CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment.
            </PRE
>
        </P
><P
>&#13;            <PRE
CLASS="programlisting"
>&#13;<SPAN
CLASS="type"
>CTCLHashTableItem&#60;T&#62;</SPAN
>&#38; <CODE
CLASS="function"
>operator*</CODE
> ();
<SPAN
CLASS="type"
>CTCLHashTableItem&#60;T&#62;</SPAN
>* <CODE
CLASS="function"
>operator-&#62;</CODE
>();
        </PRE
>
        </P
><P
>&#13;            These operators allow <CODE
CLASS="classname"
>CTCLHashTableIterator</CODE
> objects
            to be treated like pointers to <CODE
CLASS="classname"
>CTCLHashTableItem</CODE
> objects.
            <CODE
CLASS="function"
>operator*</CODE
> provides 'pointer' dereferencing that allows
            code like:
            <PRE
CLASS="programlisting"
>&#13;                (*i).getItem();
            </PRE
>
        </P
><P
>&#13;            <CODE
CLASS="function"
>operator-&#62;</CODE
> provides a pointer to struct like semantics
            allowing code like:
            <PRE
CLASS="programlisting"
>&#13;                i-&#62;getItem();
            </PRE
>
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN6597"
></A
><H2
>SEE ALSO</H2
><P
>&#13;CTCLHashTable(3),
CTCLHashTableItem(3),
Tcl_InitHashTable(3tcl),
Tcl_FirstHashEntry(3tcl),
Tcl_NextHashEntry(3tcl)
        </P
></DIV
><DIV
CLASS="refsect1"
><A
NAME="AEN6600"
></A
><H2
>REFERENCES</H2
><P
>&#13;        <PRE
CLASS="programlisting"
>&#13;Niklaus Wirth <CODE
CLASS="parameter"
>Algorithms + Data Structures = Programs</CODE
>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <CODE
CLASS="parameter"
>STL Tutorial and Reference Guide</CODE
>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </PRE
>
        </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="r6442.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="r6606.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CTCLHashTableItem</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="p4402.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CTCLString</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>