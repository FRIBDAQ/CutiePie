<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Programming Guide.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>June 12, 2017 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>

<chapter>
    <title>Introduction</title>
    <para>
        This book is intended to cover several topics people programming
        within the SpecTcl histogramming framework might need.  The intended audience
        are those who might be tailoring SpecTcl to analyze the data from a
        specific experiment from the NSCLDAQ as well as those who may want to
        go further.  This guide is intended to be used in conjunction with the
        programming reference manual which provides detailed class reference
        information for the key classes.
    </para>
    <para>
        Topics we are going to consider in this manual include:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='chap.processingmodel' endterm='chap.processingmodel.title' />
            </term>
            <listitem>
                <para>
                    Which covers the processing model used by SpecTcl.  This will
                    be covered in a bit greater detail than in the user guide.
                    Understanding this model, and where to attach your code
                    to it can be important to following the path of least resistance
                    in accomplishing your programming goals.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.eventprocessingpipeline' endterm='chap.eventprocessingpipeline.title' />
            </term>
            <listitem>
                <para>
                    The event processing pipeline is the set of objects that
                    transform raw events into parameters that SpecTcl processes.
                    We'll take a look at this and describe how to write event
                    process pipeline elements as well as how to prepare SpecTcl
                    to anlyze filtered data.  Along the way the SpecTclAPI object
                    will be introduced.  It provides stable interfaces to several
                    important subsystems of SpecTcl
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.eventsinkpipeline' endterm='chap.eventsinkpipeline' />
            </term>
            <listitem>
                <para>
                    The event sink pipeline takes over where the event
                    processing pipeline leaves off.  It performs all processing
                    on the unpacked event.  The built in processing includes
                    Histograming and processing any filters that are active.
                    You can, however, hook your own code to the event sink
                    pipeline.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.addingcommands' endterm='chap.addingcommands.title' />
            </term>
            <listitem>
                <para>
                    SpecTcl uses the Tcl scripting language as its base command
                    language.  There are cases where adding a compiled command
                    to SpecTcl is useful.  This chapter introduces the
                    Tcl++ C++ wrapping of the Tcl interpreter and how to use
                    it to add commands and interface with other interpreter
                    elements.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.xaminebuttonbox' endterm='chap.xaminebuttonbox.title' />
            </term>
            <listitem>
                <para>
                    Xamine is one of two displayers that SpecTcl supports. One
                    of Xamine's little known features it the ability for its
                    clients to add a set of buttons to the Xamine GUI.  This
                    chapter introduces the Xamine button box and how to use it.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.spectrumfileformat' endterm='chap.spectrumfileformat.title' />
            </term>
            <listitem>
                <para>
                    The SpecTcl <command>sread</command> and <command>swrite</command>
                    commands write spectra to file.  They have a
                    <option>-format</option> option that determines the format
                    in which spectra are written.    This chapter describes
                    how to add spectrum formats to the <command>swrite</command>
                    and <command>sread</command> commands.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.filterformat' endterm='chap.filterformat.title' />
            </term>
            <listitem>
                <para>
                    The format of files written by SpecTcl filters is extensible.
                    In this chapter we'll show how to extend the set of formats
                    available.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.fittypes' endterm='chap.fittypes.title' />
            </term>
            <listitem>
                <para>
                    The SpecTcl fitting subsystem allows you to add additional
                    fit types.  In this chapter we'll show how to add a new
                    fit-type to SpecTcl.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.dataformat' endterm='chap.dataformat.title' />
            </term>
            <listitem>
                <para>
                    SpecTcl is data acquisition system neutral.  This chapter
                    will explore how this is managed and describe how to extend
                    SpecTcl so that it can handle data from another data acquisition
                    system.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
</chapter>
<chapter id='chap.processingmodel'>
    <title id='chap.processingmodel.title'>
        The SpecTcl processing model.    
    </title>
    <para>
        This chapter describes the SpecTcl processing model.  In order to
        effectively write SpecTcl based software it is important to have some
        understanding of how SpecTcl organizes its computing.  The intent of this
        chapter is to provide an overview of this processing model.  Each of the
        remaining chapters in this book will then zoom in on one section of
        that model and describe how to write software that extends or lives inside
        of that section.
    </para>
    <para>
        The figure below graphically shows the major components of SpecTcl
        and their main interactions.
    </para>
    <figure id='fig.processingmodel' >
        <title id='fig.processingmodel.title'>SpecTcl processing model</title>
        <graphic format='PNG' fileref='processingmodel.png' />
    </figure>
    <para>
        The core of SpecTcl is a command interpreter that is an extended
        version of the Tcl/Tk scripting language (<ulink url='http://www.tcl.tk' />).
        Tcl is a general purpose programming language with a very simple syntax.
        You can learn most of what you need about Tcl in under an hour.  The Tk
        toolkit bolts on to Tcl providing a mechanism for Tcl scripts to create
        rich graphical user interfaces.
    </para>
    <para>
        SpecTcl extents the Tcl interpreter.  It adds commands to the interpreter
        that provide the ability to create and manipulate the objects SpecTcl
        needs.  The most prominent of these objects are parameters, spectra, gates
        and gate applications.  Parameters, spectra and gates are held in
        dictionaries indexed by their names.  Gate applications are stored
        with their spectra.
    </para>
    <para>
        Tcl/Tk's processing model provides an event loop.  An event loop
        reacts to events and dispatches them to appropriate handlers.
        SpecTcl's Tcl extensions establish a source of events.  When the data
        source has data avaialable, the event loop dispatches it to a processing
        pipeline.
    </para>
    <para>
        The first stage of event processing knows about the high level format of
        the data. This is used to unpack blocks of data into units that consist
        of, among other things events.  This is represented by the diagram's
        <literal>High level parsing</literal>  box.  In most cases
        you will not need to provide or modify that code.  That code only needs
        to be touched if you are adapting SpecTcl to data from a new data acquisition
        system not supported by SpecTcl.
    </para>
    <para>
        The high data parsing stage locates blocks of events (a block may be
        a single event long as it is for ring buffer data).  Events from
        this block are passed one by one to the event processing pipeline.
    </para>
    <para>
        The event processing pipeline is the code you will normally have to write.
        It takes a raw event and extracts meaningful parameters from it.
        The format of a raw event and the definition of meaningful parameter
        are both experiment specific.  
    </para>
    <para>
        The event processing pipeline consists of an arbitrary number of stages.
        Each stage has access to the raw event and to the parameters that have
        been unpacked from it by the prior stages.  Careful organization of
        the functionality of your event processors can be key both to allowing
        your detector system to be easily reconfigured and to layering the extraction
        of computed parameters on top of raw parameters in a meaningful and organized
        way.
    </para>
    <para>
        The parameters produced by the event processing pipeline are then passed
        to the event sink pipeline.  The main component of that is the
        histogramming kernel.  It uses the parameters, parameter definitions,
        spectrum definitions, gate applications and relevant gate definitions
        to determine which histograms will be incremented and where.
    </para>
    <para>
        At this point, the only other elements that live in the event sink
        pipeline are filters.  Filters produce a reduced data set by outputing
        some set of parameters for events that satisfy a gate.  It is very
        unusual for application specific code to need to add elements to the
        event sink pipeline, though that is  possible.
    </para>
    <para>
        Histograms are stored by SpecTcl as arrays of data with descriptive
        metadata.  SpecTcl has no built in visualization component.  It can
        store spectrum bulk data in a shared  memory region and supports a few
        well defined communications mechanisms that allow external displayers
        to let you visualize and interact with the data.  The two visualizers
        that are currently supported are Xamine and Spectra.  Xamine is an
        X-11/Motif application, while spectra is based on Root
        (<ulink url='http://root.cern.ch' />).
    </para>
    <para>
        We won't say anything about Spectra in this document, however
        Xamine provides hooks to allow your code to interact with it and the
        data it displays.  We'll describe how to take advantage of those
        hooks.
    </para>
</chapter>
<chapter id='chap.eventprocessingpipeline'>
    <title id='chap.eventprocessingpipeline.title'>
        The SpecTcl event processing pipeline.
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.eventsinkpipeline'>
    <title id='chap.eventsinkpipeline.title'>
        The SpecTcl event sink pipeline
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.addingcommands'>
    <title id='chap.addingcommands.title'>
        libTcl++ and adding commands to SpecTcl
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.xaminebuttonbox'>
    <title id='chap.xaminebuttonbox.title'>
        Xamine's button box
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.spectrumfileformat'>
    <title id='chap.spectrumfileformat.title'>
        Extending SpecTcl spectrum file formats
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.filterformat'>
    <title id='chap.filterformat.title'>
        Extending SpecTcl's filter file formats
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.fittypes'>
    <title id='chap.fittypes.title'>
        Extending the set of SpecTcl fit types.
    </title>
    <para>
        
    </para>
</chapter>
<chapter id='chap.dataformat'>
    <title id='chap.dataformat.title'>
        Interfacing SpecTcl with data from other data acquisition systems.
    </title>
    <para>
        
    </para>
</chapter>


</book>
