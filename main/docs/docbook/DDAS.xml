<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl DDAS Unpackers Guide.</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>August 10, 2018 and following</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>

<chapter>
    <title>Introduction></title>
    <para>
        SpecTcl's <filename>libDDASUnpacker.so</filename> library provides
        several tools that allow you to manage data from the NSCL XIA/DDAS
        data aquisition system.  This book will help you understand how to use
        those tools.  Note that there is additional documentation available
        amongst the DDASDocuments.
    </para>
    <para>
        Topics we will cover in this manual include:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='chap.ddashit' endterm='chap.ddashit.title' />
            </term>
            <listitem>
                <para>
                    Which will describe the <classname>DAQ::DDAS::DDASHit</classname>
                    class.  This class encapsulates the data from a single
                    channel of a DDAS event (or hit).
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.unpackers' endterm='chap.unpackers.title' />
            </term>
            <listitem>
                <para>
                    Will describe the two unpackers provided by SpecTcl for
                    DDAS data and when to use each one of them.  Attention
                    will be given to what you need to add to this code to
                    map DDAS hits to parameters in a SpecTcl event.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.filemapper' endterm='chap.filemapper.title' />
            </term>
            <listitem>
                <para>
                    Describes two file driven parameter mapping classes you can use
                    with the unpackers in the previous chapter to avoid having
                    to recompile SpecTcl has you modify your mappings.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='chap.reference' endterm='chap.reference.title' />
            </term>
            <listitem>
                <para>
                    Will provide reference information for the classes described
                    in the first set of chapters of this guide.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
</chapter>

<chapter id='chap.ddashit'>
   <title id='chap.ddashit.title'>The DDASHit class.</title>
   <para>
        The <classname>DAQ::DDAS::DDASHit</classname> class provides
        information about a channel from DDAS.  DDAS events are comprised
        of hits.  Each hit provides data from a single crate/slot/channel
        of the system.  If the NSCL Event builder is used hits may be aggregated
        into events based on a coincidence window on their timestamps.
   </para>
   <para>
        Several methods allow you to retrieve data from the hit or hits
        that comprise an event.  In addition, hit objects are copy-constructable and
        assignable.  We'll only look at the most common methods you'll need
        to know.  The remainder are described in the reference documentation.
   </para>
   <variablelist>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>uint32_t</type>
                <methodname> GetCrateID</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns the number of the DDAS Crate from which the hit came.
                The crate number is assigned in the <filename>cfgPixie16.txt</filename>
                file used by the Readout program that read the hit.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>uint32_t </type>
                <methodname>GetSlotID</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns the slot number from which the hit was acquired.
                Slot numbers used by a readout program are described in
                <filename>cfgPixie16.txt</filename> as well.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>uint32_t </type>
                <methodname>GetChannelID</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns the ID of the channel from which the hit came.  The
                hit origin is uniquely defined by the crate, slot and channel
                within the slot.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>double </type>
                <methodname>GetTime</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns the calibrated timestamp of the hit.  The Readout
                software produces a timestamp based on the raw timestamp that
                has been converted to nanoseconds.  This allows the comparison
                of timestamps across modules with different clock frequencies (if
                they have been synchronized).  
            </para>
            <para>
                Note that it is an integerized version
                of this calibrated timestamp that is passed to the event builder.
                This allows events to be properly built from a system with a
                heterogeneous set of digitizers..
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>uint32_t </type>
                <methodname>GetEnergy</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns the energy determined by the digital pulse processing
                algorithm of the channel.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>std::vector&lt;uint16_t&gt;&amp; </type>
                <methodname>GetTrace</methodname>
                <void />
                <modifier></modifier>
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Returns a reference to the trace data stored for the hit.
                Note that the contents of the vector should not be considered
                well defined if the channel has been programmed not to return
                traces.
            </para>
        </listitem>
    </varlistentry>
   </variablelist>
   <para>
    These are the most commonly used methods.  Note that the full
    documentation for this class is available in the reference section.
   </para>
   <para>
    The remainder of this document describes frameworks that present vectors
    of hits to code that you right or, alternatively, provide configuration files
    that describe how a simplified bit of code should operate.
   </para>
</chapter>
<chapter id='chap.unpackers'>
    <title id='chap.unpackers.title'>DDAS Data unpackers.</title>
    <para>
        DDAS data are broken up into <firstterm>hits</firstterm>. A hit is the
        data from a single channel of DDAS.  You can think of the DDAS
        readout software as delivering a stream of these hits.
        The SpecTcl DDAS software provides two event processors that can be
        used with SpecTcl.  These are:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                <classname>DAQ::DDAS::CParameterUnpacker</classname> which processes
                raw DDAS hits.  These are the units of data that come from
                a single DDAS channel. In the absence of an event builder to
                glue hits within some coincidence time intervale, events from
                DDAS look like events containing single hits.
            </para>
            <para>
                In general you will not want to use this unless you are
                taking singles data.
            </para>
        </listitem>
        <listitem>
            <para>
                <classname>DAQ::DDAS::CDDASBuiltUnpacker</classname> processes
                the output of the NSCLDAQ event builder.  Hits that satisfy
                the event builder's coincidence window are treated as a
                single event.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Both of these unpackers rely on you to provide a mapping between hits
        and SpecTcl parameters.  This mapping is performed by supplying an object
        from a class derived from <classname>DAQ::DDAS::CParameterMapper</classname>.
    </para>
    <para>
        The derived class must implement the method:
    </para>
    <methodsynopsis>
        <modifier>virtual</modifier>
        <type>void</type>
        <methodname>mapToParameters</methodname>
        <methodparam>
            <type>std::vector&lt;DAQ::DDAS::DDASHit&gt;&amp;</type><parameter>hits</parameter>
        </methodparam>
        <methodparam>
            <type>CEvent&amp;</type><parameter>rEvent</parameter>
        </methodparam>
    </methodsynopsis>
    <para>
        This method is expected to unpack the elements of the
        <parameter>hits</parameter> vector into parameters in
        <parameter>rEvent</parameter>.  Naturally <classname>CTreeParameter</classname>
        objects can be used instead to manage this unpacking.
    </para>
    <para>
        The constructors for the two unpackers are shown below along with
        a simple example that sets up the event built unpacker within
        <filename>MySpecTclApp.cpp</filename>
    </para>
    <variablelist>
        <varlistentry>
            <term><constructorsynopsis>
                <methodname>CDDASUnpacker</methodname>
                <methodparam>
                    <type>CParameterMapper&amp;</type>
                    <parameter>rParameterMapper</parameter>
                </methodparam>
            </constructorsynopsis></term>
            <listitem>
                <para>
                    Constructs the unpacker for non-event built data.
                    <parameter>rParamterMapper</parameter> is a reference
                    to a parameter mapper object as described above.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                    <methodname> CDDASBuiltUnpacker</methodname>
                    <methodparam>
                        <modifier>const</modifier>
                        <type>std::set&lt;uint32_t&gt;&amp;</type>
                        <parameter> validSourceIds</parameter>
                    </methodparam>
                    <methodparam>
                        <type>CParameterMapper&amp;</type>
                        <parameter>rParameterMapper</parameter>
                    </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor for the event built data unpacker.
                    This unpacker is more usual.  <parameter>validSourceIds</parameter>
                    are a set containint the source ids that are expected from
                    fragments in the event built data.
                    <parameter>rParameterMapper</parameter> again is a reference
                    to a parameter packer.
                </para>
                <para>
                    Note that the <classname>CDDASBuiltUnpacker</classname>
                    class will only process event fragments whose source ids
                    are in the set <parameter>validSourceIds</parameter>,
                    ignoring all fragments from other sources.  This allows
                    for mixed mode data, where some source ids are not
                    acquired using DDAS.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        Assume that <classname>MyParameterMapper</classname> is a class
        that's implemented to unpack its from DDAS for our experiment.
        The <methodname>MySpecTclApp::CreateAnalysisPipeline</methodname>
        method body might look like this:
    </para>
    <informalexample>
        <programlisting>
MyParameterMapper mapper;
std::set&lt;uint32_t&gt;  ddasIds = {1, 2, 3};   // Allowed DDAS source ids (crates).
...
MySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
{
    RegisterEventProcessor(*(new DAQ::DDAS::CDDASBuiltUnpacker(ddasIds, mapper)));
}
        </programlisting>
    </informalexample>
</chapter>
<chapter id='chap.filemapper'>
    <title id='chap.filemapper.title'><classname>CFileDrivenParameterMapper</classname></title>
    <para>
        While you can hard-code parameter unpacking, and sometimes it pays to do
        so, you can use a prebuilt <classname>CFileDrivenParameterMapper</classname>
        or <classname>CCalibratedFileDrivenParameterMapper</classname>
        object to unpack DDAS hits from either of the top level unpackers.
        This unpacker takes a description file which defines how to map
        your DDAS channels (crate/slot/channel triplets) into parameters.
        
    </para>
    <para>
        <classname>CFileDrivenParameterMapper</classname> simply unpacks raw
        parameters. <classname>CCalibratedFileDrivenParameterMapper</classname>
        provides the additional functionality of created quadratically calibrated
        raw parameters.
    </para>
    <para>
        As a bonus, objects of these classes even create tree parameters for
        each of the parameters described in its configuration file.  You can use
        this, in conjunction with the fact that tree parameters with the
        same name map to the same underlying parameters to communicate
        between your raw DDAS unpacker and subsequent event processors
        or unpackers.
    </para>
    <section>
        <title>The <classname>CFileDrivenParameterMapper</classname></title>
        <para>
            The constructor of the <classname>CFileDrivenParameterMapper</classname>
            looks like this:
        </para>
        <constructorsynopsis>
            <methodname>CFileDrivenParameterMapper</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>configFile</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Where <parameter>configFile</parameter> is the path to a configuration
            file for the parameter mapper.  The configuration file provides a mapping
            between DDAS channel triplets and parameter names.  In addition
            metadata about the channel must be provided.
        </para>
        <para>
            The configuration file is a text file that can consist of a series any of the
            following line types:
        </para>
        <variablelist>
            <varlistentry>
                <term>Empty line</term>
                <listitem>
                    <para>
                        Ignored.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Line whose first character is <literal>#</literal></term>
                <listitem>
                    <para>
                        Ignored.  Use this to comment your configuration file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Channel definition</term>
                <listitem>
                    <para>
                        These lines contain five fields.  In order there are four
                        integers and a string.  Spaces are not allowed in the string.
                    </para>
                    <para>
                        The first three fields are the channel triplet, in order, the
                        crate number, the slot number and the channel number within
                        that crate/slot pair.  The fourth field is the number of
                        bits of resolution for the digitizer channel described.
                        The last field is the name of the parameter to which the
                        DPP energy from this channel should be unpacked into.
                    </para>
                    <para>
                        Here's a sample channel definition line:
                    </para>
                    <informalexample>
                        <programlisting>
    1 2 0 16 some.channel.name
                        </programlisting>
                    </informalexample>
                    <para>
                        This line specifies that energy from
                        channel number 0 of slot 2 in crate
                        1 is 16 bits wide and should be unpacked into some.channel.name
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            When <classname>CFileDrivenParameterMapper</classname> objects are
            constructed, the configuration file is read and for eeach channel
            definition line, a tree parameter is created with the specified name
            and the specified number of bits.  When the object's
            <methodname>mapToParameters</methodname> method is invoked,
            this mapping is used to drive the interpretation of the
            <parameter>hits</parameter> parameter.
        </para>
        <para>
            During unpacking, if a channel is encountered that does not have
            a channel definition, an <classname>std::string</classname> exception
            is thrown and, in general,
            the processing of that event is aborted. Failures to parse the
            configuration file also result in <classname>std::string</classname>
            exceptions.
        </para>
        <para>
            Here's a sample use of the <classname>CFileDrivenParameterMapper</classname>
            class in the context of
            <classname>MySpecTclApp</classname>::<methodname>CreateAnalysisPipeline</methodname>.
            We are processing event built data.
        </para>
        <informalexample>
            <programlisting>
    std::set&lt;uint32_t&gt;  ddasIds = {1, 2, 3};   // Allowed DDAS source ids (crates).
    ...
    MySpecTclApp::CreateAnalysisPipeline(CAnalyzer&amp; rAnalyzer)
    {
        try {
            CFileDrivenParameterMapper* pMapper =
                new CFileDrivenParameterMapper("/user/fox/crate_1/crate1.parameters");
        }
        catch (std::string msg) {
            std::cerr &lt;&lt; msg &lt;&lt; std::endl;
            exit(EXIT_FAILURE);
        }
        RegisterEventProcessor(*(new DAQ::DDAS::CDDASBuiltUnpacker(ddasIds, *pMapper)));
    }
            </programlisting>
        </informalexample>
        <para>
            Note the use of the try/catch block to output any errors parsing the
            configuration file prior to exiting.
        </para>

    </section>
    <section>
        <title>
            <classname>CCalibratedFileDrivenParameterMapper</classname>
        </title>
        <para>
            This class produces two parameters for each hit.  The first is the
            same raw parameter <classname>CFileDrivenParameterMapper</classname>
            unpacks.  The second is a calibrated energy parameter.
        </para>
        <para>
            The calibrated enery is computed by passing the raw energy through
            a quadratic function.  The configuration file provides the
            coefficients of this function as either constants, or tree
            variable names (or a mix).  The configuration file
            also provides a more general definition of the calibrated
            treeparameter (low, high bins, and units).
        </para>
        <para>
            Construction of the
            <classname>CCalibratedFileDrivenParameterMapper</classname>
            is identical to that of <classname>CFileDrivenParameterMapper</classname>.
            We will therefore refer you to the usage examples for that
            class rather than repeating all that stuff here.
        </para>
        <para>
            The difference in usage of these to classes is the configuration
            file.  Of necessity, the
            <classname>CCalibratedFileDrivenParameterMapper</classname>,
            while following similar formatting rules requires additional
            fields of information.  
        </para>
        <para>
            Following the name of the raw parameter are the three
            coefficients for the quadratic function used to produce the
            calibrated parameter.  In order these are the constant, linear and
            quadratic coeficients.  Each field can be either a constant
            floating point or the name of a tree variable (which will
            be created if necessary).
        </para>
        <para>
            Thus linear calibration is simply a matter of providing
            a constant quadratic coefficient of <literal>0.0</literal>
        </para>
        <para>
            Following the coefficients are four fields that describe the resulting
            treeparameter.  The first three are numeric and are the low and
            high limits of the parameter and the binning.  The last is textual
            and provides the units for the parameter.  Note that the text
            <literal>""</literal> can be used if no units are required.
        </para>
        <para>
            The final field is the name of the calibrated parameter.
            As with the raw parameter, a tree parameter is created if necessary.
        </para>
        <para>
            Here's an example of configuration file lines:
        </para>
        <informalexample>
            <programlisting>
0 2 0 crate0.slot2.raw.chan0 c0.s2.ch0.const c0.s2.ch0.lin 0 0 100 100 MeV crate0.slot2
            </programlisting>
        </informalexample>
        <para>
            Note how the quadratic coefficient is constant 0?  This results in
            a linear calibration function.
        </para>
        <informalexample>
            <programlisting>
0 2 0 crate0.slot2.raw.chan0 c0.s2.ch0.const c0.s2.ch0.lin c0.s2.ch0.q 0 100 100 MeV crate0.slot2.cal.chan0                
            </programlisting>
        </informalexample>
        <para>
            The line above is a fully quadratic calibration.
        </para>
    </section>
    
</chapter>
<chapter  id='chap.reference'>
    <title id='chap.reference.title'>Reference pages.</title>
    <para>
        Note that all classed described here can be incorporated into customized
        SpecTcl by adding <literal>-lDDASUnpacker</literal> to the
        <literal>USERLDFLAGS</literal> Makefile variable in the standard
        Makefile skeleton.
    </para>
    <refentry>
        <refmeta>
            <refentrytitle>DAQ::DDAS::DDASHit</refentrytitle>
            <manvolnum>3ddasSpecTcl</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>DAQ::DDAS::DDASHit</refname>
            <refpurpose>encapsulate the data from a DDAS hit.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
#include &lt;DDASHit.h&gt;

namespace DAQ {
  namespace DDAS {
    class DDASHit { 
      public:
        uint32_t GetSlotID() const ;
        uint32_t GetCrateID() const;
        uint32_t GetChannelID() const;
        uint32_t GetEnergy() const;
        double GetTime() const;
        uint32_t GetTraceLength() const ;
        std::vector&lt;uint16_t&gt;&amp; GetTrace();
        uint32_t GetTimeHigh() const;
        uint32_t GetTimeLow() const;
        uint32_t GetTimeCFD() const;
        uint64_t GetCoarseTime() const;
        uint32_t GetFinishCode() const;
        uint32_t GetChannelLength() const;
        uint32_t GetChannelLengthHeader() const;
        uint32_t GetOverflowCode() const;
        uint32_t GetModMSPS() const ;
        int GetHardwareRevision() const;
        int GetADCResolution() const ;
        uint32_t GetCFDTrigSource() const;
        uint32_t GetCFDFailBit() const ;
        const std::vector&lt;uint16_t&gt;&amp; GetTrace() const;
        std::vector&lt;uint32_t&gt;&amp; GetEnergySums();
        const std::vector&lt;uint32_t&gt;&amp; GetEnergySums() const;
        std::vector&lt;uint32_t&gt;&amp; GetQDCSums() ;
        const std::vector&lt;uint32_t&gt;&amp; GetQDCSums() const ;
        uint64_t GetExternalTimestamp() const ;
        bool     GetADCOverflowUnderflow() const ;
        
        // Used by low level unpackers.

        void Reset();        
        void setChannel(uint32_t channel);
        void setSlot(uint32_t slot);
        void setCrate(uint32_t crate);
        void setChannelHeaderLength(uint32_t channelHeaderLength);
        void setChannelLength(uint32_t channelLength);
        void setOverflowCode(uint32_t overflow);
        void setFinishCode(bool finishCode);
        void setCoarseTime(uint64_t time);
        void setRawCFDTime(uint32_t data);
        void setCFDTrigSourceBit(uint32_t bit);
        void setCFDFailBit(uint32_t bit);
        void setTimeLow(uint32_t datum);
        void setTimeHigh(uint32_t datum);
        void setTime(double time);
        void setEnergy(uint32_t value);
        void setTraceLength(uint32_t trace);
        void setADCFrequency(uint32_t value);
        void setADCResolution(int value);
        void setHardwareRevision(int value);
        void appendEnergySum(uint32_t value);
        void appendQDCSum(uint32_t value);
        void appendTraceSample(uint16_t value);
        void setExternalTimestamp(uint64_t tstamp);
        void setADCOverflowUnderflow(bool state);
    };
  
  }
}
            </synopsis>
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This class encapsulates a decoded DDASHit.  It is filled in
                by the low level decoders using the <methodname>setXXX</methodname>
                methods.  Consumers of DDAS data use the
                <methodname>getXXX</methodname> data to fetch decoded and massaged
                data from objecgts of this class.
            </para>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                Don't be intimidated by the large number of methods this
                class provides. The <methodname>setXXX</methodname> and
                <methodname>appendXXX</methodname> methods will, in general
                not be used by you.  As such we're not going to document them
                here.  If you do need to build your own decoder, you can
                look at the code to understand what they do.
            </para>
            <para>
                For the most part you'll only need to use the first few
                methods of this class.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetSlotID</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the slot id for the module from which this
                            hit was gotten.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetCrateID() </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of the crate from which the
                            hit came.  The crate id is set in the
                            <filename>cfgPixie16.txt</filename> file that drove
                            the readout program that produced the hit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetChannelID</methodname>
                            <void ></void>
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the channel number from which this hit
                            was emitted.   Together, the triplet of crate id,
                            slot id and channel number define which channel
                            of the system produced this hit, though in systems
                            known to consist of a single crate, the crate id
                            can be ignored in general.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetEnergy</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the energey computed by the DSP and FPGA
                            for the trace captured by this channel for this
                            trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>double </type>
                            <methodname>GetTime</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the calibrated time for the hit.  This is
                            the number of nanoseconds since the last clock reset
                            and includes any correction for the CFD zero crossing
                            time.
                        </para>
                        <para>
                            The actual calibrated time determination, from
                            timestamps and cfd times depends on the module type:
                        </para>
                        <variablelist>
                                <varlistentry>
                                    <term>100MSPS Modules:</term>
                                    <listitem>
                                        <para>
                                            <informalexample>
                                                <simpara>
time = 10*((timehigh &lt;&lt; 32) + timelow)
                                                </simpara>
                                            </informalexample>
                                            
                                        </para>
                                        <para>
                                            where <literal>timehigh</literal>
                                            and <literal>timelow</literal> are the
                                            two halves of themodule's raw timestamp.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>250MSPS modules:</term>
                                    <listitem>
                                        <para>
                                            <informalexample>
                                                <simpara>
time = 8*(timehigh &lt;&lt; 32 + timelow) + 4*(timecfd/(2^14) - cfdtrigsourcebit)                                                    
                                                </simpara>
                                            </informalexample>
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>500MSPS module:</term>
                                    <listitem>
                                        <para>
                                            <informalexample>
                                                <simpara>
time = 10*(timehigh &lt;&lt; 32 + timelow) + 2*(timecfd/(2^13) + cfdtrigsourcebit - 1)
                                                </simpara>
                                            </informalexample>
                                        </para>
                                    </listitem>
                                </varlistentry>
                        </variablelist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetTraceLength</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the length of the trace data acquired by
                            the hit.  If no trace data was captured, this will
                            be <literal>0</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>std::vector&lt;uint16_t&gt;&amp; </type>
                            <methodname>GetTrace</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a reference to the trace data captured for
                            this hit.  Note this is not a <literal>const</literal>
                            reference so use this with care as it's possible
                            to use the return value to modify the trace data
                            in the object, and normally this is not desirable.
                        </para>
                        <para>
                            The method:
                        </para>
                        <methodsynopsis>
                            <modifier>const </modifier>
                            <type>std::vector&lt;uint16_t&gt;&amp; </type>
                            <methodname>GetTrace</methodname>
                            <void />
                            <modifier>const;</modifier>
                        </methodsynopsis>
                        <para>
                            Provides more protected access to the trace.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetTimeHigh</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the upper bits of the hit's raw timestamp.
                            Normally you would use <methodname>GetTime</methodname>
                            to access a calibrated timestamp.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetTimeLow</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the low order bits of a hit's raw timestamp.
                            Normally you'd use <methodname>GetTime</methodname>
                            to access a calibrated timestamp.  The calibrated
                            time also includes any appropriate CFD correction.
                            
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetTimeCFD</methodname>
                            <void ></void>
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the raw CFD correction to the timestamp.
                            Normally you'd use <methodname>GetTime</methodname>
                            to get a full calibrated timestamp.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint64_t </type>
                            <methodname>GetCoarseTime</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the calibrated time (nanoseconds) without
                            any application of a CFD correction. This timestamp
                            is sufficient for use in event building e.g.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetFinishCode</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the hit's finish code. The finish code is
                            non-zero if the firmware detected signal
                            pile-up. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetChannelLength</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the amount of raw data in the hit. This
                            is not normally useful as by the time your code
                            sees this object, the raw hit is not available to you.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetChannelLengthHeader</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the length of the raw hit header.  THis is
                            not normally useful in your code because by the time
                            you have this object the raw hit is unavailable to you.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetOverflowCode</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the overflow code from the hit.  If this is
                            non-zero, the trace at some point in the acquisition
                            window overflowed the range that could be digitized
                            by the module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetModMSPS</methodname>
                            <void />
                            <modifier>const </modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the sampling frequency of the module
                            the hit comes from in MHz. (MSPS == Mega Samples Per Second).
                            This comes from an extra data word remembered for each
                            module and added to the Pixie16 raw hit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>GetHardwareRevision</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the hardware identification/version code
                            for the module that returned this hit.  This
                            comes from data saved by Readout and added to the
                            Pixie16 raw hit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>GetADCResolution</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the ADC resolution in bits.
                             This
                            comes from data saved by Readout and added to the
                            Pixie16 raw hit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetCFDTrigSource</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the source of the CFD trigger.  This is
                            only important for 250MHz and 500Mhz modules.
                            For 250MHz modules, this indicates whether the
                            fractional time comes from the odd or even samples
                            which are processed in the CFD in parallel.
                            For the 500Mhz modules this is a value from 0-4
                            indicating which of 5 parallel CFD Branches found
                            the zero crossing. 
                        </para>
                        <para>
                            Section 4.2.3 of the Pixie-16 manual version 3
                            shows how to interpret these values along with the
                            coarse and CFD timing information. See as well
                            <methodname>GetTime</methodname> above which
                            captures the information in that section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint32_t </type>
                            <methodname>GetCFDFailBit</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>1</literal> if the CFD logic
                            in the module's FPGA could not find a zero
                            crossing for the CFD trace for this hit..
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>const </modifier>
                            <type>std::vector&lt;uint32_t&gt;&amp; </type>
                            <methodname>GetEnergySums</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the a four element vector of energy sums and the
                            baseline
                            for this hit. Note there is an overload of this
                            method that returns a non const reference (allowing
                            the values to be modified).
                        </para>
                        <para>
                            the first three elements are trailing, gap and leading sums
                            as defined by the Pixie16 manual.  The last
                            element is the DC Offset the signal is on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>const</modifier>
                            <type>std::vector&lt;uint32_t&gt;&amp; </type>
                            <methodname>GetQDCSums</methodname>
                            <void ></void>
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The Pixie16 allows the user to specify 8 regions over
                            which the wave form is summed.  This allows both the
                            computation of a QDC for the trace as well as
                            pulse shape analysis.  This returns the 8 element
                            vector containin the summed values.
                        </para>
                        <para>
                            Note that an overload supplying a writable
                            access to this vector is also provided.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>uint64_t </type>
                            <methodname>GetExternalTimestamp</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            For firmware that supports an external timestamp
                            clock, reports the time.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>bool     </type>
                            <methodname>GetADCOverflowUnderflow() </methodname>
                            <void />
                            <modifier>const </modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Obsolete.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry>
        <refmeta>
            <refentrytitle>DAQ::DDAS::DDASUnpacker</refentrytitle>
            <manvolnum>3ddasSpecTcl</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>DAQ::DDAS::DDASUnpacker</refname>
            <refpurpose>Event processor for  a sequence of DDSAS hits.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
#include &lt;DDASUnpacker.h&gt;

namespace DAQ {
  namespace DDAS {

    class CDDASUnpacker : public  CEventProcessor
    {
      public:
        CDDASUnpacker(CParameterMapper&amp; rParameterMapper);
        void setParameterMapper(CParameterMapper&amp; pParameterMapper);
        CParameterMapper&amp; getParameterMapper() const;

        virtual Bool_t operator()(const Address_t pEvent,
            CEvent&amp;         rEvent,
            CAnalyzer&amp;      rAnalyzer,
            CBufferDecoder&amp; rDecoder);

    };

  }
} 

            </synopsis>
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This unpacker unpacks a sequence of raw DDAS hits into
                SpecTcl parameters.  It operates by first creating a vector
                of <classname>DAQ::DDAS::DDASHit</classname> objects.
                That vector is than handed off to a 
                <classname>CParameterMapper</classname> object which is
                supposed to make a mapping between the data from each hit
                to SpecTcl raw parameters.
            </para>
            <para>
                This class should not be used to unpack data that has
                been formatted by the NSCL event builder.  See the
                <classname>DAQ::DDAS::DDASBuiltUnpacker</classname> for
                an unpacker that can do that.
            </para>
            <para>
                Note that this event processor could be registered to handle
                data from a source id for the Event builder Event Processsor.
            </para>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CDDASUnpacker</methodname>
                            <methodparam>
                                <type>CParameterMapper&amp; </type>
                                <parameter>rParameterMapper</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs the object.  The <parameter>rParameterMapper</parameter>
                            is a reference to an object that is from a class
                            derived from
                            <classname>DAQ::DDAS::CParameterMapper</classname> that
                            is responsible for taking data from each decoded hit
                            and turning it into a set of SpecTcl parameters.
                        </para>
                        <para>
                            Since this is a reference and the object is not
                            copy constructed (there's no requirement that it be
                            copy constructable), it is important that the
                            actual object passed remains in scope for the
                            lifetime of the unpacker object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>setParameterMapper</methodname>
                            <methodparam>
                                <type>CParameterMapper&amp;</type>
                                <parameter>rParameterMapper</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Allows you to replace the parameter mapping
                            object on the fly.
                            <parameter>rParameterMapper</parameter> refers
                            to a new parameter mapping object that will
                            replace the current one.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CParameterMapper&amp; </type>
                            <methodname>getParameterMapper() </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a reference to the current parameter mapping
                            object.  One use case for this is managing dynamic
                            parameter mappers for example:
                        </para>
                        <informalexample>
                            <programlisting>
...
CMyMapper1* mapper = new CMyMapper1;  // Derived from CParameterMapper.
...
DAQ:DDAS::DDASUnpacker unpacker(*mapper); // Initial mapper.

.... // in some other part of the program where the mapper pointer is out of scope:

CParameterMapper* pOldMapper = &amp;(unpacker.getParameterMapper());
CMyMapper2* newMapper = new CMyMapper2;
unpacker.setParameterMapper(*newMapper);
delete oldpMapper;
...

                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier> virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>operator()</methodname>
                            <methodparam>
                                <modifier>const</modifier><type> Address_t </type>
                                <parameter>pEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CEvent&amp;</type>
                                <parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CAnalyzer&amp;</type>
                                <parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CBufferDecoder&amp;</type>
                                <parameter>rDecoder</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the normal event processing method of
                            event processors. It's handed the raw data
                            from an event (<parameter>pEvent</parameter>),
                            it expects <parameter>pEvent</parameter>  to point
                            to a sequence of raw DDAS hits from the DDASReadout
                            or DDASReadout_extcl program and decodes these
                            hits into a vector of
                            <classname>DAQ::DDAS::DDASHit</classname> objects
                            which are then passed to its
                            parameter mapper object to be loaded into SpecTcl
                            parameters.
                        </para>
                        
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry>
        <refmeta>
            <refentrytitle>DAQ::DDAS::CDDASBuiltUnpacker</refentrytitle>
            <manvolnum>3ddasSpecTcl</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>DAQ::DDAS::CDDASBuiltUnpacker</refname>
            <refpurpose>Unpack ddas hits from event built data.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
                
#inlcude &lt;DDASBuiltUnpacker.h&gt;
namespace DAQ {
  namespace DDAS {    class CDDASBuiltUnpacker : public  CEventProcessor
    {

      public:
        CDDASBuiltUnpacker(const std::set&lt;uint32_t&gt;&amp; validSourceIds, 
                          CParameterMapper&amp; rParameterMapper);
        void setValidSourceIds(const std::set&lt;uint32_t&gt;&amp; validSourceIds);

        std::set&lt;uint32_t&gt; getValidSourceIds() const;

        void setParameterMapper(CParameterMapper&amp; rParameterMapper);
        CParameterMapper&amp; getParameterMapper() const;

        virtual Bool_t operator()(const Address_t pEvent,
            CEvent&amp;         rEvent,
            CAnalyzer&amp;      rAnalyzer,
            CBufferDecoder&amp; rDecoder);
    };

  } // end DDAS namespace
} // end DAQ namespace

            </synopsis>            
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                Instances of this class process event built data containing
                XIA DDAS sources.  Data from sources known not to contain
                DDAS data are ignored. 
            </para>
            <para>
                For the most part, other than the input data, this class
                operates in the same manner as
                <classname>DAQ::DDAS::DDASUnpacker</classname>,
            </para>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CDDASBuiltUnpacker</methodname>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::set&lt;uint32_t&gt;&amp;</type>
                                <parameter> validSourceIds</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CParameterMapper&amp; </type>
                                <parameter>rParameterMapper</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            <parameter>validSourceIds</parameter> represents the
                            set of event fragment source ids that are assumed
                            to contain DDAS data.  Fragments with source ids
                            not in <parameter>validSourceIds</parameter> are
                            not processsed by this event processor.  Presumably
                            another event processor works on those.
                        </para>
                        <para>
                            The <parameter>rParameterMapper</parameter>
                            is a reference to an object that is from a class
                            derived from
                            <classname>DAQ::DDAS::CParameterMapper</classname> that
                            is responsible for taking data from each decoded hit
                            and turning it into a set of SpecTcl parameters.
                        </para>
                        <para>
                            Since this is a reference and the object is not
                            copy constructed (there's no requirement that it be
                            copy constructable), it is important that the
                            actual object passed remains in scope for the
                            lifetime of the unpacker object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>setValidSourceIds</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type> std::set&lt;uint32_t&gt;&amp; </type>
                                <parameter>validSourceIds</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Replaces the set of source ids that will be processed
                            with a new set.  With a statically composed
                            DAQ you should probably never need to call this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <modifier></modifier>
                        <type>std::set&lt;uint32_t&gt; </type>
                        <methodname>getValidSourceIds</methodname>
                        <void />
                        <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the current set of valid source ids. These
                            are the data sources who's fragments will
                            <emphasis>not</emphasis> be ignored by this
                            event processor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>setParameterMapper</methodname>
                            <methodparam>
                                <type>CParameterMapper&amp; </type>
                                <parameter>rParameterMapper</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provdes a new parameter mapper object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>CParameterMapper&amp; </type>
                            <methodname>getParameterMapper</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a reference to the current parameter mapping
                            object for this object.  See
                            <classname>DAQ::DDAS::DDASUpnacker::getParameterMapper</classname>
                            for a sample use of this method.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>Bool_t </type>
                            <methodname>operator()</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type>const</type>
                                <parameter>Address_t pEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CEvent&amp;</type><parameter>rEvent</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CAnalyzer&amp;</type><parameter>rAnalyzer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CBufferDecoder&amp; </type><parameter>rDecoder</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This is the method called to process raw events
                            pointed to by <parameter>pEvent</parameter>. The
                            crate, slot and channel numbers of all raw hits are
                            marshalled into a vector of
                            <classname>DAQ::DDAS::DDASHit</classname> objects
                            which is then passed to the parameter mapping object.
                        </para>
                    </listitem>
                </varlistentry>
        </variablelist>
        </refsect1>    
    </refentry>
    <refentry>
        <refmeta>
            <refentrytitle>CFileDrivenParameterMapper</refentrytitle>
            <manvolnum>3ddasSpecTcl</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>CFileDrivenParameterMapper</refname>
            <refpurpose>Parameter mapper operating from description file.</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
#include &lt;CFileDrivenParameterMapper.h&gt;

class CFileDrivenParameterMapper : public DAQ::DDAS::CParameterMapper {

public:       
    
    CFileDrivenParameterMapper(const char* configFile);
    virtual ~CFileDrivenParameterMapper();
    virtual void mapToParameters(
        const std::vector&lt;DAQ::DDAS::DDASHit&gt;&amp; hits, CEvent&amp; rEvent
    );
};
            </synopsis>
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                If the mapping between channels and parameters is fixed, it can
                often be expressed as a configuration rather than as code.
                This <emphasis>should</emphasis> be less error prone.
            </para>
            <para>
                <classname>CFileDrivenParameterMapper</classname> captures this.
                It is a parameter mapper that processes a configuration file to
                build up a correspondence between channels and tree parameters.
                FOr each parameter, a tree parameter is created so that you don't
                have to create the parameters in a separate (e.g.
                <filename>SpecTclRC.tcl</filename>) file.
            </para>
            <para>
                The configuration file that drives this class is a simple text
                file that defines a channel's parameter name one per line.
                Each line contains 5 fields.  The first four fields are numeric
                and are, in order, the crate id, the slot id, and the
                channel id that uniquely identifies the channel, and the number
                of bits in that channel's ADC.  The final field is the name
                of the parameter that is given this parameter's raw value.
            </para>
            <para>
                Empty lines (not lines with spaces but truly empty lines). Comments
                are lines whose first character is a pound (<literal>#</literal>)
                character.
            </para>
            <para>
                Here's a sample configuration file fragment.
            </para>
            <informalexample>
                <programlisting>
#
#  Experiment xxxxxx XIA DDAS parameter mapping file
#
# crate slot channel     bits parameter name. 
     0    2     0         16  Crate0.slot2.channel0
     0    2     1         16  Crate0.slot2.channel1
...
     1    2     15        16  Crate1.slot2.channel16

     1    3     0         16  Crate1.slot3.channel0

...


                </programlisting>
            </informalexample>
            <para>
                Hopefully the meaning of this is clear.
            </para>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CFileDrivenParameterMapper</methodname>
                            <methodparam>
                                <modifier>const</modifier><type> char* </type>
                                <parameter>configFile</parameter>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Normally you only need to construct an object of this
                            type, construct the appropriate unpacker with this
                            as the parameter mapper and registser that unpacker as
                            an event processor.
                        </para>
                        <para>
                            The <parameter>configFile</parameter> parameter is the
                            path to your channel mapping configuration file.
                        </para>
                        <para>
                            Errors in the configuration file are signaled by throwing a
                            <classname>std::string</classname> exception.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>mapToParameters</methodname>
                        <methodparam>
                            <modifier>const</modifier>
                            <type>std::vector&lt;DAQ::DDAS::DDASHit&gt;&amp; </type>
                            <parameter>hits</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CEvent&amp; </type><parameter>rEvent</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis></term>
                    <listitem>
                        <para>
                            This is the unpacking method called by the
                            event processor.  It is not necessary to override this.
                            Errors in this method are signalled by throwing a
                            <classname>std::string</classname> exception.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    
    </refentry>
    <refentry>
        <refmeta>
            <refentrytitle>CCalibratedFileDrivenParameterMapper</refentrytitle>
            <manvolnum>3ddasSpecTcl</manvolnum>
        </refmeta>
        <refnamediv>
            <refname>CCalibratedFileDrivenParameterMapper</refname>
            <refpurpose>Unpack DDAS data to raw and calibrated params</refpurpose>
        </refnamediv>
        <refsynopsisdiv>
            <synopsis>
#include &lt;CCalibratedFileDrivenParameterMapper.h&gt;

class CCalibratedFileDrivenParameterMapper : public DAQ::DDAS::CParameterMapper
{
    CCalibratedFileDrivenParameterMapper(const char* filename);
    
    
    virtual void mapToParameters(
        const std::vector&lt;DAQ::DDAS::DDASHit&gt;&amp; hits, CEvent&amp; rEvent
    );    
};
            </synopsis>    
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                Provices a parameter mapper for DDAS unpacking.  The mapper
                produces both a raw energy parameter and a calibrated energy
                for each hit.  The mapping is defined by an external
                configuration file whose path is provided by the
                <parameter>filename</parameter> parameter at
                construction time.
            </para>
            <para>
                The configuration file is a text file.  Each line can consist
                of one of the following:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        An empty line with no characters.  Empty lines are ignored
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A line whose first character is a <literal>#</literal>
                        these lines are treated as comment lines, and ignored.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A hit map description line.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Hit map description lines contain, in order,
                the following whitespace
                separated fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term>Hit channel definition</term>
                    <listitem>
                        <para>
                            These are three unsigned integer fields that,
                            in order, provide the crate, slot and device channel
                            ids
                            of a DDAS input channel
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Resolution</term>
                    <listitem>
                        <para>
                            This is an unsigned integer that provides the number
                            of bits of resolution the hit's energy has (usually 16).
                        </para>                 
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Raw Parameter name</term>
                    <listitem>
                        <para>
                            This is the name of the parameter into which the
                            raw energy from the pulse processing firmware
                            will be unpacked.  If necessary, the code
                            will create a new tree parameter with this name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Calibration coefficients.</term>
                    <listitem>
                        <para>
                            These are three fields.  In order these are the
                            constant, the linear, and the quadratic coefficients.
                        </para>
                        <para>
                            Each field is either a constant double precision
                            floating point number of the name of the treevariable
                            that will hold the coefficient at run time.  Note
                            that if needed a tree variable will be created.
                            The variables created are unitless.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Calibrated parameter description</term>
                    <listitem>
                        <para>
                            The next five fields describe the calibrated parameter.
                            The first three fields are numeric and are, in order,
                            the low and high limits anticipated for the
                            parameter values and the recommended binning.
                        </para>
                        <para>
                            The next field is textual and is the parameter's
                            unit of measure (e.g. MeV).  If the parameter is
                            unitless you can use the string <literal>""</literal>.
                        </para>
                        <para>
                            Finally, the last field is textual and is the name
                            assigned to the calibrated parameter.  This name
                            and the previouisl four fields are used to
                            construct a new tree parameter.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <informalexample>
                <programlisting>
#
#   Calibrated parameter map file
#

# locn     raw name            const coeff     linear    qua lo hi bins units calibname
0 2 0 crate0.slot2.raw.chan0 c0.s2.ch0.const c0.s2.ch0.lin 0 0 100 100 MeV crate0.slot2
0 2 0 crate0.slot2.raw.chan0 c0.s2.ch0.const c0.s2.ch0.lin c0.s2.ch0.q 0 100 100 MeV crate0.slot2.cal.chan0                
                </programlisting>
            </informalexample>
        </refsect1> 
    </refentry>
</chapter>
</book>