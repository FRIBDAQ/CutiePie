<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Parallel DDASSpecTcl</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Parallel SpecTcl (version 6.0-dev)"
HREF="index.html"><LINK
REL="UP"
TITLE="How to create your thread-safe analysis pipeline"
HREF="c46.html"><LINK
REL="PREVIOUS"
TITLE="How to create your thread-safe analysis pipeline"
HREF="c46.html"><LINK
REL="NEXT"
TITLE="How to configure Parallel SpecTcl"
HREF="c191.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Parallel SpecTcl (version 6.0-dev)</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c46.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. How to create your thread-safe analysis pipeline</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c191.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN109"
>3.2. Parallel DDASSpecTcl</A
></H1
><DIV
CLASS="example"
><A
NAME="AEN111"
></A
><P
><B
>Example 3-6. Obtaining the Parallel SpecTcl skeleton</B
></P
><PRE
CLASS="programlisting"
>&#13;	    mkdir parallel
	    cd parallel
	    cp /usr/opt/spectcl/6.0-000/DDASSkel/* .
	  </PRE
></DIV
><P
>&#13;	  The skeleton consists of several files. The example has been created following the model of analysis pipeline of the one existing experiments. 
	</P
><P
></P
><UL
><LI
><P
>&#13;	      Makefile: the user needs to add the *.o of the event processor that he created. 
	    </P
></LI
><LI
><P
>&#13;	      MySpecTclapp: class to create and register the event processor(s) you need in the order you want them called. NB global static definitions are forbidden (more later).
	    </P
></LI
><LI
><P
>&#13;	      MyParameterMapper: this file doesn't need to be edited.
	    </P
></LI
><LI
><P
>&#13;	      MyParameters: class that contains the main data structure. In the example provided it contains several nested structures (ChannelData, CTreeParameter, MyPipelineData, MyParameters2).
	      In Figure 3-1, a schematic representation of the structure is showed.
	      <DIV
CLASS="figure"
><A
NAME="AEN124"
></A
><P
><B
>Figure 3-1. Schematic representation of the working components of Spectcl 5.</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="figure4.jpg"></P
></DIV
></DIV
>
	    </P
></LI
><LI
><P
>&#13;	      MyCalibrator: class that contains the user-defined event processor. NB: the structure of the class is thread-safe any modification may cause into segmentation faults and/or memory leaks.
	    </P
></LI
></UL
><P
>&#13;	  In editing <TT
CLASS="filename"
>MySpecTclApp.cpp</TT
>, you need to consider three things:
	</P
><P
></P
><UL
><LI
><P
>&#13;	      The actual event processing pipeline you are going to create.  Note that unlike SpecTcl, all pipeline
	      elements (event processors) must have names.
	    </P
></LI
><LI
><P
>&#13;	      The name of the shared object the Makefile will create.
	    </P
></LI
></UL
><P
>&#13;	  To setup the event processing pipeline you'll need to provide <TT
CLASS="literal"
>#include</TT
> directives to pull in
	  the headers for your event processors.  Don't specify absolute paths, take care of that in the Makefile.
	</P
><P
>&#13;	  Here's an example
	</P
><DIV
CLASS="example"
><A
NAME="AEN141"
></A
><P
><B
>Example 3-7. Including event processor headers</B
></P
><PRE
CLASS="programlisting"
>&#13;	    ...
	    //  Here you should include your headers for your event processors.

	    #include &#60;MyCalibrator.h&#62;
	    ...
	  </PRE
></DIV
><P
>&#13;	  The command shown is in the skeleton to indicate where to put these <TT
CLASS="literal"
>#include</TT
> directives.
	</P
><P
>&#13;	  Next, locate the class <CODE
CLASS="classname"
>MySpecTclApp</CODE
>, create and register the event processor(s) you need
	  in the order you want them called. For example,
	</P
><DIV
CLASS="example"
><A
NAME="AEN148"
></A
><P
><B
>Example 3-8. Registering MyParameters, MyParameterMapper, and the processing pipeline</B
></P
><PRE
CLASS="programlisting"
>&#13;	    void
	    CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&#38; rAnalyzer)
	    {
	    MyParameters* pParams = new MyParameters("ddas");
	    MyParameterMapper* pMapper = new MyParameterMapper(*pParams);
	    RegisterData(pMapper);
	    RegisterEventProcessor(*(new DAQ::DDAS::CDDASBuiltUnpacker({1, 2, 3 })), "Raw");
	    RegisterEventProcessor(*(new MyCalibrator()), "Cal");
	    }
	  </PRE
></DIV
><P
>&#13;	  It is fundamental to notice how objects are declared and dynamically created. Global static object are forbidden by multithreading programming. Local static object are good.
	  Declaring any of those objects without initialization outside CMySpecTclApp::CreateAnalysisPipeline would cause undefined behaviors.
	</P
><P
>&#13;	  Let's look now at the MyParameters definition.
	  <DIV
CLASS="example"
><A
NAME="AEN153"
></A
><P
><B
>Example 3-9. Definition of MyParameters.h</B
></P
><PRE
CLASS="programlisting"
>&#13;	      #ifndef MYPARAMETERS_H
	      #define MYPARAMETERS_H

	      #include &#60;config.h&#62;
	      #include &#60;TreeParameter.h&#62;
	      #include &#60;string&#62;
	      #include &#60;PipelineData.h&#62;
	      #include &#60;vector&#62;
	      #include "MyPipelineData.h"
	      #include "MyParameters2.h"

	      struct ChannelData {

	      CTreeParameter energy;
	      CTreeParameter timestamp;

	      // Initialize the TreeParameters
	      //
	      // We will create TreeParameters with names associated with
	      // the name passed in. For example, if name = "rawdata", then
	      // we will create TreeParameters with names rawdata.energy and
	      // rawdata.timestamp.
	      //
	      // \param name  name of parent in tree structure

	      ChannelData();
	      ChannelData(const ChannelData&#38; rhs);
	      void Initialize(std::string name);
	      void Reset();
	      };

	      //____________________________________________________________
	      // Struct for top-level events
	      //
	      struct MyParameters {

	      ChannelData      chan[1000];
	      CTreeParameter   multiplicity;
	      MyPipelineData   data;
	      MyParameters2    example;

	      // Ctor
	      MyParameters(std::string name);
	      // Dtor
	      ~MyParameters(){};
	      // Copy Ctor
	      MyParameters(const MyParameters&#38; rhs);

	      void Reset();
	      };
	      #endif
	    </PRE
></DIV
>
	  The most important part is the copy constructor for every structure or class we will define. This ensures that objects are correctly copied for each thread we will instantiate.
	  MyPipelineData is a special structure that contains STL vectors. I highly suggest to keep these separated from the CTreeParameters. Nesting classes in a logical data structure
	  according to tasks is a good approach for multithreading programming. Similar structure constructions can be observed for MyPipelineData and MyParameters2.
	</P
><P
>&#13;	  The core of your analysis pipeline is your MyCalibrator. Let's look at it more in details:
	  <DIV
CLASS="example"
><A
NAME="AEN157"
></A
><P
><B
>Example 3-10. Definition of MyCalibrator.h</B
></P
><PRE
CLASS="programlisting"
>&#13;	      #ifndef __MYCALIBRATOR_H
	      #define __MYCALIBRATOR_H

	      #include &#60;EventProcessor.h&#62;
	      #include &#60;TranslatorPointer.h&#62;
	      #include &#60;TCLAnalyzer.h&#62;

	      class MyParameterMapper;

	      class MyCalibrator : public  CEventProcessor
	      {
	      public:
	      MyParameterMapper* m_pParameterMapper; <A
NAME="make.dpmap"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>

	      MyCalibrator(); <A
NAME="make.dctor"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
	      MyCalibrator(const MyCalibrator&#38; rhs);
	      ~MyCalibrator();
	      virtual MyCalibrator* clone() { return new MyCalibrator(*this); }

	      void setParameterMapper(DAQ::DDAS::CParameterMapper&#38; rParameterMapper); <A
NAME="make.dsetmap"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>

	      virtual Bool_t operator()(const Address_t pEvent,  <A
NAME="make.doper"
><IMG
SRC="../images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>
	      CEvent&#38;         rEvent,
	      CAnalyzer&#38;      rAnalyzer,
	      CBufferDecoder&#38; rDecoder,
	      BufferTranslator&#38; trans,
	      long thread);
	      };
	      #endif
	    </PRE
></DIV
>
	  <DIV
CLASS="calloutlist"
><DL
COMPACT="COMPACT"
><DT
><A
HREF="x109.html#make.dpmap"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>&#13;		MyParameterMapper is the common interface class that handles the mapping between channels and data structure.
		Just for information, here the definition of the public members:
		<DIV
CLASS="example"
><A
NAME="AEN167"
></A
><P
><B
>Example 3-11. Definition of MyParameterMapper.h</B
></P
><PRE
CLASS="programlisting"
>&#13;		    ...
		    class MyParameterMapper : public DAQ::DDAS::CParameterMapper
		    {
		    public:
		    
		    MyParameters  m_params;           // reference to the tree parameter structure
		    std::map&#60;int, int&#62; m_chanMap;     // global channel index for crates
		    ...
		  </PRE
></DIV
>
		As descibed above, this file doesn't need to be modified.
	      </DD
><DT
><A
HREF="x109.html#make.dctor"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>&#13;		This is a very important part of the thread-safe code for the processor. We need an explicit declaration of the class constructor, copy constructor, destructor,
		and clone method. If one does NOT implement correctly the class, failure will occur at compilation time.
	      </DD
><DT
><A
HREF="x109.html#make.dsetmap"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>&#13;		The registration and setting of the parameter mapping is crucial for the success of Parallel SpecTcl. 
	      </DD
><DT
><A
HREF="x109.html#make.doper"
><IMG
SRC="../images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>&#13;		If compared to normal SpecTcl, the function operator requires extra arguments to for the proper definition of our multithreading program.
	      </DD
></DL
></DIV
>
	</P
><P
>&#13;	  For the implementation of MyCalibrator class:
	  <DIV
CLASS="example"
><A
NAME="AEN177"
></A
><P
><B
>Example 3-12. Definition of MyCalibrator.cpp</B
></P
><PRE
CLASS="programlisting"
>&#13;	      #include &#60;ThreadAnalyzer.h&#62;
	      #include "MyCalibrator.h"
	      #include "MyParameterMapper.h"
	      #include "MyParameters.h"
	      #include &#60;ZMQRDPatternClass.h&#62;

	      MyCalibrator::MyCalibrator()
	      {}

	      MyCalibrator::MyCalibrator(const MyCalibrator&#38; rhs)
	      {}

	      MyCalibrator::~MyCalibrator() {
	       delete m_pParameterMapper;
	      }

	      void
	      MyCalibrator::setParameterMapper(DAQ::DDAS::CParameterMapper&#38; rParameterMapper) <A
NAME="make.canonic"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>
	      {
	       m_pParameterMapper = reinterpret_cast&#60;MyParameterMapper*&#62;(&#38;rParameterMapper);
	      }

	      Bool_t
	      MyCalibrator::operator()(const Address_t pEvent,
	      CEvent&#38;         rEvent,
	      CAnalyzer&#38;      rAnalyzer,
	      CBufferDecoder&#38; rDecoder,
	      BufferTranslator&#38; trans,
	      long thread)
	      {
	       auto&#38; params = m_pParameterMapper-&#62;m_params; <A
NAME="make.params"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>

	       // loop over hits
	       for(int i= 0; i&#60;params.data.m_chanHit.size(); i++){   <A
NAME="make.loop"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>

 	          int id = params.data.m_chanHit[i];
	          double ran = ( static_cast&#60;double&#62;(rand())) / (static_cast&#60;double&#62;(RAND_MAX));

    	          if( id == 341) {   
	           if (rEvent[params.chan[id].energy.getId()].isValid()){
	           params.example.ex1.energy = (params.chan[id].energy + ran) + 0.0;
	           params.example.ex1.ecal = params.example.ex1.energy*params.example.var.var1.c1; 
	          }
	          if (rEvent[params.chan[id].timestamp.getId()].isValid()) 
	           params.example.ex1.time = params.chan[id].timestamp + 10.0;
	         }
      	       }
	       return kfTRUE;
	      };
	    </PRE
></DIV
>
	  <DIV
CLASS="calloutlist"
><DL
COMPACT="COMPACT"
><DT
><A
HREF="x109.html#make.canonic"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>&#13;		The four canonical constructor, destructor, copy constructor, and clone methods have to be standard for every event processor an user wants to define.
		The setParameterMapper definition is fundamental for the correct copy of the parameter mapper to each worker thread.
	      </DD
><DT
><A
HREF="x109.html#make.params"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>&#13;		This line dictates your entry point to access the data structure you defined in MyParameters.h. Your params object is the top tree of your nested structure.
		If ones looks back at Figure 3-1, can see the actual structure and how to access each component (in red).
	      </DD
><DT
><A
HREF="x109.html#make.loop"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>&#13;		Example of simple loop over hits. This is pretty self explanatory. One can see how the data structure has been linearized to access the members.
	      </DD
></DL
></DIV
>
	</P
><P
>&#13;	  Once you've edited everything, use make to build the shared object and don't forget to add it to the Makefile.
	</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c46.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c191.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>How to create your thread-safe analysis pipeline</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c46.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>How to configure Parallel SpecTcl</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>