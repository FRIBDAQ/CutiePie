<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>How to create your thread-safe analysis pipeline</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Parallel SpecTcl (version 6.0-dev)"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Parallel SpecTcl: an introduction"
HREF="c25.html"><LINK
REL="NEXT"
TITLE="Parallel DDASSpecTcl"
HREF="x109.html"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Parallel SpecTcl (version 6.0-dev)</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c25.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x109.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="AEN46"
></A
>Chapter 3. How to create your thread-safe analysis pipeline</H1
><P
>&#13;	Writing multithreading programs is not trivial. Problems like data races (i.e. concurrently writing and reading of data), minimize explicit sharing of writable data (i.e. if you share data,
	it should be constant), and synchronization between tasks are only several of the things to keep in mind. For this reason, I provide two basic skeletons for analysis pipeline
	(one for VMUSB events and one for DDAS built events) to guide the use to a correct way to program for Parallel SpecTcl.
      </P
><P
>&#13;	To start with, obtain the Parallel SpecTcl skeleton. This consists of the files in the VMUSBSkel (or DDASSkel) directory of the Skeleton installation tree.
	Put these files in an empty directory. For example: suppose SpecTcl is installed in /usr/opt/spectcl/6.0-000,
      </P
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN50"
>3.1. Parallel VMUSBSpecTcl</A
></H1
><DIV
CLASS="example"
><A
NAME="AEN52"
></A
><P
><B
>Example 3-1. Obtaining the Parallel SpecTcl skeleton</B
></P
><PRE
CLASS="programlisting"
>&#13;	    mkdir parallel
	    cd parallel
	    cp /usr/opt/spectcl/6.0-000/VMUSBSkel/* .
	  </PRE
></DIV
><P
>&#13;	  The skeleton consists of several files; Makefile and MySpecTclApp.cpp, CMyProcessor.cpp (which is what you want to modify for your needs) and other files that you won't need to edit.
	</P
><P
>&#13;	  In editing <TT
CLASS="filename"
>MySpecTclApp.cpp</TT
>, you need to consider three things:
	</P
><P
></P
><UL
><LI
><P
>&#13;	      The actual event processing pipeline you are going to create.  Note that unlike SpecTcl, all pipeline
	      elements (event processors) must have names. 
	    </P
></LI
><LI
><P
>&#13;	      The name of the shared object the Makefile will create.
	    </P
></LI
></UL
><P
>&#13;	  To setup the event processing pipeline you'll need to provide <TT
CLASS="literal"
>#include</TT
> directives to pull in
	  the headers for your event processors.  Don't specify absolute paths, take care of that in the Makefile.
	</P
><P
>&#13;	  Here's an example
	</P
><DIV
CLASS="example"
><A
NAME="AEN66"
></A
><P
><B
>Example 3-2. Including event processor headers</B
></P
><PRE
CLASS="programlisting"
>&#13;	    ...
	    //  Here you should include your headers for your event processors.
	    
	    #include &#60;CMyProcessor.h&#62;
	    ...
	  </PRE
></DIV
><P
>&#13;	  The command shown is in the skeleton to indicate where to put these <TT
CLASS="literal"
>#include</TT
> directives.
	</P
><P
>&#13;	  Next, locate the class <CODE
CLASS="classname"
>MySpecTclApp</CODE
>, create and register the event processor(s) you need
	  in the order you want them called. For example,
	</P
><DIV
CLASS="example"
><A
NAME="AEN73"
></A
><P
><B
>Example 3-3. Registering your event processing pipeline</B
></P
><PRE
CLASS="programlisting"
>&#13;	    ...
	    void
	    CMySpecTclApp::CreateAnalysisPipeline(CAnalyzer&#38; rAnalyzer)
	    {
	      RegisterEventProcessor(*(new CStackUnpacker), "adc-data");
	      RegisterEventProcessor(*(new CMyProcessor), "example");
	    }
	    ...
	  </PRE
></DIV
><P
>&#13;	  FYI, CStackUnpacker is the basic unpacking class for VMUSBSpecTcl that has to be defined before any user-defined processor to work correctly. For more information on VMUSBSpecTcl
	  please refer to the corresponding section in the SpecTcl manual.
	</P
><P
>&#13;	  Now let's see what the CMyProcessor class looks like.
	</P
><DIV
CLASS="example"
><A
NAME="AEN78"
></A
><P
><B
>Example 3-4. Example of CMyProcessor.h</B
></P
><PRE
CLASS="programlisting"
>&#13;	    #ifndef CMYPROCESSOR_H
	    #define CMYPROCESSOR_H

	    #include "EventProcessor.h"
	    #include "ThreadAnalyzer.h"
	    #include &#60;Event.h&#62;
	    #include &#60;TreeParameter.h&#62;

	    class CParameterMapper;

	    class CMyProcessor : public  CEventProcessor
	    {
	    public:

	    long var1;  <A
NAME="make.vars"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>
	    CTreeParameter pars;
	    CTreeParameter tmp;
	    CTreeVariable vars;

	    CMyProcessor(); <A
NAME="make.ctor"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
	    CMyProcessor(const CMyProcessor&#38; rhs);
	    virtual ~CMyProcessor();
	    virtual CMyProcessor* clone() { return new CMyProcessor(*this); }

	    void setParameterMapper(DAQ::DDAS::CParameterMapper&#38; rParameterMapper){}; <A
NAME="make.map"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>

	    virtual Bool_t operator()(const Address_t pEvent, <A
NAME="make.oper"
><IMG
SRC="../images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
>
	    CEvent&#38;         rEvent,
	    CAnalyzer&#38;      rAnalyzer,
	    CBufferDecoder&#38; rDecoder,
	    BufferTranslator&#38; trans,
	    long thread);

	    virtual Bool_t OnInitialize(); <A
NAME="make.other"
><IMG
SRC="../images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
>

	    };

	    #endif
	  </PRE
></DIV
><DIV
CLASS="calloutlist"
><DL
COMPACT="COMPACT"
><DT
><A
HREF="c46.html#make.vars"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>&#13;	      In this section the CTreeParameter, CTreeVariable, and support variables are be defined. In the implementation file, one can see how the
	      CTreeParameter tmp is used as copy of another CTreeParameter.
	    </DD
><DT
><A
HREF="c46.html#make.ctor"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>&#13;	      This is a very important part of the thread-safe code for the processor. We need an explicit declaration of the class constructor, copy constructor, destructor, and clone method.
	      If one does NOT implement correctly the class, failure will occur at compilation time.
	    </DD
><DT
><A
HREF="c46.html#make.map"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>&#13;	      Although there is no explicit mapping declaration inside CreatePipelineAnalysis for VMUSBSpecTcl, this declaration is fundamental for the compilation of the code. For more details on
	      the reason of its importance, come to my office and I'll explain it to you (hint: implementation of a method for a pure virtual function).  
	    </DD
><DT
><A
HREF="c46.html#make.oper"
><IMG
SRC="../images/callouts/4.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(4)"></A
></DT
><DD
>&#13;	      If compared to normal SpecTcl, the function operator requires extra arguments to for the proper definition of our multithreading program.
	    </DD
><DT
><A
HREF="c46.html#make.other"
><IMG
SRC="../images/callouts/5.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(5)"></A
></DT
><DD
>&#13;	      These are the classic method that SpecTcl offers OnInitialize, OnBegin, OnEnd... It's up to the user knowing if the analysis code needs them or not.
	    </DD
></DL
></DIV
><DIV
CLASS="example"
><A
NAME="AEN97"
></A
><P
><B
>Example 3-5. Example of CMyProcessor.cpp</B
></P
><PRE
CLASS="programlisting"
>&#13;	    #include "CMyProcessor.h"
	    #include &#60;CRingBufferDecoder.h&#62;
	    #include &#60;SpecTcl.h&#62;
	    #include &#60;sstream&#62;
	    #include &#60;iomanip&#62;
	    #include &#60;cmath&#62;

	    CMyProcessor::CMyProcessor():
	    var1(0)
	    {}

	    CMyProcessor::CMyProcessor(const CMyProcessor&#38; rhs):
	    var1(rhs.var1)
	    {}

	    CMyProcessor::~CMyProcessor()
	    {}

	    Bool_t
	    CMyProcessor::operator()(const Address_t pEvent,
	    CEvent&#38;         rEvent,
	    CAnalyzer&#38;      rAnalyzer,
	    CBufferDecoder&#38; rDecoder,
	    BufferTranslator&#38; trans,
	    long thread)
	    {
	    if (tmp.isValid()){  <A
NAME="make.ex"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>

	    pars = tmp + vars*var1;

	    }

	    return kfTRUE;
	    }

	    Bool_t
	    CMyProcessor::OnInitialize() <A
NAME="make.oninit"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
>
	    {
	    tmp.Initialize("adc1.06");
	    pars.Initialize("test_var", 16384, 0.0, 16383.0, "");
	    vars.Initialize("const", 10, "");
	    if (!tmp.isBound())
	    tmp.Bind();
	    if (!pars.isBound())
	    pars.Bind();

	    return kfTRUE;
	    }
          </PRE
></DIV
><DIV
CLASS="calloutlist"
><DL
COMPACT="COMPACT"
><DT
><A
HREF="c46.html#make.ex"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>&#13;	      A simple example of parameter calibration based on a previously defined CTreeParameter (tmp), CTreeVariable (vars), and a long variable (var1).
	    </DD
><DT
><A
HREF="c46.html#make.oninit"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>&#13;	      After the Parallel SpecTcl app is built and started, a few CTreeParameter and CTreeVariable are initialized. To make the example complete, we initialized tmp
	      as a copy of the CTreeParameter associated to the ADC channel number 6, pars as a new CTreeParameter that will correspond to some calibrated quantity, and vars
	      as a CTreeVariable for the calibration process. Note that the two defined new CTreeParameter are bound at this stage as well. 
	    </DD
></DL
></DIV
><P
>&#13;	  Once you've edited everything, use make to build the shared object and don't forget to add it to the Makefile.
	</P
><P
>&#13;	  NB: If you have a more complex structure for your calibration parameters please look at the DDASSkel example for more details.
	</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c25.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x109.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Parallel SpecTcl: an introduction</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Parallel DDASSpecTcl</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>