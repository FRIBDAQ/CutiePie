<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Client Display Interface and Headless SpecTcl</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>October 27, 2021</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
       <title>INTRODUCTION</title>
       <para>
        This document is intended for the following audiences:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Users of NSCLDAQ that want a persistent SpecTcl to run under
              the NSCLDAQ-12+ experiment manager.
           </para>
        </listitem>
        <listitem>
           <para>
              Users of SpecTcl that want to start up a remote displayer.  This
              includes users of SpecTcl within the NSCLDAQ-12+ experiment manager
              environment.
           </para>
        </listitem>
        <listitem>
           <para>
               Users of SpecTcl that want to remote control a SpecTcl that may
               be running headless in the experiment manager environment.
           </para>
        </listitem>
        <listitem>
           <para>
              Programmers that want to write their own displayers or otherwise
              gain access to the SpecTcl display memory.
           </para>
        </listitem>
        <listitem>
           <para>
              Programmers that need to know the structure of the SpecTcl display
              memory.
           </para>
        </listitem>
       </itemizedlist>
    </chapter>
    <chapter>
       <title>Running SpecTcl Within the NSCLDAQ-12.0+ Experiment Manager.</title>
       <para>
        NSCLDAQ-12.0 introduced an experiment manager. The experiment manager
        allows an experiment to break out of the use of a single account.
        The manager gets started by a user and it  runs programs as needed in the
        background.   The configuration of the programs managed by the program
        manager is defined in an SQLite3 database file.   Editor programs
        allow this database to be modified to describe the programs
        that must be run, and when to run them.  
       </para>
       <para>
        The manager is a server that exports a REST service that supports
        control of the manager.    The manager is, at its heart, a state machine.
        It has a well defined, finite set of states, and well defined transitions
        between those states.   As the manager transitions from one state to the
        next, it runs a set of programs triggered by each transition.  The
        manager is also container aware and programs can be run inside of
        persistent containers that it maintains.
       </para>
       <para>
        You may want to run one or more SpecTcl analysis programs under the control
        of this manager.  If you do that, other chapters in this document
        describe how to run displayers (to visualize the spectra SpecTcl is
        accumulating and the displayable gates), as well as how to control
        these SpecTcl instances with existing graphical user interfaces.
       </para>
       <para>
        SpecTcl, itself, when run under the manager must be run headless.
        This specifically means that:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              You must not allow a histogram visualization program (Displayer)
              to run. 
           </para>
        </listitem>
        <listitem>
           <para>
              <filename>SpecTclRC.tcl</filename>  must not start any graphical
              user interface windows and, in fact, may not require the package
              <literal>Tk</literal>.
           </para>
           <para>
            In order to visualize spectra in systems that are remote from
            SpecTcl, you shouild start the mirror server and REST server.
           </para>
           <para>
            In order to control SpecTcl, you should run its REST server.
           </para>
        </listitem>
       </itemizedlist>
        <para>
            This implies specialized <filename>SpecTclInit.tcl</filename>,
            <filename>SpecTclRC.tcl</filename>.
        </para>
        <para>
            Since program definitions for the experiment manager support
            specifying the working directory of a program, you can, very easily,
            have a separate working directory for interactive SpecTcls and
            managed SpecTcls.  Let's consider, therefore, the following directory
            tree.  <filename>SpecTcl</filename> has the SpecTcl program.
            <filename>SpecTcl/interactive</filename> is the directory from
            which SpecTcl can be run interactively.  It contains the
            normal set of <filename>SpecTclInit.tcl</filename> and
            <filename>SpecTclRC.tcl</filename> scripts you usually use
            to run SpecTcl and has a symbolic link named SpecTcl that points back
            to the executable for SpecTcl.
            Similarly, <filename>SpecTcl/managed</filename>, which we will descrribe
            has <filename>SpecTclRC.tcl</filename> and <filename>SpecTclInit.tcl</filename>
            files as well as its own symbolic link back to the executable.
        </para>
        <para>
            The remainder of this chapter will show example
            <filename>SpecTclInit.tcl</filename> and <filename>SpecTclRC.tcl</filename>
            that will work togethr
            to start SpecTcl under the manager.  We'll also describe how
            to setup SpecTcl within the program manager so that it starts when
            the experiment is booted and stops when it is shutdown.
            This will require two more scripts: <filename>stop.bash</filename> and
            <filename>stop.tcl</filename> in the <filename>SpecTcl/managed</filename>
            directory which we will describe.
        </para>
        <section>
            <title>SpecTclInit.tcl in Managed SpecTcl</title>
            <para>
                SpecTclInit.tcl contains
                variable definitions that SpecTcl examines on
                startup.  These variable definitions control how SpecTcl
                starts up the three definitions we'll need to set properly are:
            </para>
            <variablelist>
                <varlistentry>
                   <term><varname>DisplayType</varname></term>
                   <listitem>
                       <para>
                        This variable determines which of the SpecTcl displayers
                        is started by SpecTcl when it starts.  The value of
                        <literal>none</literal> tells SpecTcl not to start any
                        displayer program.  
                       </para>
                       <para>
                        Note that SpecTcl will still create display shared memory
                        so clients can access the spectra the user has bound
                        into the display memory via <command>sbind</command>.
                        The shared memory region can also be mirrored to remote
                        systems if desired.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><varname>HTTPDPort</varname></term>
                   <listitem>
                       <para>
                        If this variable is defined, SpecTcl will start it's
                        REST server allowing remote control over SpecTcl. With
                        SpecTcl run in the manager, this is the only way to
                        provide a user interface to SpecTcl.  
                       </para>
                       <para>
                        The value of this variable must be in integer.  In the
                        environment of the NSCLDAQ experiment manager, it is
                        recommended that, rather than hard-coding a numerical port,
                        you use the NSCLDAQ port manager to allocate a port and
                        advertise a named service.  We'll describe this process
                        the sample <filename>SpeTclInit.tcl</filename> below.
                       </para>
                       <para>
                        If you do choose to hard code a port number, this value must
                        be unique <emphasis>system wide over all users</emphasis>.
                        If you provide a duplicate port number, you'll wind up starting
                        the REST server on a 'nearby' free port.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><varname>MirrorPort</varname></term>
                   <listitem>
                       <para>
                        If this variable is defined, SpecTcl will start its
                        mirror server.  The mirror server supports remote displayers
                        by providing the ability to create and maintain a mirror of
                        the SpecTcl  display memory on a remote or local system.
                       </para>
                       <para>
                        Under the manager, at FRIB/NSCL, SpecTcl is normally
                        run containerized, and the experiment manager uses persistent
                        containers to accomplis that.   Since persistent containers
                        have their own, private namespace of SYS-V shared memory
                        segments used by SpecTcl for display shared memory,
                        you will need to create a mirror in the local host to
                        allow non-containerized programs or programs in transient
                        containers (<command>singularity shell</command>) to
                        attach displayers to SpecTcl.
                       </para>
                       <para>
                        Mirroring and attached displayers to mirror will be
                        described in the next chapter.
                       </para>
                       <para>
                        As with <varname>HTTPDPort</varname>, this value  should,
                        in most cases be gotten with the NSCLDAQ port manager as
                        it must be a unique integer system wide.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                In the remainder of this section, we will provide a
                sample <filename>SpecTclInit.tcl</filename> file and
                walk through how it works.  In doing so, we will use the port
                manager to get our server ports.  Doing so requires that 
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      The SpecTcl Tcl library directory must be added to the
                      Tcl intepreter package search path.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      The NSCLDAQ-12.0+ environment is set up in the
                      container via its initialization script
                      (e.g. the initialization script source /usr/opt/daq/12.something/daqsetup.bash)
                   </para>
                </listitem>
                <listitem>
                   <para>
                      The value of the environment variable
                      <varname>DAQTCLLIBS</varname> is appended to the
                      Tcl interpreter search path so that the required Port manager
                      interaction  packages can be sourced in.
                   </para>
                </listitem>
            </orderedlist>
            <example>
                <title>Sample SpectclInit.tcl for Experiment Manager</title>
                <programlisting>
lappend auto_path [file join $SpecTclHome TclLibs]   <co id='mgrinit.spectcltcllibs' />
if {[array names env DAQTCLLIBS]  ne ""} {           <co id='mgrinit.daqtcllibs' />
    lappend auto_path $env(DAQTCLLIBS)
}
package require DAQService                          <co id='mgrinit.daqservice' />
set HTTPDPort [SpecTcl::getServicePort SpecTcl_REST]   <co id='mgrinit.restport' />
set MirrorPort [SpecTcl::getServicePort SpecTcl_MIRROR] <co id='mgrinit.mirrorport' />
set DisplayType none                                <co id='mgrinit.nodisplay' />

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='mgrinit.spectcltcllibs' >
                    <para>
                        The Tcl variable <varname>SpecTclHome</varname> is defined
                        at SpecTcl's compile and initialization time to be the
                        top level installation directory of SpecTcl.  This
                        line adds the <filename>TclLibs</filename> subdirectory
                        to the Tcl library search path (<varname>auto_path</varname>).
                        The <filename>TclLibs</filename> contains the SpecTcl
                        Tcl library of support packages
                    </para>
                </callout>
                <callout arearefs='mgrinit.daqtcllibs' >
                    <para>
                        This segment of the script determines if the environment
                        variable <varname>DAQTCLLIBS</varname> has been defined and,
                        if so, appends it to the Tcl package  search path.
                        The NSCLDAQ 12.0+ <filename>daqsetup.bash</filename> script
                        defines <varname>DAQTCLLIBS</varname> to point to the
                        NSCLDAQ Tcl package library directory tree.
                    </para>
                    <para>
                        We don't exit if this is not the case as there are
                        other mechanisms to add the DAQ Tcl library packages to
                        the search path (e.g. externally defining
                        <varname>TCLLIBPATH</varname>).
                    </para>
                </callout>
                <callout arearefs='mgrinit.daqservice' >
                    <para>
                        The <literal>DAQService</literal> package is a package
                        in the SpecTcl Tcl package library that provides a simplified
                        interface to the NSCLDAQ Port manager for advertising
                        services and obtaining the port allocated.  Note that since
                        this depends on the low-level NSCLDAQ port manager package,
                        we needed, as we did previously, add the NSCLDAQ Tcl library
                        packages to the Tcl interpreter package search paths.
                    </para>
                </callout>
                <callout arearefs='mgrinit.restport' >
                    <para>
                        The <literal>DAQService</literal> package exports the
                        <command>SpecTcl::getServicePort</command> proc.
                        This proc takes a service name as a parameter and returns
                        the port that has been allocated to that service by
                        the port manager.  Service names shouild be unique
                        with <emphasis>users</emphasis> requesting them.
                    </para>
                    <para>
                        This line advertises the service <literal>SpecTcl_REST</literal>
                        and assigns the resulting port to <varname>HTTPPort</varname>.
                        The service can be looked up by clients and the resulting
                        port then used to connect to the REST server that
                        SpecTcl will start listening for connections on that port/
                    </para>
                </callout>
                <callout arearefs='mgrinit.mirrorport' >
                    <para>
                        Similarly, the service <literal>SpecTcl_MIRROR</literal>
                        is advertised and the resulting port set to the
                        <varname>MirrorPort</varname> so that when SpecTcl
                        starts its mirror service it will be listening on the
                        corresponding port.
                    </para>
                </callout>
                <callout arearefs='mgrinit.nodisplay' >
                    <para>
                        Setting the <varname>DisplayType</varname> to
                        <literal>none</literal> means that SpecTcl will not
                        start a spectrum display program but it will, nonetheless,
                        create the spectrum shared memory so that local clients
                        can display data from it and remote clients, upon setting up
                        a mirror, can also display data from it.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
           <title>SpecTclRC.tcl for Managed SpecTcl</title>
           <para>
            <filename>SpecTclRC.tcl</filename> should be very minimal.
            This is because in most cases, users use <filename>SpecTclRC.tcl</filename>
            to create graphical user interfaces (GUIs) which managed SpecTcl's
            cannot display.  A later chapter will describe how to run
            these as clients of the SpecTcl REST server.
           </para>
           <para>
            We recommend using SpecTclRC.tcl to:
           </para>
           <itemizedlist>
            <listitem>
               <para>
                  Read in a SpecTcl configuration file, and bind its spectra into
                  the SpecTcl shared memory region.
               </para>
            </listitem>
            <listitem>
               <para>
                  Read in any non-interactive scripts your GUI's might use
                  that would run better locally than remotely (see, however
                  the chapter on running scripts remotely).
               </para>
            </listitem>
            
           </itemizedlist>
           <example>
            <title>
                Sample SpecTclRC.tcl Script for Managed SpecTcl.
            </title>
            <programlisting>
source mydefinitions.tcl     <co id='managed.rcdefs' />
sbind -all                   <co id='managed.rcsbind' />
source mylocalprocs.tcl      <co id='managed.rclocalprocs' />

set pidfile [open spectclpid w]
puts $pidfile [pid]          <co id='managed.rcpid' />
close $pidfile

            </programlisting>
           </example>
           <calloutlist>
            <callout arearefs='managed.rcdefs' >
                <para>
                    Reads in a SpecTcl definition file that contains tree parameter
                    definitions, spectrum definitions, gate definitions and
                    applications as well as tree variable values.
                </para>
            </callout>
            <callout arearefs='managed.rcsbind' >
                <para>
                    Binds all the spectra defined in <filename>mydefinitions.tcl</filename>
                    to the display shared memory.  This makes them visible
                    to local displayers attached to SpecTcl as well as remote
                    displayers when mirroring has been started to the remote
                    system.
                </para>
            </callout>
            <callout arearefs='managed.rclocalprocs' >
                <para>
                    Sources in any Tcl procedures you want SpecTcl to hold locally.
                    These may be procs that are invoked by SpecTcl's compiled
                    code or utilities that your GUI scripts use that will run
                    better or faster locally rather than remotely.
                </para>
                <para>
                    It's perfectly normal and acceptable for a line like this
                    to be omitted.
                </para>
            </callout>
            <callout arearefs='managed.rcpid' >
                <para>
                    Records the process id of SpecTcl in the file
                    <filename>spectclid</filename>.  This allows us to
                    define a command in the manager to kill SpecTcl when the
                    system is shutting down.
                </para>
            </callout>
           </calloutlist>
        </section>
        <section>
           <title>Defining SpecTcl to the Manager.</title>
           <para>
            Using SpecTcl with the NSCLDAQ experiment manager means defining it as
            a program as well as defining a program to stop it.  It then means
            attaching the start program to the <literal>BOOT</literal>
            state transition and attaching the stop program to the
            <literal>SHUTDOWN</literal> transition.
           </para>
           <para>
            Throughout this section, we will assume that
            <filename>SpecTclRC.tcl</filename> will create a file named
            spectclpid in its working directory that will contain its process ID.
           </para>
        </section>
        <section>
            <title>Starting SpecTcl in the Manager</title>
            <para>
                Use the <filename>$DAQBIN/mg_config</filename> progream specifying as
                a parameter the name of the manager's configuration database file.
                When the list of configuration options pops up, double click on
                <literal>Programs</literal> to define the SpecTcl program.
            </para>
            <para>
                When the list of defined programs pops up, click the
                <guibutton>New...</guibutton> button to bring up the program editor.
                Fill in the following fields in the editor as follows::
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>Name:</literal></term>
                   <listitem>
                       <para>
                        A unique program name such as <literal>SpecTcl</literal>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Host</literal></term>
                   <listitem>
                       <para>
                        DNS name of the computer on which you want SpecTcl to run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Working Directory</literal></term>
                   <listitem>
                       <para>
                        The <filename>SpecTcl/managed</filename> director in which
                        you put your <filename>SpecTclInit.tcl</filename> and
                        <filename>SpecTclRC.tcl</filename> scripts for managed
                        Spectcl.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Program File:</literal></term>
                   <listitem>
                       <para>
                        The path to the SpecTcl you want to run.  This
                        can be releative.  If you created the symlink to
                        the SpecTcl executable you want to run this can be e.g.
                        <literal>./SpecTcl</literal>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Container</literal></term>
                   <listitem>
                       <para>
                        If you want SpecTcl to run in a container, this should be
                        the name of a container that you defined earlier.
                        If left blank, SpecTcl will run in native mode.
                        The container should have a startup script that
                        sources in the NSCLDAQ Environment definition script,
                        see, however, below.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>Type:</literal></term>
                   <listitem>
                       <para>
                        Select the <literal>Persistent</literal> radio button
                        to indicate that SpecTcl is expected to persist but
                        that the data flow can continue if it exits.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                If your container or other environment do not define
                DAQTCLLIBS as expected by the <filename>SpecTclInit.tcl</filename>
                script we created, you can use the
                <literal>Program Environment</literal> editor section to set this
                or, alternatively <literal>TCLLIBPATH</literal>.
            </para>
            <para>
                Click <guibutton>Ok</guibutton> to save the definition and close
                the program list.
            </para>
            <para>
                Having create the program you need to add it to a sequence triggered
                by Boot.
                Double click the <literal>Sequence Definition</literal> entry in
                the top level window.  If there is no sequence triggered by
                booting the system, type <literal>BOOT</literal> in the
                <literal>New sequence:</literal> entry.  Pull down the
                <literal>Trigger state:</literal> drop down menu and select
                <literal>BOOT</literal> then click <guibutton>Add</guibutton>
                to add the sequence.
            </para>
            <para>
                Double click <literal>BOOT</literal> from the list of sequences
                to pop up the sequence editor.  In the <literal>Program name</literal>
                pulldown, select <literal>SpecTcl</literal> (or the name you gave
                to your SpecTcl program definition.  Click <guibutton>Add</guibutton>
                to add this to the <literal>BOOT</literal> sequence and
                click <guibutton>SAVE</guibutton> to save the modified sequence.
            </para>
            <para>
                You also need to kill SpecTcl when the experiment is <literal>Shutdown</literal>.
                Define a program with the same attributes as your SpecTcl program
                however:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                      Select a <literal>Transitory</literal>  program type.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      For the <literal>Program File:</literal> enter:
                      <literal>kill -9 `cat spectclpid`</literal>
                   </para>
                </listitem>
            </itemizedlist>
            <para>
                Add this to a sequence that's triggerd by the <literal>SHUTDOWN</literal>
                transition.  Since the programs run as shell commands this works to
                send a <literal>SIGKILL</literal> signal to the program whose
                PID is stored in the <filename>spectclpid</filename> file the
                SpecTcl <filename>SpecTclInit.tcl</filename> sample file written
                when SpecTcl started.  A key point is that the <literal>Program File:</literal>
                is actually a line that's submitted to a <literal>bash</literal>
                shell for execution on the specified host
                (possibly within the containerized environment).
            </para>
        </section>
    </chapter>
    <chapter>
       <title>Starting a Remote Displayer With xaminerunner</title>
       <para>
        Once you have a headless SpecTcl running you will, at some point in time,
        probably want to look at the spectra it produces.  This can be done by
        running a supported Displayer program such as <literal>Xamine</literal>
        or <literal>CutiePie</literal> and attaching it to the local SpecTcl
        shared memory region (if SpecTcl is running locally) or a mirror
        managed by the mirror server if SpecTcl is remote.
       </para>
       <para>
        This chapter describes a helper program that's installed in SpecTcl's
        <filename>bin</filename> directory called <literal>xaminerunner</literal>
        that simplifies this process for the Xamine displayer. It does the
        following:
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Figures out if SpecTcl is running remotely and, if so, sets up
              a mirror, if one does not already exist, of the SpecTcl shared
              memory in the local host.
           </para>
        </listitem>
        <listitem>
           <para>
              Sets up the environment variables Xamine needs to locate the shared
              memory it's supposed to map accordingly and starts Xamine.
           </para>
        </listitem>
        <listitem>
           <para>
              Accepts Xamine gate creation communications and maps them into the
              appropriate SpecTcl REST requests to create those gates in
              SpecTcl.
           </para>
        </listitem>
        <listitem>
           <para>
              Captures new gates and new sbind operations and communiates with
              Xamine so that the gates it displays accurately reflect the
              gates that can be displayed on the spectra bound to the shared
              memory.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        <literal>xaminerunner</literal> requires the SpecTcl REST server be running.
        If SpecTcl is in a remote system it must also be running the Mirror server.
       </para>
       <para>
        <literal>xaminerunner</literal> is located in
        <filename>$SpecTclHome/bin/xaminerunner</filename>, where <literal>SpecTclHome</literal>
        is the top level of a SpecTcl installation version 5.10 or later.
        It's operation is controlled by command line options.  If SpecTcl is
        running under NSCLDAQ and advertising services via the NSCLDAQ port
        manager (as descrdibed in the previous chapter), to do named service lookup,
        you must have setup the environment variables of an NSCLDAQ installation
        before running <literal>xaminerunner</literal> (sourced <filename>daqsetup.bash</filename>).
       </para>
       <para>
        Here are the command options accepted by <literal>xaminerunner</literal>:
       </para>
       <variablelist>
        <varlistentry>
           <term><option>--host</option>=<replaceable>DNS-or-IP</replaceable></term>
           <listitem>
               <para>
                This mandatory option provides the host in which SpecTcl is
                running.  The value of this option can be either a
                DNS hostname that can be resolved by DNS on the system in which
                you are running <literal>xaminerunner</literal> or an IP address.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><option>--port</option>=<replaceable>rest-port-or-service</replaceable></term>
           <listitem>
               <para>
                This required option
                provides information about the port on which the SpecTcl REST
                server is running.  This can be either a numeric port numer or,
                if NSCLDAQ's environment variables have been set up and SpecTcl
                is using the NSCLDAQ port manager to advertise the REST
                service, the name of the service that is being advertised.
                See also <option>--user</option>
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><option>--mirror</option>=<replaceable>mirror-port-or-service</replaceable></term>
           <listitem>
               <para>
                This option is required if SpecTcl is running remotely.  It's value
                is interpreted in the same manner as
                <option>--port</option> but is the port on which SpecTcl's mirror
                server is listening.  If SpecTcl is local its mirror server will
                only be contacted if SpecTcl is runnning in a persistent container
                (e.g. by the NSCLDAQ experiment manager) in which case its shared
                memory is invisible outside of the container.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><option>--user</option>=<replaceable>service-username</replaceable></term>
           <listitem>
               <para>
                This optional option is only used if service names advetiased
                by the NSCLDAQ port manager are used for either the
                <option>--port</option> or <option>--mirror</option> options.
                Service names in NSCLDAQ are qualified by the user advertising them.
                This option supplies the name of the user running SpecTcl.  This is
                intended for use in the experiment environment.  When running
                an experiment, several users collaborate.  One user has started
                SpecTcl under the experiment manager, but others may wish
                to visualize and interact with the spectra SpecTcl creates.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
       
    </chapter>
    <chapter>
       <title>Running Spectcl Scripts Remotely Via the REST Server</title>
       <para>
        Especially within the experiment manager, SpecTcl can be run without
        a controlling terminal.  In that case, it is necessary to use the
        REST interface to tell SpecTcl what to do.  The Tcl REST client API
        is implemented as two packages:
       </para>
       <variablelist>
        <varlistentry>
           <term><literal>SpecTclRestClient</literal></term>
           <listitem>
               <para>
                Provides an object oriented interface to the REST services
                offered by SpecTcl.  This interface can be used by scripts that know
                they will be running as REST clients.  The Reference pages in
                the appendices will describe the API offered by this package.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><literal>SpecTclRestCommand</literal></term>
           <listitem>
               <para>
                Uses <literal>SpecTclRestClient</literal> to implement all of
                SpecTcl's commands.  This makes it possible to frame existing
                user interface scripts with a simple start up script to run
                them as REST clients.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
       <para>
        Let's start by looking at a simple framing script that starts the
        SpecTcl Tree parameter graphical user interface -- but as a REST client.
        Following a discussion of that script, we'll describe some of the differences
        between SpecTcl's native commands and the SpecTcl REST command simulation.
       </para>
       <example>
        <title>Running the Tree Parameter GUI as a REST client</title>
        <programlisting>
package require Tk                              <co id='resttree.tk' />

set SpecTclHome /usr/opt/spectcl/5.10-000       <co id='resttree.auto_path'/>
lappend auto_path [file join $SpecTclHome TclLibs]

package require SpecTclRestCommand            <co id='resttree.cmdpackage' />

if {[array names ::env DAQROOT] ne ""} {
    lappend auto_path [file join $::env(DAQROOT) TclLibs] <co id='resttree.daq.auto_path' />
}

package require portAllocator                  <co id='resttree.discovery' />
set mgr [portAllocator %AUTO% -hostname daqcompute99];
set port [$mgr findServer SpecTcl_REST fox];  # Could be different user!
$mgr destroy

if {$port eq ""} {
    error "There is no SpecTcl_REST service - perhaps SpecTcl isn't runnig"
}


SpecTclRestCommand::initialize daqcompute99  $port   <co id='resttree.initcmdpackage' />

maintainVariables 2                             <co id='resttree.vars' />
source $SpecTclHome/Script/SpecTclGui.tcl      <co id='resttree.treegui' />
wm withdraw .                                  <co id='resttree.withdrawroot' />

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='resttree.tk' >
            <para>
                The Tree user interface is a graphical user interface and hence,
                needs the <literal>Tk</literal> package.  This explicit
                <command>package require</command> allows this script to run
                either under <command>wish</command> or <command>tclsh</command>.
            </para>
        </callout>
        <callout arearefs='resttree.auto_path' >
            <para>
                These two lines define <varname>SpecTclHome</varname> to point
                to the top level installation directory for SpecTcl version
                <literal>5.10-000</literal>, the first version to support
                remote SpecTcl's REST command  simulator.
            </para>
            <para>
                <varname>SpecTclHome</varname> is normally defined by
                SpecTcl as it starts.  We must define it ourself if our scripts
                use it.  
            </para>
            <para>
                Finally, the <filename>TclLibs</filename> subdirectory, which
                contains the SpecTcl Tcl package library is added to the
                <varname>auto_path</varname> variable so that it will be searched
                to satisfy future <command>package require</command> commands.
            </para>
        </callout>
        <callout arearefs='resttree.cmdpackage' >
            <para>
                Searches for and imports the SpecTcl command simulator over
                REST.
            </para>
        </callout>
        <callout arearefs='resttree.daq.auto_path' >
            <para>
                We're going to do service discovery in the NSCLDAQ port manager,
                assuming that SpecTcl has advertised the service name
                <literal>SpecTcl_REST</literal> for its rest server.
                Doing this requires that we import a package from NSCLDAQ.
                This line adds the <filename>TclLibs</filename> subdirectory
                of the version of NSCLDAQ who's environment variables we have
                just set up
                to the package search path.
            </para>
            <para>
                That directory contains the NSCLDAQ Tcl package library.
            </para>
        </callout>
        <callout arearefs='resttree.discovery' >
            <para>
                This chunk of code first imports the NSCLDAQ
                <literal>portAllocator</literal> package which contains,
                among other things, service discovery support.
                It then creates a <literal>portAllocator</literal> to
                perform service discovery on the host <literal>daqcompute99</literal>
                where, presumably SpecTcl is running.
            </para>
            <para>
                The <literal>portAllocator</literal> object is then asked to
                resolve the service <literal>SpecTcl_REST</literal> advertised
                by the user <literal>fox</literal> into a numerical TCP/IP port
                number.
            </para>
            <para>
                If the result is an empty string, there is no matching service.
            </para>
        </callout>
        <callout arearefs='resttree.initcmdpackage' >
            <para>
                The SpecTcl command simulator must be told where the
                REST service it is operating over lives.  This is done with the
                <command>SpecTclRestCommand::initialize</command>.  That command has
                two parameters; the host in which SpecTcl is running and the
                port on which the REST server is listening for connections.
            </para>
        </callout>
        <callout arearefs='resttree.vars' >
            <para>
                SpecTcl documents serveral variables in which state is maintained.
                This command tells the command simulator to maintain those variables,
                updating them every 2 seconds.  This is one difference between
                the simulator and the native environment.  Updates to variables
                must be fetched from the server.   This command ensures that's done
                periodically.
            </para>
        </callout>
        <callout arearefs='resttree.treegui' >
            <para>
                Sources the tree parameter GUI, starting the remote Tree GUI.
                This does not build its interface in the root window, but
                starts a new top level in which it builds its interface.
            </para>
        </callout>
        <callout arearefs='resttree.withdrawroot' >
            <para>
                Withdraws the root window from the display.   Once the
                end of the script is reached, since the <literal>Tk</literal>
                package was impored, <command>tclsh</command> enters the event
                loop dispatching e.g. user interface events, until the application
                is ended.
            </para>
        </callout>
       </calloutlist>
       <section>
        <title>Differences between the Command Simulator and Native SpecTcl.</title>
        <para>
            In the sample framing script for the tree parameter GUI, we have already
            seen two differences between the command simulator and running native.
            There are a few other differences, as well as a command in both
            SpecTcl and the command simulator to determine which environment your
            scripts are running in.
        </para>
        <para>
            This section describes all of the differences between the command
            simulator and native SpecTcl.
        </para>
        <itemizedlist>
            <listitem>
               <para>
                  The command simulator must be initialized via
                  <command>SpecTclRestCommand::initialize</command>.
                  This command tells the simulator the
                  host on which the SpecTcl server is running and the port on which
                  the REST server is listening for connections.
               </para>
            </listitem>
            <listitem>
               <para>
                  Several SpecTcl variables are not available in the command
                  simulator unless it is asked to periodically fetch them from
                  the SpecTcl REST server. The
                  <command>maintainvariables</command> accepts the number
                  of seconds between updates and sets up periodic fetches of those
                  variables.
               </para>
            </listitem>
            <listitem>
               <para>
                  The command <command>isRemote</command>  will return true
                  (1) in the simulator and false (0) in native SpecTcl.
                  You can use this to have your user interfaces take action that
                  varies depending on whether or not it is running in the
                  simulator.  One application might be to write user interfaces
                  that know how to start themselves as REST clients or native
                  scripts.
               </para>
            </listitem>
            <listitem>
               <para>
                  Several objects in SpecTcl can have traces applied to their
                  state.  For example <command>spectrum -trace</command> can be used
                  to execute user scripts when the spectrum dictionary is modified.
                  The simulator supports these but at a higher latency than
                  native SpeTcl.  
               </para>
               <para>
                The server accumulates traces for clients that have expressed interest
                in them.  The client can then request the traces that have
                accumulated since the last time it asked.  In the simulator,
                the first time a trace is created, the simulator expresses interest
                in traces to the server.  It then sets up periodic polling of
                traces the server has accumulated.  Each trace is then
                dispatched as appopriate by the simulator.
               </para>
               <para>
                A simulator variable <varname>SpecTclRestCommand::tracePollInterval</varname>
                contains the integer number of seconds between trace polls.   It is read
                after each trace poll and, therefore, is to some extent dynamic.
                The default value is <literal>2</literal> (seconds).
               </para>
            </listitem>
            <listitem>
               <para>
                  The <command>execCommand</command>  executs an arbitrary
                  command in SpecTcl returning its result to the caller.  This
                   supports user defined SpecTcl command extensions.  It is
                   also another use case for the
                   <command>isRemote</command> command.
               </para>
            </listitem>
            <listitem>
               <para>
                  Since, for the most part, <command>rootexec</command>  is used
                  to produce graphical results, the <command>rootexec</command>
                  command is not supported by the simulator.
               </para>
            </listitem>
        </itemizedlist>
       </section>
    </chapter>
    <chapter>
       <title>Using the Mirror API to Access SpecTcl Shared Display Memory.</title>
       <para>
       </para>
    </chapter>
    <chapter>
       <title>Structure Of the SpecTcl Shared Display Memory</title>
       <para>
       </para>
    </chapter>
    <appendix>
        <title>New SpecTclInit.tcl features.</title>
        <variablelist>
            <varlistentry>
               <term><varname>HTTPDPort</varname></term>
               <listitem>
                   <para>
                    This variable can be set in SpecTcl 5.0 and later. If it is
                    defined in SpecTclInit.tcl, it must be an integer value.
                    SpecTcl will then start an HTTPD/REST server listening on the
                    port number that is the value of that variable.
                   </para>
                   <para>
                    Non privileged users of SpecTcl must select a value
                    larger than <literal>1023</literal>.  If the specified
                    port is already being used, SpecTcl will search for a nearby
                    port to use.  The port number actually selected will be
                    output in the SpecTcl startup messages.
                   </para>
                   <para>
                    As described later it is also possible, in the NSCLDAQ
                    environment, to get the NSCLDAQ port manager to allocate
                    a port number and advertise a service that can be translated
                    by client software.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><varname>MirrorPort</varname></term>
               <listitem>
                   <para>
                    This variable can be set in SpecTcl 5.10 and later.  If it
                    is defined in SpecTclInit.tcl, it must be an integer value
                    greater than <literal>1023</literal>.   If defined, the
                    value is used as the listener port for the display memory
                    mirror server.  
                   </para>
                   <para>
                    The display memory mirror server supports clients creating
                    memory regions that are mirrors of the SpecTcl display shared
                    memory.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Both of the new variables support describing a listen port for a server.
            The NSCLDAQ running system provides a mechanism for allocating such ports
            from a large pool of reserved ports.  Allocated ports are associated
            with a name and user that can be resolved by clients in systems
            that have NSCLDAQ installed (but not necessarily running).
        </para>
        <para>
            A simplified allocation interface is included in SpecTcl-5.10+ as long
            as the NSCLDAQ environment variables for NSCLDAQ-12.0+ are set up.
        </para>
        <para>
            The example below is a fragment from a <filename>SpecTclInit.tcl</filename>
            script that uses this capability to assign and advertise ports
            for the REST and Mirror servers:
        </para>
        <example>
            <title>Advertising REST and Mirror Ports With the NSCLDAQ PortManager</title>
            <programlisting>
lappend auto_path [file join $SpecTclHome TclLibs]
if {[array names env DAQTCLLIBS]  ne ""} {         <co id='portman.tcllibs' />
    lappend auto_path $env(DAQTCLLIBS)
}
package require DAQService                         <co id='portman.package' />
set HTTPDPort [SpecTcl::getServicePort SpecTcl_REST] <co id='portman.advertise' />
set MirrorPort [SpecTcl::getServicePort SpecTcl_MIRROR]

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='portman.tcllibs' >
                <para>
                    Starting with NSCLDAQ-12.0, the <filename>daqsetup.bash</filename>
                    script exports the environment variable <literal>DAQTCLLIBS</literal>.
                    This sectio of code tests for the existence of that variable and,
                    if defined, adds its value to the Tcl library package search
                    path.  If you are using a version earlier than NSCLDAQ-12.0,
                    you must either define <literal>TCLLIBPATH</literal> to point
                    to the <literal>$DAQROOT/TclLibs</literal>, or manually add
                    that directory to the <varname>auto_path</varname>.
                </para>
            </callout>
            <callout arearefs='portman.package' >
                <para>
                    The <literal>DAQService</literal> package provides a simplified
                    interface to the NSCLDAQ port manager.  It does, however
                    require the ability to load the NSCLDAQ packages that
                    interface with that port manager, hence the code to
                    extend the <varname>auto_path</varname> variable previously
                    described.
                </para>
            </callout>
            <callout arearefs='portman.advertise' >
                <para>
                    The <literal>SpecTcl::getServicePort</literal> proc
                    takes, as an argument, the name of a service you wish to
                    advertise.  It returns the port number allocated to that
                    service.  This is used to set the values of both
                    <varname>HTTPDPort</varname> and <varname>MirrorPort</varname>
                </para>
            </callout>
        </calloutlist>
    </appendix>
</book>