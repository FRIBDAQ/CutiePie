<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Sqlite3 interfaces</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>January 23, 2020</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This document describes a package distributed with SpecTcl that provides
            support for saving and restoring data from sqlite3 databases.
            For more information about Sqlite3 see
            <ulink url='http://sqlite.org' /> for information about that database and
            package.   If you want to extend the database access but don't know SQL,
            the query language used by Sqlite3, you can have a look at this
            SQL tutorial online.  <ulink url='www.w3schools.com/sql' />
        </para>
        <para>
            The remainder of this document describes
        </para>
        <itemizedlist>
            <listitem>
               <para>
                    What the SpecTcl Sqlite interface provides and how to
                    incorporate it into your SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    The low level, program neutral C++ API which allows database
                    object to be stored and recovered without the user
                    needing to know the database schema or the SQL query language
                    used to maintain and query the database contents.
                </para>
            </listitem>
            <listitem>
                <para>
                    The C++ classes SpecTcl uses to store event data into the
                    database and read it back out into SpecTcl.
                </para>
            </listitem>
            <listitem>
               <para>
                   A description of the Tcl bindings to the C++ API.
                   These bindings can be used in any environment,
                   not just SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    A description of a high level Tcl API that
                    is SpecTcl centric.  This includes command
                    and procs for saving and restoring objects
                    in the database as well as recording
                    and playing back decoded events.
                </para>
            </listitem>
            <listitem>
               <para>
                   SpecTcl database GUI. The GUI bolts on to SpecTcl providing
                   a user interface you can use to interact with SpecTcl databases.
               </para>
            </listitem>
            
            <listitem>
               <para>
                   Appendix A provides a detailed description of the SQL schema
                   (database organization) of the database files as well as
                   reference information about the APIs described in the
                   various chapters of this manual.
               </para>
            </listitem>
            
        </itemizedlist>
        <para>
            Why use Sqlite instead of some other database library?  Most, though not all, database
            libraries work in a client server environment.  In this environment, new databases
            must be created by requesting them from a database administrator.  Sqlite, however
            stores its database in an ordinary file.  This means no overhead is required to create
            dabases and you can hand out databases to your collaborators as simply as handing them
            the database file.
        </para>
        <para>
            All of this comes at one cost.  Sqlite, provides only a single writer and multiple
            reader model.  With a lot of fancy footwork in detecting and responding to database locked
            conditions, this can be overcome, however one writer and a single reader is not normally
            a hindrance in this application.
        </para>
    </chapter>
    <chapter>
       <title>What you can do with the SpecTcl Sqlite database package.</title>
       <para>
        Databases are useful when storing data that has some well defined format and
        capturing the relationships between those data.  SpecTcl data analysis
        configurations, spectra and even event data match that description.
        Below, let's look at glossary of terms that will be used throughout
        the rest of this manual.  The glossary will also give an idea
        of what the SpecTcl Sqlite data package can do in conjunction with SpecTcl.
       </para>
       <variablelist>
        <varlistentry>
           <term>Database</term>
           <listitem>
               <para>
                In this manual database means a relational database, specifically
                and sqlite3 database.  Sqlite3 databases live in a file. While
                there are mechanisms to join several files together int one
                database, these are not used by this package.
               </para>
               <para>
                Relational databases have a schema that describes a set of tables.
                Each table has several fields.  Fields in one table can link
                rows of that table to rows of a nother table.  These are the
                relations in relational databases.
               </para>
               <para>
                The SpecTcl database package provides schema definitions
                and code to manipulate an Sqlite3 database file to store
                several types of objects interesting to SpecTcl.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Save Set</term>
           <listitem>
               <para>
                A saved set is a named entity that stores objects.  Save sets
                are analgous to directories.  Each save set owns a set of objects
                that are stored and can be retrieved.  Save sets provide a
                mechanism for users to organize the data saved in the database
                and to tag related data with a user friendly name.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Configuration</term>
           <listitem>
               <para>
                One of the things that can be stored in a save set is a configuration.
                A configuration is the SpecTcl analysis configuration at some
                point in time.  This includes parameter and tree parameter
                definitions, Spectrum definitions, gate definitions, the application
                of gates to spectra and tree variables and their values.
               </para>
               <para>
                Configurations represent repeatable SpecTcl analysis conditions.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Spectra</term>
           <listitem>
               <para>
                SpecTcl's purpose in life is to produce histograms, which it
                calls spectra.  The contents of one or more spectra can be saved
                 in a save set.   This represents the products of an analysis
                 of a specific run.  It is normal, though not required, that
                 spectra be saved in the same saveset as the configuration
                 that produced them.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Event Data</term>
           <listitem>
               <para>
                When SpecTcl analyzes raw data, either from a data file or
                from an online data source, the first thing it does
                is pass each event through a user define event processing
                pipeline.  The purpose of that pipeline is to extract useful
                parameters from the raw data into raw parameters or tree parameters.
                SpecTcl then histograms these unpacked parameters.
               </para>
               <para>
                It is possible to save the parameters extraced from raw data
                for a run in a save set.  When this done, subsequent playback
                of the run from the save set is much faster than from the
                original raw data set.  This is because the entire user
                event processing pipline, which is normally where the majority
                of the time is spent, is completely bypasssed.  
               </para>
               <para>
                This capability provides a mechanism to quickly reply  runs over
                and over again, optimizing the analysis configuration in SpecTcl.
                It also provides an analysis neutral format from which, theoretically,
                any other analysis program can analyze the data.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
    </chapter>
    <chapter>
        <title>C++ Low level API</title>
        <para>
            This section provides an overview of the C++ classes that make up the
            database API.  Before we start, the API philosophy is that you
            will write once, never modify but restore several times.
            As such you'll see that there are no methods supporting
            either removing entities saved in the database or, with the exception
            of saved spectrum contents, modifying existing stored objects.
            This is a design choice and not an oversight.
        </para>
        <para>
            The API consists of several classes all living in the <literal>SpecTclDB</literal>
            namespace:
        </para>
        <variablelist>
            <varlistentry>
               <term><classname>CDatabase</classname></term>
               <listitem>
                   <para>
                    Represents database files.  Methods in this file allow you
                    to create a properly initialized database file, connect
                    to the file, create and get information about the save set
                    objects in the file.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>SaveSet</classname></term>
               <listitem>
                   <para>
                    This class represents save set objects.  Given a database
                    object, one can create savesets in that data base and
                    load them.  Given a save set object, one can create
                    and manipulate any of the objects in the save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBParameter</classname></term>
               <listitem>
                   <para>
                    These represent parameter definitions within a save set.
                    This class can create and lookup parameter definitions
                    give a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBSpectrum</classname></term>
               <listitem>
                   <para>
                    Represents spectrum objects within a save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBGate</classname></term>
               <listitem>
                   <para>
                    Represents a gate object in a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBApplication</classname></term>
               <listitem>
                   <para>
                    Represents the application of a gate to a spectrum.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>DBTreeVariable</term>
               <listitem>
                   <para>
                    Represents a tree variable saved in a save set.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Top level classes, <classname>CDatabase</classname> and
            <classname>SaveSet</classname> are written so that normally,
            you will not have to create or manually lookup the other
            individual objects.
        </para>
        <section>
            <title><classname>SpecTclDB::CDatabase</classname></title>
            <para>
                This section will introduce the <classname>CDatabase</classname>
                class through a set of simple examples.  These examples
                include code fragments that:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Create and attach a database. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Create and lookup a save set. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      List the savesets that are already known to a database.
                   </para>
                </listitem>
            </orderedlist>
             <para>
                These examples and a sample Makefile built along the lines
                described below are installed in the
                <filename>share/dbexamples</filename> directory of SpecTcl's installation
                directory tree.
             </para>
            <para>
                If you intend to do serious programming with this class library,
                you should study the reference material in the appendix.
            </para>
            <para>
                Before we can write any code, we need to be able to link
                compile and link our programs to this library. This requires
                a set of compilation and link flags.  In both cases below, in order
                to factor out the distribution directory for SpecTcl, we'll assume
                that the environment variable SPECTCLHOME is defined to be the
                top level directory of the SpecTcl installation  you are using.
                Note that environment variables are imported to Makefiles as
                Makefile variables (e.g. $(SPECTCLHOME) is the environment variable
                SPECTCLHOME).  SpecTcl depends on Root so we're also going to
                assume that ROOTSYS is defined and points to the directory
                from wich SpecTcl was linked with root.  As of version 5.3-007,
                the $SPECTCLHOME/VERSION file will tell you the value used for
                ROOTSYS.
            </para>
            <formalpara>
                <title>Compilation flags:</title>
                <para>
                    Compilation flags must ensure that the SpecTcl Headers
                    <variablelist>
                        <varlistentry>
                           <term><literal>-I$SPECTCLHOME/include</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's include file
                                directory searchable for <literal>#include</literal>
                                directives in your source code.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <formalpara>
                <title>Link flags</title>
                <para>
                    <variablelist>
                        <varlistentry>
                           <term><literal>-L$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's library directory
                                searchable for libraries on the link line.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Adds the SpecTcl library directory to the search
                                path used by the run time loader to locate shared
                                libraries needed by your program.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$ROOTSYS/lib</literal></term>
                           <listitem>
                               <para>
                                Adds root's library directory to the shared object
                                load search path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSpecTclDb</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl database API.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lTclGrammerApp</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl main library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSqlite3pp</literal></term>
                           <listitem>
                               <para>
                                Pulls in a C++ encapsulation of sqlite3.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lsqlite3</literal></term>
                           <listitem>
                               <para>
                                Pulls in the Sqlite3 API.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <para>
                A final note.  If root was not built with internal -rpath's
                turned on the sample program in this manual (and even
                SpecTcl itself) may fail with an error like
            </para>
            <para>
                <literal>
                    ./makedb: error while loading shared libraries: libvdt.so:
                cannot open shared object file: No such file or directory
            </literal>
                If that is the case then set up the full Root environment
                by $ROOTSYS/bin/thisroot.sh
            </para>
            <para>
                Let's look at the simplest example.  A complete program
                that creates an empty database. The program takes a
                databsae filename on the command line as a single argument.
            </para>
            <example>
                <title>Createing an empty database (makedb.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;               <co id='makedb.includes' />
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makedb db-filenme\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::CDatabase::create(argv[1]);          <co id='makedb.create' />

  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='makedb.includes' >
                    <para>
                        Including this header brings the class definition of
                        <classname>SpecTclDB::CDatabase</classname> into our
                        program.
                    </para>
                </callout>
                <callout arearefs='makedb.create' >
                    <para>
                        This line creates a new empty database. The
                        static method <methodname>create</methodname> in
                        <classname>SpecTclDB::CDatabase</classname> takes
                        a null terminated (C) string and creates a new database
                        in that file.
                    </para>
                    <para>
                        It is not harmful to call this on a database file that
                        has already been initialized with the SpecTcl database
                        schema as the SQL used is of the form
                        <literal>CREATE ... IF NOT EXISTS</literal>.
                    </para>
                    <para>
                        Using this method on an existing database file used for
                        another purpose will add the schema needed to
                        also use that file as a SpecTcl database; as long
                        as there are no collisions in table and index names.
                    </para>
                    <para>
                        Using this method on a file that is not an sqlite database
                        will result in an error message indicating the file is
                        not a database file.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at another simple full program.  This
                program will open an existing  database and create a saveset
                named <literal>a saveset</literal> in the database.
                The program will also demonstrate very simple error detection.
            </para>
            <example>
                <title>Creating savesets in a database (makesaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;                <co id='makesvset.savesetheader' />
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makesaveset database-name\n";
    exit(EXIT_FAILURE);
  }
  try {
    SpecTclDB::CDatabase db(argv[1]);     <co id='makesvset.opendb' />

    SpecTclDB::SaveSet* pSaveset = db.createSaveSet("a saveset"); <co id='makesvset.makeset' />
    delete pSaveset;
  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; <co id='makesvset.errors' />
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);

}

                </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='makesvset.savesetheader' >
                <para>
                    We'll be using a method from the
                    <classname>SpecTclDB::SaveSet</classname> class. This
                    <literal>#include</literal> pulls the definition of that
                    class and its methods into our program.
                </para>
               </callout>
               <callout arearefs='makesvset.opendb' >
                   <para>
                    In the previous example, we saw that the static
                    <methodname>create</methodname> method for the
                    <classname>SpecTclDB::CDatabase</classname> class
                    created and initialized a database file.  The
                    <classname>SpecTclDB::CDatabase</classname> class constructor
                    creates a database object that is connected to an already
                    created database file.
                </para>
               </callout>
               <callout arearefs='makesvset.makeset' >
                   <para>
                    This line asks the database object to create a new saveset.
                    On success, a pointer to the saveset object that encapsulates
                    the saveset in the database is created. Note that savesets
                    must have unique names.  Try running this program on
                    the same database twice.
                </para>
               </callout>
               <callout arearefs='makesvset.errors' >
                   <para>
                        The database API reports errors by throwing exceptions that
                        are derived from <classname>std::exception</classname>.
                        Errors, therefore are handled by this catch block. Any
                        meaningful message held by the exception object is
                        reported here.
                    </para>
                    <para>
                        If you do try the experiment of runing this program
                        on a saveset twice, this code will tell you the
                        saveset already exists.
                    </para>
               </callout>
            </calloutlist>
            <para>
                As an excersise, modify this program to accepts, as a second
                parameter, the name of the save set to create.  In the
                next, and last example in this section,
                we'll list the names of all of the savesets
                in a database.
            </para>
            <example>
                <title>Listing savesets (lssaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: lssaveset db-filename\n";
    exit(EXIT_FAILURE);
  }
  SpecTclDB::CDatabase db(argv[1]);
  auto savesets = db.getAllSaveSets();                 <co id='lssvset.getall' />
  std::cout &lt;&lt; " Save sets in " &lt;&lt; argv[1] &lt;&lt; std::endl; 
  for (int i =0; i &lt; savesets.size(); i++) {
    std::cout &lt;&lt; savesets[i]-&gt;getInfo().s_name &lt;&lt; std::endl; <co id='lssvset.name' />
    delete savesets[i];                                  <co id='lssaveset.del' />
  }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='lssvset.getall' >
                    <para>
                        The <methodname>getAllSaveSets</methodname> of
                        <classname>SpecTclDB::CDatabase</classname> returns
                        an indexable collection of pointers to the save set
                        objects that encapsulate all of the savesets in the
                        database.
                    </para>
                    <para>
                        A look at the header will tell you that <varname>savesets</varname>
                        is actually a
                        <classname>std::vector&lt;SpecTclDB::SaveSet*&gt;</classname>.
                        We could have used that type declaration.  There are
                        a couple of reasons we didn't. One sensible the other lazy.
                        By letting the compiler figure out the actual type
                        for <varname>savesets</varname>, the implementation of
                        <methodname>getAllSaveSets</methodname> could change and,
                        as long as the type returned suported
                        <methodname>size</methodname> and
                        <methodname>operator[]</methodname>, our code would
                        not need to change.  Second, this saved us a bunch of
                        typing in the code, at the cost of this paragraph
                        of explanation.
                    </para>
                </callout>
                <callout arearefs='lssvset.name' >
                    <para>
                        Saveset objects have a
                        <methodname>getInfo</methodname> method.  This method
                        returns a const reference to a struct that contains
                        information cached from the database about the saveset.
                        The <structfield>s_name</structfield> field of this
                        struct contains a printable name (actually a
                        <classname>std::string</classname>).
                    </para>
                </callout>
                <callout arearefs='lssaveset.del' >
                    <para>
                        Since <methodname>getAllSaveSets</methodname> dynamically
                        creates the save set objects it returns, these must be
                        <literal>delete</literal>-d as they are no longer needed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The SpecTclDB::SaveSet class.</title>
            <para>
                Save sets are where data are stored. Save sets are used to organize
                data into named containers.  Each container has a name,
                a creation timestamp and a unique integer identifier.   The
                identifier is used to link other objects back to the save set
                that owns them in the <literal>save_sets</literal> table of the
                database.  See the description of the database schema in the
                reference appendix for more information.
            </para>
            <para>
                In this section we'll show a few examples of the the
                <classname>SpecTclDB::SaveSet</classname> class in action.  We're
                only going to look at the object methods of the
                <classname>SpecTclDB::Saveset</classname> class.  There are
                some static methods, but they are intended for use by
                the <classname>SpecTclDB::CDatabase</classname> class not us.
            </para>
            <para>
                We're going to look at the Savesets through the lens of the following
                examples (installed in the <filename>share/dbexamples</filename>
                directory of the SpecTcl installation).
                These examples will:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                       Show how to define parameters and get
                       information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Show how to save spectrum definitions and
                      retrieve information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save the definition of
                      several broad categories of
                      gates, and retrieve information about
                      them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save information about which gates
                      are applied to conditionalize the
                      increments of which spectra.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to store information about
                      tree variables and retrieve it.
                   </para>
                </listitem>
                <listitem>
                    <para>
                        How to store and retrieve
                        decoded events,
                        and scaler readouts in a
                        saveset.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Defining parameters (pardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;      <co id='pardef.paramhdr' />

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if(argc != 2) {
    std::cerr &lt;&lt; "Usage:  pardef db-filename\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::SaveSet* pSave(nullptr);  <co id='pardef.psave' />
      
  try {
    SpecTclDB::CDatabase db(argv[1]);
    pSave = db.getSaveSet("a saveset"); <co id='pardef.getsvset' />
    delete pSave-&gt;createParameter("p1", 100); <co id='pardef.create' />
    delete pSave-&gt;createParameter("p2", 101, -10.0, 1.0, 100, "cm");

    auto params = pSave-&gt;listParameters(); <co id='pardef.listpars' />
    std::cout &lt;&lt; "The following parameters are defined:\n";
    for (int i =0; i &lt; params.size(); i++) {
      std::cout &lt;&lt; params[i]-&gt;getInfo().s_name &lt;&lt; std::endl;
      delete params[i];
    }
    SpecTclDB::DBParameter* p = pSave-&gt;findParameter("p2"); <co id='pardef.find' />
    std::cerr &lt;&lt; " I found parameter: " &lt;&lt; p-&gt;getInfo().s_name &lt;&lt; std::endl;
    delete p;

  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    delete pSave;
    exit(EXIT_FAILURE);
  }

  delete pSave;
  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pardef.paramhdr' >
                    <para>
                        Parameters are encapsulated in
                        <classname>SpecTclDB::DBParameter</classname>
                        objects.   This <literal>#include</literal>
                        bring the definition of that class into
                        the program.
                    </para>
                </callout>
                <callout arearefs='pardef.psave' >
                    <para>
                        This will be a pointer to the save set
                        we're manipulating. It's declared here
                        so that it will be in scope in the
                        <literal>catch</literal> block below.
                        That allows us to ensure that the
                        saveset gets freed if there's an
                        exception.
                    </para>
                </callout>
                <callout arearefs='pardef.getsvset' >
                    <para>
                        The <methodname>getSaveSet</methodname>
                        looks up a save set and caches its
                        database defintion into internal data
                        in a <classname>SpecTclDB::SaveSet</classname>.
                        A pointer to this dynamically allocated
                        object is then returned on success.
                        On failure an exception is thrown.
                    </para>
                </callout>
                <callout arearefs='pardef.create' >
                    <para>
                        This line and the next create two parameters.
                        SpecTcl has two raw parameters and
                        <classname>CTreeParameter</classname>
                        parameters.  The latter wrap raw parameters
                        and provide metadata that give hints about
                        how to best histogram the variable and
                        units of measure.
                    </para>
                    <para>
                        The first line stores a parameter
                        definition for a raw parameter. These
                        have a name and a slot number defining
                        how SpecTcl event processors should
                        supply data for this parameter.
                    </para>
                    <para>
                        The second line stores a parameter
                        with full metadata. In addition to the
                        name and number, metadata includes a
                        suggested low limite, a suggested high
                        limit, a suggested binning over that range,
                        and units of measure.  The second line
                        stores a parameter that runs in the range
                        of -10.0 to 10.0 with a suggested binning
                        of 100 bins.  The units of measure
                        are <literal>cm</literal>.
                    </para>
                    <para>
                        Noe that
                        <methodname>createParameter</methodname>
                        returns a pointer to the created parameter
                        object. This object is immediately
                        deleted.
                    </para>
                </callout>
                <callout arearefs='pardef.listpars' >
                    <para>
                        Produces a container with pointers to all
                        parameters.  The pointers are to
                        dynamically allocated objects which
                        must be deleted when no longer needed.
                    </para>
                    <para>
                        Subsequent code iterates over the
                        objects in the container, outputting
                        the names of each parameter and
                        deleting the objects.
                    </para>
                </callout>
                <callout arearefs='pardef.find' >
                    <para>
                        Retrieves a parameter definition by name.  This provides
                        us a container of pointers to <classname>DBParameter</classname>
                        objects.  We'll say more about <classname>DBParameter</classname>
                        later on.  For now you only need to know that this
                        class encapsulates cached information retrieved from
                        the database for a single parameter.
                    </para>
                    <para>
                        A readonly reference to this information can be gotten via
                        the <methodname>getInfo</methodname> method.  The pointers
                        in the container represent pointers to dynamically created
                        objects.  Therefore, once your code is done using one,
                        it should be deleted to avoid memory leaks.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at a toy program to create spectra in a save
                set and list information about the spectra a save set has.
                For this program:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Refer to the SpecTcl command reference or user's guide for
                      a list of the spectrum types and what they do.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you are going to test it, be sure you run it on a
                      database that has had the parameter test program run on it.
                      We will be using the saveset and
                      parameter definitions that we created
                      with that program.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                Note that in general, spectra need a name,
                a spectrum type, a vector of parameters and
                one or two axis definitions.  By default,
                spectra are defined with longword per channel
                storage, but this can be modified.
            </para>
            <example>
                <title>Defining Spectra (specdef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;
#include &lt;DBSpectrum.h&gt;     <co id='specdef.header' />

#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:  specdef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSvSet(nullptr);
    try {
        pSvSet = db.getSaveSet("a saveset");

        std::vector&lt;const char*&gt; s1Params = {"p1"};      <co id='specdef.pars' />
        std::vector&lt;const char*&gt; s2Params = {"p1", "p2"}; 
        SpecTclDB::SaveSet::SpectrumAxis x = {0, 1023, 1024};  <co id='specdef.axes' />
        SpecTclDB::SaveSet::SpectrumAxis y = {-10.0, 1.0, 100};

        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s1axes = {x};
        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s2axes = {x, y};

        delete pSvSet-&gt;createSpectrum("s1", "1", s1Params, s1axes); <co id='specdef.def' />
        delete pSvSet-&gt;createSpectrum("s2", "2", s2Params, s2axes);

        auto spectra = pSvSet-&gt;listSpectra();                 <co id='specdef.list' />
        std::cout &lt;&lt; "Names of spectra in saveset:\n";
        for (int i =0; i &lt; spectra.size(); i++) {
            auto&amp; info = spectra[i]-&gt;getInfo();
            std::cout &lt;&lt; info.s_base.s_name &lt;&lt; std::endl; <co id='specdef.info'/>
            delete spectra[i];
        }
    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        delete pSvSet;
        exit(EXIT_FAILURE);
    }

    delete pSvSet;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <para>
                We're not going to describe the elements of this example
                that are repeats of code fragments in prior examples.
            </para>
            <calloutlist>
                <callout arearefs='specdef.header' >
                    <para>
                        We will be calling methods of the
                        <classname>DBSpectrum</classname>
                        class, which encapsulates data from
                        a spectrum definition in the database.
                        We'll also be deleting dynamically allocated
                        <classname>DBSpectrum</classname> objects.
                        Both of these require knowledge of the shape of the
                        object given in the class definition.
                        The <filename>DBSpectrum.h</filename> header
                        is included to provide that information
                        to our program.
                    </para>
                </callout>
                <callout arearefs='specdef.pars' >
                    <para>
                        Spectrum are incremented on data from parameters
                        in events.  We defined two parameters in the
                        <filename>pardef.cpp</filename> example;
                        <literal>p1</literal> and <literal>p2</literal>.
                        We're going to be making a 1d and 2d spectrum.
                        These need one and two parameters respectively.
                        The spectrum generating method requires a
                        <classname>std::vector&lt;const char*&gt;</classname>
                        where each element is a pointer to a parameter
                        name that's already been defined. 
                    </para>
                    <para>
                        This line and the next line define the vectors
                        appropriate to the two spectra we'll be creating.
                    </para>
                </callout>
                <callout arearefs='specdef.axes' >
                    <para>
                        Spectra require one or two axes as well.
                        Axes are defined by low, and high limits and
                        binning.  This line and the next define a pair
                        of axes.  Note that the first one is arbitrary,
                        but the second one, uses the low/high binning
                        suggestions in the <literal>p2</literal>
                        parameter definition.  A real program
                        will query that parameter for its axis
                        recommendations.  That's beyond the scope of
                        this example however.
                    </para>
                    <para>
                        The two lines that follow the axis definitions
                        make a one element and two element vector of
                        axis specifications respectively.  Vectors of
                        axis specifications are what the spectrum
                        generating method expects.
                    </para>
                </callout>
                <callout arearefs='specdef.def' >
                    <para>
                        These two lines actually create the spectra.
                        As with parameters, a dynamically allocated
                        pointe to the spectrum object is returned, which
                        we immediately <literal>delete</literal>.
                        The parameters to <methodname>createSpectrum</methodname>
                        are respectively, the name of the spectrum,
                        the spectrum type (<literal>1</literal> is the
                        type of 1d spectra and <literal>2</literal>
                        is the type for 2d spectra).  The parameters needed
                        by the spectrum and the spectrum axes.
                    </para>
                    <para>
                        An optional additional parameter provides
                        a string specification of the data type used
                        for spectrum channels.  This defaults to
                        <literal>long</literal> if not supplied but
                        can also be <literal>word</literal> or
                        <literal>byte</literal>.
                    </para>
                </callout>
                <callout arearefs='specdef.list' >
                    <para>
                        Asks the saveset for a list of the spectra
                        that have been defined.  The return value is
                        an indexable container that holds pointers to
                        dynamically allocated <classname>DBSpectrum</classname>
                        objects.
                    </para>
                </callout>
                <callout arearefs='specdef.info' >
                    <para>
                        The spectrum information struct is complex enough
                        that it is divided into several pieces. The
                        piece selected by <structfield>s_base</structfield>
                        contains the base information about the spectrum,
                        including the type and spectrum name.
                    </para>
                    <para>
                        The loop outputs the name sof all spectra
                        defined in the saveset to standard output.
                    </para>
                </callout>
            </calloutlist>
                        <para>
                The gate definition API in <classname>SavSet</classname>
                is the most complex of the APIs. This is because SpecTcl supports
                a rich set of gate types.  There are are essentially
                three major classes of gate:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Gates that specify a region of interest in a subset
                      of the event's parameter space.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a logical operation
                      on other gates.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a bitwise operation and comparison
                      on a mask applied to a single parameter.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The point gates are, for convenience, further
                subdivided into
                <firstterm>1-d</firstterm> gates, which specify
                lower and upper bounds that define a slice of valuees,
                and <firstterm>2-d</firstterm> gates, which
                define a 2-d region of parameter space in pairs
                of parameters.
                Regardless of the gate type, all gates are
                encapsulated in a <classname>DBGate</classname>
                class which holds the database information
                describing the gate.
            </para>
            <para>
                The information cached for a gate is similarly
                more complex.  We'll look at that in detail
                in the reference man pages on the
                <classname>DBGate</classname> class.
            </para>
            <para>
                Let's look at a simple program that generates
                one of each type of these gates.  In past examples,
                we've made a token attempt at error handling by
                wrapping the body of the code in a try/catch
                block.  From now on we will not do any error
                handling, for the sake of brevity.
            </para>
            <para>
                This program assums a database that has had
                the <command>makesaveset</command> and
                <command>pardef</command>  example programs
                run on it.
            </para>
            <example>
                <title>Defining gates (gatedef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBGate.h&gt;         <co id='gatedef.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; 'Usage:: gatedef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet*  svset = db.getSaveSet("a saveset");

    std::vector&lt;const char*&gt; p1ds = {"p1"};  <co id='gatedef.1d' />

    delete svset-&gt;create1dGate("1d", "s", p1ds, 100, 200);

    std::vector&lt;const char*&gt; p2ds = {"p1", "p2"};  <co id='gatedef.2d' />
    std::vector&lt;std::pair&lt;double, double&gt;&gt; pts2d {
      {100, 0}, {200, 0}, {200, 200}, {100, 200}
    };
    delete svset-&gt;create2dGate("2d", "c", p2ds, pts2d);

    std::vector&lt;const char*&gt; gatenames={"1d", "2d"};   <co id='gatedef.compound' />
    delete svset-&gt;createCompoundGate("compound", "+", gatenames);

    delete svset-&gt;createMaskGate("mask", "em", "p1", 0x55555555); <co id='gatedef.mask' />

    auto gates = svset-&gt;listGates();   <co id='gatedef.list' />
    std::cout &lt;&lt; "Gates in the saveset:\n";
    for (int i = 0; i &lt; gates.size(); i++) {
        std::cout &lt;&lt; gates[i]-&gt;getInfo().s_info.s_name &lt;&lt; std::endl;
        delete gates[i];
    }

    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='gatedef.header' >
                    <para>
                        The <filename>DBGate.h</filename> header defines
                        the shape and method sof the
                        <classname>SpecTclDB::DBGate</classname> class.
                        We need these definitions because we are going
                        to all methods on class instances and
                        <literal>delete</literal> them.
                    </para>
                </callout>
                <callout arearefs='gatedef.1d' >
                    <para>
                        This section of code creates a 1-d gate.
                        1-d gates define a slice in parameter space.
                        Examples of 1-d gates are slices and gamma slices.
                        Since a gamma slice is defined on any number
                        of parameters, the method that creates 1-d
                        gates needs a vector of parameter names, rather
                        than a single parameter name.
                    </para>
                    <para>
                        Once the parameter name vector is created,
                        we can call
                        <methodname>create1dGate</methodname>
                        passing the name of the new gate, the
                        gate type code (slice in this case), the
                        vector of parameter names the gate needs and
                        the limits of the gate.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        The only difference between a 1d and
                        a 2d gate (e.g. band, contour, gamma contour) is that
                        the shape of the region of interest is defined
                        by a vector of x/y coordinate pairs.  These
                        coordinates are in parameter space (not spectrum space).
                    </para>
                    <para>
                        This section of code creates  a
                        contour gate that consists of a square
                        in the parameter space defined by
                        <literal>p1</literal>, <literal>p2</literal>.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        Compound gates define a logical combination
                        of existing gates; for example a gate that
                        is true if all component gates are true or a gate that is
                        true if any of the component gates is true.
                        The  not gate is also a compound gate that
                        depends on exactly one gate.  Similarly, True and False
                        gates are compound gates that depend on no
                        other gate.
                    </para>
                    <para>
                        This section of code creates a compound gate
                        that is true when either of the 1d or
                        2d gates we previously created is true.
                    </para>
                </callout>
                <callout arearefs='gatedef.mask' >
                    <para>
                        A mask gate performs specific bitwise operations
                        on parameters that are presumed to actually be
                        integers.  The result of those bitwise
                        operations determines the truth or falsity
                        of a gate.
                    </para>
                    <para>
                        This section of code creates an
                        <firstterm>equal mask gate</firstterm>.
                        The bitmask is bitwise anded with the
                        value of the parameter on each event and,
                        if the result is equal to that mask, the
                        gate is satisfied.
                    </para>
                </callout>
                <callout arearefs='gatedef.list' >
                    <para>
                        This section of code lists the gates
                        in the save set. The method
                        <methodname>listGates</methodname> returns a container
                        that has pointers to <classname>SpecTclDB::DBGate</classname>
                        that contain cached information about all gates defined
                        for the saveset in the database.
                        The <classname>SpecTclDB::DBGate</classname> objects
                        are dynamically created and, therefore,
                        must be deleted when you no longer need them.
                    </para>
                    <para>
                        As with all database objects, the
                        <methodname>getInfo</methodname> method
                        returns a const reference to a struct
                        that defines the information in the
                        database for the gate.  For gates, this
                        struct has quite a few sub-pieces. The
                        <structfield>m_info</structfield> sub
                        structure contains base information all
                        gates have.  The <structfield>s_name</structfield>
                        field in that struct is an
                        <classname>std::string</classname>
                        containing the gate's name.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Gates, by themselves are useless.  They only have meaning, and in
                SpecTcl are only evaluated, if they are applied
                to a spectrum or spectra. When a gate is applied
                to a spectrum, that spectrum can only be incremented
                for events that make that gate true.
            </para>
            <para>
                All SpecTcl spectra have exactly one gate applied
                to it at all times.  When initially created, a SpecTcl
                spectrum has a pre-defined True gate applied to it. By convention,
                there's no need to save either that true gate
                nor the application of true gates to spectra.
            </para>
            <para>
                Note that the database does not enforce the
                requirement that only one gate is applied at any
                time to any spectrum.  Restoring from a saveset
                that applies more than one gate to a spectrum
                will result in the application of one of those
                gates (unpredictably), to the spectrum.  The
                code used by SpecTcl to create savesets ensures this
                does not happen.
            </para>
            <para>
                The example below assumes that the databas it
                is run on has hasd
                <command>makesaveset</command>, <command>pardef</command>,
                <command>gatedef</command> and
                <command>specdef</command>previously
                run on it.
            </para>
            <example>
                <title>Applying gates to spectra (applydef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBApplications.h&gt;            <co id='applydef.header' />


#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: applydef database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;applyGate("1d", "s2");    <co id='applydef.apply' />
    delete svset-&gt;applyGate("compound", "s1");

    auto applications = svset-&gt;listApplications();
    std::cout &lt;&lt; "Gate applications\n";   <co id='applydef.list' />
    for (int i = 0; i &lt; applications.size(); i++) { 
        std::cout &lt;&lt; applications[i]-&gt;getGateName()
                  &lt;&lt; " is applied to "
                  &lt;&lt; applications[i]-&gt;getSpectrumName() &lt;&lt; std::endl;
        delete applications[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);

}                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='applydef.header' >
                    <para>
                        The <filename>Applictions.h</filename>
                        header defines the
                        <classname>SpecTclDB::DBApplication</classname>
                        class which encapsulates gate application
                        records in the database.
                        Including this file allows us to delete
                        instances of this class as well as call
                        methods on instances.
                    </para>
                </callout>
                <callout arearefs='applydef.apply' >
                    <para>
                        To save a gate application, we only need
                        provide the name of the gate and the
                        name of the spectrum it should be applied
                        to to the
                        <methodname>applyGate</methodname> method
                        of the saveset.
                    </para>
                </callout>
                <callout arearefs='applydef.list' >
                    <para>
                        This section of code lists the gate applications.
                        A good question is why we didn't just use
                        <methodname>getInfo</methodname> and list
                        out information cached there.  The answer
                        is that the information structure contains
                        information that's stored in the database for
                        the application.  In keeping with holding
                        the database in a normal form, the gate
                        and spectra are stored as foreign keys into
                        the gate and spectrum definitions tables.
                    </para>
                    <para>
                        <methodname>getGateName</methodname> and
                        <methodname>getSpectrumName</methodname>
                        use those values to look up the actual
                        gate and spectrum names.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Sometimes we want to write computations that can
                be steered at run-time.  For example, suppose we want to apply a
                linear energy calibration to a raw ADC parameter.  This
                calibration requires two values, a slope and offset.
                These values will not, in general, be known in advance
                but must be determined.
            </para>
            <para>
                Tree variables wrap Tcl variables in a way that makes them
                easy for the user to set and modify yet appear
                like ordinary double precision values to the C++
                code.  In addition tree variables have associated,
                with them units of measure to remind users how
                to properly set them (was that slope counts/KeV, counts/MeV?).
            </para>
            <para>
                Being able to save the analysis conditions so that
                they can be repeatably restored requires that
                tree variable definitions and values be saved
                in the database as well.
            </para>
            <para>
                The C++ API for tree variables is demonstrated
                in the example below.
            </para>
            <example>
                <title>Saving and recovering tree variables (vardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBTreeVariable.h&gt;  <co id='tv.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
    if (argc !=2) {
        std::cerr &lt;&lt; "Usage: vardb database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;createVariable("p1.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("p1.offset", 0.0, "KeV");   <co id='tv.create' />

    delete svset-&gt;createVariable("p2.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("ps.offset", 0.0, "KeV");

    auto vars = svset-&gt;listVariables();      <co id='tv.list' />
    std::cout &lt;&lt; " Tree variables: \n";
    for (int i = 0; i &lt; vars.size(); i++) {
        const auto&amp; info = vars[i]-&gt;getInfo();
        std::cout &lt;&lt; info.s_name &lt;&lt; " = " &lt;&lt; info.s_value
                  &lt;&lt; info.s_units &lt;&lt; std::endl;

        delete vars[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='tv.header' >
                    <para>
                        The <filename>DBTreeVariable.h</filename>
                        header defines the <classname>SpecTclDB::DBTreeVariable</classname>
                        class which is wraps a database definition
                        for a tree variable.
                    </para>
                </callout>
                <callout arearefs='tv.create' >
                    <para>
                        These lines create four tree variables.
                        These might be initial value for a linear
                        calibration.  Each call to
                        <methodname>createVariable</methodname>
                        needs a variable name, its current value
                        and units of measure.  It is customary
                        to use an empty string as the units
                        of measure for unit-less values.
                    </para>
                </callout>
                <callout arearefs='tv.list' >
                    <para>
                        This section of code lists the tree
                        variables that are defined in this save
                        set, their values and units of measure.
                        Note that since
                        <methodname>listVariables</methodname>
                        returns a container of pointers to dynamically
                        created objects, we <literal>delete</literal>
                        each pointer after we are done with it.
                    </para>
                </callout>
            </calloutlist>
            <para>
                One of the more powerful features of the SpecTcl
                database is its ability to store pre-decoded parameters
                and playing back runs from the databsae.
                This is analagous to loading Root Trees (which SpecTcl
                can also do).  
            </para>
            <para>
                This allows the user to rapidly try out different
                analysis conditions.   Rapidly because normally the
                user's data anlysis pipeline, the code that extracts parametes
                from raw data, is the most computationally expensive
                part of SpecTcl.  Reading events from the database allows
                the data analysis pipeline to be bypassed.
            </para>
            <para>
                The examples that show the API for storing and
                reading back event data are somewhat more complex.
                They will also need to rely on the existence of
                some source of data and some sink of data.
                These will be trivial sources, and not described
                in detail in the examples.
            </para>
            <example>
                <title>Storing event data (evtstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
                         <co id='evtstore.crevent' />
void createEvent(std::vector&lt;int&gt;&amp; params, std::vector&lt;double&gt;&amp; values)
{

    for (int i =0; i &lt; 100; i++) {
        if (drand48() &lt; 0.5) {
            params.push_back(i);
            values.push_back(drand48()*200.0 - 100.0);
        }
    }
}

int main(int argc, char** argv)
{
    if (argc != 3) {
        std::cerr &lt;&lt; "Usage:  evtstore db-filename nevents\n";
    }
    const char* dbFile = argv[1];
    int         nEvents = strtoul(argv[2], nullptr, 0);

    SpecTclDB::CDatabase db(dbFile);
    SpecTclDB::SaveSet* pSaveSet = db.getSaveSet("a saveset");

    int runId =                      <co id='evtstore.start' />
        pSaveSet-&gt;startRun(1, "Some junk Data", time(nullptr));

    std::vector&lt;int&gt; params;
    std::vector&lt;double&gt; values;
    srand48(time(nullptr));           <co id ='evtstore.init' />
    void* ctx = pSaveSet-&gt;startEvents(runId);  <co id='evtstore.trans' />
    for (int i =0; i &lt; nEvents; i++) {
        params.clear();
        values.clear();             // new event.
        createEvent(params, values);
        pSaveSet-&gt;saveEvent(                   <co id='evtstore.save' />
            runId, i, params.size(), params.data(), values.data()
        );

        if (i %100 == 0) {    // every 100 events commit the transaction.
            pSaveSet-&gt;endEvents(ctx);         <co id='evtstore.commit' />
            ctx  = pSaveSet-&gt;startEvents(runId);
        }

    }
    pSaveSet-&gt;endEvents(ctx);                <co id='evtstore.commit2' />

    pSaveSet-&gt;endRun(runId, time(nullptr));  <co id='evtstore.endrun' />
    delete pSaveSet;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtstore.crevent' >
                    <para>
                        This function creates an event. It
                        takes references to  a pair of vectors.
                        The integer vector is filled in with
                        numbers of parameters that are present
                        while the vector of doubles is filled in
                        whith parameter values for that parameter
                        in this event.
                    </para>
                    <para>
                        There are 100 parameters.  In any given
                        event, there's a 50% chance a parameter is present.
                        The parameter values are uniformly distributed
                        random numbers in the range [-100.0, 100.0)
                        because <function>drand48</function>
                        produces pseudo randoms in the range
                        [0, 1)
                    </para>
                </callout>
                <callout arearefs='evtstore.start' >
                    <para>
                        The <methodname>startRun</methodname>
                        indicates we are starting to store data for a run.
                        Normally this will be intermixed event
                        and scaler data.  For this example, we're
                        only storing events.  The run number must
                        be unique within the save set. The
                        return value is an integer that identifies
                        the run and must be used in most
                        of the methods we'll call in the future.
                    </para>
                    <para>
                        Only a run start time is provided.
                        The assumption is that we are reading data
                        from some serial data source and won't
                        know the end time for the run until
                        we reach data for the end of the run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Our event generator uses the pseudo random number generators.
                        This code ensures those generators are seeded with an
                        undeterministic value.  If you omit this
                        line, the program will still work but the
                        random number generators will be seeded
                        with a deterministic value and the
                        results of each run will be the same
                        from program run to program run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Individual database stores can be expensive.
                        Sqlite provides a mechanism for batching up
                        a bunch of stores into an atomic
                        <firstterm>transaction</firstterm>, these
                        transactions are called savesets.  
                    </para>
                    <para>
                        This line starts a transaction for storing
                        events and gets a <type>void*</type>
                        back which we call a context.
                        The context identifies the transaction
                        suc that it can be rolled back or committed
                        by the code at a later date.
                    </para>
                </callout>
                <callout arearefs='evtstore.save' >
                    <para>
                        This line saves an event. The
                        <methodname>data</methodname> method of
                        <classname>std::vector</classname> returns
                         a pointer to the contiguous storage used by the
                         event for he current transaction.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit' >
                    <para>
                        Every 100 events, we commit the
                        transaction we started with our call to
                        <methodname>startEvents</methodname>.
                    </para>
                    <para>
                        It is also possible to decide not to
                        store any events from a transaction
                        but doing that is beyond the scope of this
                        example.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit2' >
                    <para>
                        Performs the commit for any partial
                        block of events.
                    </para>
                </callout>
                <callout arearefs='evtstore.endrun' >
                    <para>
                        Closes off the run by providing the
                        end run time.
                    </para>
                </callout>
            </calloutlist>
            <para>
                The next program will read the event data
                we stored in the previous example and dump
                every 50 events to stdout. Note that the
                parameter numbers are intended to be the
                <parameter>number</parameter> parameter
                passed to the <methodname>createParameter</methodname>
                method in the database.  In SpecTcl these
                correspond to parameter ids, slots in the
                <classname>CEvent</classname> object passed
                between the members of the event processing
                pipeline.  
            </para>
            <para>
                In SpecTcl, using <classname>CTreeParameter</classname>
                and <classname>CTreeParameterArray</classname> objects
                hides but does not eliminate this parameter number.
                What this number is <emphasis>not</emphasis>
                is the value of the primary key of a parameter
                definition.
            </para>
            <example>
                <title>Recovering event data (evtget.cpp)</title>

                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


// accept data:
                    <co id='evtget.sink' />
void sink(const SpecTclDB::SaveSet::Event&amp; event)
{
    static int evt = 0;
    if ((evt % 50) == 0) {
      std::cout &lt;&lt; "Dumping event " &lt;&lt; evt &lt;&lt; ":\n";
        for (int i =0; i &lt; event.size(); i++)  {
            std::cout &lt;&lt; "   param# " &lt;&lt; event[i].s_number
                &lt;&lt; " = " &lt;&lt; event[i].s_value &lt;&lt; std::endl;
        }
    }
    evt++;
}


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: evtget db-filename\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSet = db.getSaveSet("a saveset");

    int runid = pSet-&gt;openRun(1);    <co id='evtget.open' />
    void* ctx = pSet-&gt;openEvents(runid); <co id='evtget.evts' />

    SpecTclDB::SaveSet::Event event;
    while(pSet-&gt;readEvent(ctx, event)) {  <co id='evtget.read' />
        sink(event);
    }

    pSet-&gt;closeEvents(ctx);     <co id='evtget.close' />
    delete pSet;

    exit(EXIT_SUCCESS);
}

                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtget.sink' >
                    <para>
                        This function is a stand in for whatever
                        processing you might do on events.
                        For our toy example, it just dumps the
                        data from every 50'th event.
                    </para>
                </callout>
                <callout arearefs='evtget.open' >
                    <para>
                        <methodname>openRun</methodname>
                        accepts a run number and returns the
                        id (primary key) identifying that run
                        in the database.  This can be used in other
                        calls to retrive information about
                        event data and scalers.
                    </para>
                </callout>
                <callout arearefs='evtget.evts' >
                    <para>
                        Getting events back from the database
                        requires iteration through the result set
                        from a query.  Doing this requires
                        that some context allowing the result set to be
                        identified must be held and saved.
                        <methodname>openEvents</methodname> performs
                        the query for the events that belong to the
                        run and returns a context that refers to the
                        result set.
                    </para>
                </callout>
                <callout arearefs='evtget.read' >
                    <para>
                        <methodname>readEvent</methodname>
                        takes the result set context gotten above
                        and fills in the <parameter>event</parameter>
                        parameter with the next event for that
                        run in the database.
                    </para>
                    <para>
                        As we've seen from the previous example
                        (<filename>evtstore.cpp</filename>),
                        parameters in an event can form a sparse set.
                        The data stored for an event only consists of the
                        parameters that have data for that event.
                        <methodname>readEvents</methodname> fills
                        in an indexable container (<classname>Event</classname>)
                        which contains the parameter numbers and
                        parameter values for parameters with data
                        for an event.
                    </para>
                    <para>
                        note that this can be trivially turned into
                        a <classname>CEvent</classname> object
                        by SpecTcl. With a bit of a table lookup
                        it can also be trivially marshalled into a root tree
                        leaf.
                    </para>
                </callout>
                <callout arearefs='evtget.close' >
                    <para>
                        <methodname>closeEvents</methodname>
                        releases all resources that were associated
                        with the result set gotten from
                        <methodname>openEvents</methodname>.
                    </para>
                </callout>
            </calloutlist>
            <para>
                In addition to storing decoded event data, the
                database schema supports storing and retrieving
                the results of scaler reads.  The next pair of
                examples exercise this capability.
            </para>
            <example>
                <title>Storing scaler readouts (sclstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;


std::vector&lt;uint32_t&gt; getScalers()  <co id='sclstore.produce' />
{
    static uint32_t       chan1 = 0;
    std::vector&lt;uint32_t&gt; result;
    for (int i = 0; i &lt; 32; i++) {
        result.push_back(chan1*i);
    }

    chan1++;
    return result;
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage: sclstore database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    time_t now =time(nullptr);
    int offset = 0;
    int runid = pS-&gt;startRun(2, "This is run 2", now);

    // simulate Read every 10 seconds 100 times:

    for (int i = 0; i &lt; 100; i++) {   <co id='sclstore.save' />
        now += 10;
        auto scalers = getScalers();
        pS-&gt;saveScalers(
            runid, 1, offset, offset+10, 1, now, 32, scalers.data()
        );
        offset += 10;
    }
    pS-&gt;endRun(runid, now);

    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <para>
                We've already seen show to record the start and
                end of run information, therefore, we won't
                repeat that discussion here.
            </para>
            <calloutlist>
                <callout arearefs='sclstore.produce' >
                    <para>
                        We need something to generate our scaler
                        data.  normally, these will come from ring items.
                        In SpecTcl event processors, the
                        <methodname>OnOther</methodname> method allows you to
                        catch and process scaler data.  SpecTcl's
                        code to write event data to the database h as an
                        implementation for this method that decodes
                        the scaler ring item and writes it to the
                        database.
                    </para>
                    <para>
                        In this case, since we are just writing a
                        sample program, we'll just generate 32
                        scaler values that change somewhat each time.
                    </para>
                </callout>
                <callout arearefs='sclstore.save' >
                    <para>
                        This loop simulates the scaler readouts
                        for a run that's 1000 seconds long with scaler
                        readouts every 10 seconds.
                        <methodname>saveScalers</methodname> takes
                        the run Id to associate the scalers with the
                        correct run.  It also takes two offset
                        values representing the start and end time into
                        the run over which the scalers counted.
                        The next parameters is a divisor. If you
                        divide the start and end times by the
                        divisor you should get the number of seconds
                        into the run for each of those values. This supports
                        offsets that have sub-second precision.
                        Following the divisor is a clock timestamp
                        indicating when this read took place.
                        The final pair of parameters is the
                        number of scalers and a pointer to them.
                    </para>
                </callout>
            </calloutlist>
            <example>
                <title>Recovering scaler readouts (sclget.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

                       <co id='sclget.process' />
void processScalers(const SpecTclDB::SaveSet::ScalerReadout&amp; readout)
{
    double start = readout.s_startOffset;
    start /= readout.s_divisor;
    double end   = readout.s_stopOffset;
    end   /= readout.s_divisor;
    std::cout &lt;&lt; "Scaler readout: Sid: " &lt;&lt; readout.s_sourceId
              &lt;&lt; " from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; " seconds into the run \n                  ";
    std::cout &lt;&lt; "Readout occured at: " &lt;&lt; ctime(&amp;readout.s_time) &lt;&lt; std::endl;

    for (int i =0; i &lt; readout.s_values.size(); i++) {
        std::cout &lt;&lt; "   channel " &lt;&lt; i &lt;&lt; " : " &lt;&lt; readout.s_values[i] &lt;&lt; std::                  endl;
    }
    std::cout &lt;&lt; "------------------------------\n";
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: sclget database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    int runid = pS-&gt;openRun(2);
    auto info = pS-&gt;getRunInfo(runid);   <co id='sclget.runinfo' />
    std::cout &lt;&lt; "Dumping scalers for run: " &lt;&lt; info.s_runNumber &lt;&lt; std::endl;
    std::cout &lt;&lt; "Title: " &lt;&lt; info.s_title &lt;&lt; std::endl;
    std::cout &lt;&lt; "Start time: " &lt;&lt; ctime(&amp;info.s_startTime) &lt;&lt; std::endl;
    std::cout &lt;&lt; "End time  : " &lt;&lt; ctime(&amp;info.s_stopTime) &lt;&lt; std::endl;

    void* ctx = pS-&gt;openScalers(runid);  <co id='sclget.open' />
    SpecTclDB::SaveSet::ScalerReadout scalers; <co id='sclget.read' />
    while(pS-&gt;readScaler(ctx, scalers)) { 
        processScalers(scalers);
    }

    pS-&gt;closeScalers(ctx);              <co id='sclget.close' />


    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='sclget.process' >
                    <para>
                        This function is a stand-in for any processing you
                        might want to do on a scaler readout.
                        In this case we just output information
                        about the scaler read and the channel
                        values to <literal>stdout</literal>.
                    </para>
                </callout>
                <callout arearefs='sclget.runinfo' >
                    <para>
                        The <methodname>getRunInfo</methodname>
                        method fetches top level information
                        about the run given its id
                        (gotten from <methodname>openRun</methodname>).
                        The run number, title, start and stop time
                        are elements of the
                        <type>SpecTclDB::SaveSet::RunInfo</type>
                        struct this method returns.
                    </para>
                </callout>
                <callout arearefs='sclget.open' >
                    <para>
                        As with getting events from the database,
                        scaler readout information is gotten by
                        iterating over the result set from a
                        query executed on the database.
                        <methodname>openScalers</methodname> executes
                        the query and returns a context that
                        can be used to iterate over the result set
                        from that query.
                    </para>
                </callout>
                <callout arearefs='sclget.read' >
                    <para>
                        The <methodname>readScaler</methodname>
                        gets the next result from the result set
                        indicated by the context parameter.
                        The information in that result are loaded
                        into the <type>SpecTclDB::SaveSet::ScalerReadout</type>
                        struct passed to it (by reference).
                    </para>
                    <para>
                        The return value of <methodname>readScaler</methodname>
                        is non zero if there was another result or
                        zero if there was no next result set
                        item.
                    </para>
                    <para>
                        All we do with the data gotten from
                        the database is call
                        <function>processScalers</function>.
                    </para>
                </callout>
                <callout arearefs='sclget.close' >
                    <para>
                        Once you are done iterating over the
                        result set, you must free the resources associated
                        with the context.   This is done by
                        calling <methodname>closeScalers</methodname>
                        passing the context.
                    </para>
                    <para>
                        It is not legal to use the context again, once
                        it has been closed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        
    </chapter>
    <chapter>
        <title>SpecTcl classes that record event data</title>
        <para>
            The database can hold event and scaler data associated
            with a run. These data are placed in a saveset. SpecTcl
            records at most one run per saveset and includes in that
            save set, the analysis conditions in effect at the time
            the run was analyzed.
        </para>
        <para>
            This also allows data from a run to be recorded more than
            once, using differing analysis configurations.
        </para>
        <para>
            This section describes the classes used by SpecTcl
            to record event data.  Note that in most cases, you don't
            need to use these classes.  They are instantiated
            by the SpecTcl database GUI and automatically
            placed in the analysis and data sink piplines as
            requested.
        </para>
        <para>
            These classes are organized into two layers.
            The lowest layer provides an interface between
            runs and the database API.  The upper layer provides
            an interface between SpecTcl's flow of control
            and the lower layer.
        </para>
        <para>
            The lower layer's header is <filename>CDBEvents.h</filename>.
            The upper layer's header is <filename>Events.h</filename>.
        </para>
        <section>
            <title>Lower layer of SpecTcl's event recording/playback code.</title>
            <para>
                The lower layer of SpecTcl's event recording
                and playback system consists of a pair of classes.
                <classname>CDBEventWriter</classname>, as the
                name implies, is used to record unpacked parameters and
                scalers to the database.
                <classname>CDBEventPlayer</classname>, as its name
                implies is used to read event data back from the
                database for a run in a save set.
                <classname>CDBEventPlayer</classname> only reads
                event data.  It does not read scaler data. The
                Tcl SpecTcl interface, however, has a mechanism
                to test for the existence of scaler data and recover
                it for a run in a saveset.
            </para>
            <para>
                <classname>CDBEventWriter</classname>
                the following methods of interest:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>beginRun</methodname>
                       <methodparam>
                           <type>const RingItem* </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method must be the first one called
                        to start recording a run. It provides
                        a ring item, which must be a
                        <literal>BEGIN_RUN</literal> item.
                        It records information about the run
                        and the start time of the run
                        using data in the ring item.
                       </para>
                       <para>
                        This method handles multiple begin runs
                        (as happens in event built data) by only
                        saving information from the first
                        call.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>endRun</methodname>
                       <methodparam>
                           <type>const RingItem*   </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method should be called when
                        end of run rinng items are available.
                        Note that the code is able to detect
                        multiple ends per run (as will be the
                        case in event built data) and, as with
                        the <methodname>beginRun</methodname>
                        call only saves information from the first one.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>scaler</methodname>
                       <methodparam>
                           <type>const RingItem*   </type><parameter>pScaler</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The <parameter>pScaler</parameter> parameter
                         must be a <literal>PERIODIC_SCALER</literal> ring item.
                         I is added to the scaler readouts for the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>event</methodname>
                       <methodparam>
                           <type>CEvent*      </type><parameter>pEvent</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds an event to the database. Note that
                        events are added in bunches for the sake of
                        efficiency.  The bunch size is set at
                        construction time and has a default value
                        that's believed to be reasonable.
                       </para>
                       <para>
                        The <parameter>pEvent</parameter> is a pointer
                        to the object that contains unpacked data from
                        SpecTcl.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>setAutoSaveSpectra</methodname>
                       <methodparam>
                           <type>const std::vector&lt;std::string&gt;&amp;</type>
                           <parameter>spectra</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The SpecTcl code that manages saving events to the database
                        provides the capability for automatically saving the contents
                        of a set of spectra at the end of the run.
                        THese spectra are referred to as
                        <firstterm>autosaved spectra</firstterm>.
                       </para>
                       <para>
                        This method sets the names of the spectra that will be
                        autosaved from <parameter>spectra</parameter>.
                        Any spectra previously deisgnated as autosaved
                        are no longer autosaved (unless they are in the
                        <parameter>spectra</parameter> parameter).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>addAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char*</type><parameter> name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds the spectrum named by <parameter>name</parameter>
                        to the list of autosaved spectra.  Existing autosaved
                        spectra are not removed from the list.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>removeAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char* </type><parameter>name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        If the spectrum named <parameter>name</parameter>
                        is in the auto saved list, it is removed from
                        that list.  All other spectra in that list
                        are not affected.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>std::vector&lt;RunInfo&gt; </type>
                       <methodname>listRuns</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns information about all runs saved in the
                        database. The run information includes the
                        name of the saveset it was recorded in.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>CDBEventPlayer*</type>
                       <methodname>playRun</methodname>
                       <methodparam>
                           <type>int</type><parameter>run</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Locates the first saveset that has the
                        requested <parameter>run</parameter> recorded in it
                        and creates a playback object for that
                        run.
                       </para>
                       <para>
                        See the description of <classname>CDBEventPlayer</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                To play back data the low level code supplies
                a <classname>CDBEventPlayer</classname>. This
                is constructed on a saveset and  the run number
                of a save set that's known to be stored in
                that saveset.
            </para>
            <para>
                The following methods are then available:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>const SpecTclDB::SaveSet::Event&amp; </type>
                       <methodname>next</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns a reference to the next event in the
                        run.  This will be an empty event if you attempt
                        to read past the last event. Note that
                        the writer class does not write empty events to the
                        database.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns the run's title string.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Upper layer of SpecTcl's event recording/playback code.</title>
            <para>
                The upper layer of SpecTcl event recording/playback code
                consists of a pair of objects that interface into
                SpecTcl's analysis system.  Specifically,
                <classname>CDBProcessor</classname> is used
                to write run starts stops and scalers to the
                database.  It is an <classname>CEventProcessor</classname>
                and will be added to the event processing pipeline
                <classname>CDBSink</classname>, on the other hand
                is a <classname>CEventSink</classname> and will be added
                to the event sink pipline.  By the time the event sink pipline
                is executed for an event, the event has been fully decoded and
                can be written to the database.
            </para>
        </section>
    </chapter>
    <chapter>
       <title>Tcl bindings to the C++ API</title>
       <para>
        The Tcl bindings to the C++ API closely mimic the C++
        API.  Tcl is a command based language. The C++ API is object
        oriented.  The standard way to do object oriented programming
        or present object oriented APIs is through
        <firstterm>command ensembles</firstterm>.
       </para>
       <para>
        A Tcl command ensemble is a command with subcommands.
        You can think of a command as a class or an object and
        the subcommand as methods (class or object level).
        You can imagine a Tcl command that represents a class.
        It might have construction subcommand that would dynamically
        generate a new command ensemble that represents an object.
        This is the approach taken by the Tcl bindings.
       </para>
       <para>
        The Tcl bindingsx are in a package called
        <literal>SpecTclDB</literal> which is stored in the
        SpecTcl Tcl package library.  There are two ways to bring that
        library directory tree into the Tcl package search path:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Via an environment variable.  For example, suppose
              the environment variable SPECTCLHOME is defined and is the
              top level directory in which the version of SpecTcl
              you are using is stored.
              <command>TCLLIBPATH=$SPECTCLHOME/TclLibs tclsh</command>
              will run a Tcl shell that includes the SpecTcl Tcl library tree
              in the search path.
           </para>
        </listitem>
        <listitem>
           <para>
              Extension of the the Tcl <varname>auto_path</varname>
              variable.  Suppose, as before SPECTCLHOME is defined
              to be the top level installation directory of your SpecTcl
              version, the following script fragment will bring the
              SpecTcl Tcl packages into your search path.
           </para>
           <informalexample>
            <programlisting>
lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
            </programlisting>
           </informalexample>
           <para>
            The global <varname>env</varname> array contains
            the values of environment variables indexed by variable
            name.  The <command>file join</command> command joins file
            system path elments and <command>lappend</command>
            appends items to a list, in this case the
            <varname>auto_path</varname> search list.
           </para>
        </listitem>
       </orderedlist>
       <para>
        Our examples will use the second form.  They will mirror
        closely the examples in the C++ API section.  The examples
        are deployed in the <filename>share/dbexamples</filename>
        directory.
       </para>
       <example>
        <title>Creating an empty database in Tcl (makedb.tcl)</title>
        <programlisting>
#!/bin/sh       <co id="makedb.tcl.boilerplate" />
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs] <co id='makedb.tcl.autopath' />
package require SpecTclDB                   <co id='makedb.tcl.require' />

if {[llength $argv] != 1} {                 <co id='makdeb.tcl.args' />
    puts stderr "Usage: makedb.tcl database-file"
    exit -1
}

DBTcl create [lindex $argv 0]           <co id='makedb.tcl.create' />

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='makedb.tcl.boilerplate' >
            <para>
                This bit of boilerplate is a recommended way to prefix
                executable Tcl scripts.  It starts the
                <command>/bin/sh</command> shell, which is almost always
                a legal shell and then some continuation line
                magic executes the Tcl interpreter passing the
                file back to itself as a parameter.  The
                <literal>\</literal> in the line before the
                <command>exec</command> command ensures that line
                is not seen by the Tcl intepreter as it continues the
                comment line.  The Tcl interpreter then continues
                to interpret the script in the remainder of the file.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.autopath' >
            <para>
                As described previously, this line appends the
                SpecTcl Tcl library directory tree to the
                <command>package require</command> search path.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.require' >
            <para>
                Brings the <literal>SpecTclDB</literal> package into the
                script. This defines the command ensemble that
                makes up the package.
            </para>
        </callout>
        <callout arearefs='makdeb.tcl.args' >
            <para>
                The <varname>argv</varname> list contains
                the command parameters that follow the command.
                Note that the command itself is not included. 
            </para>
        </callout>
        <callout arearefs='makedb.tcl.create' >
            <para>
                Creates the database file specified by the first
                command argument and initializes it to contain the
                SpecTcl database Schema.
            </para>
        </callout>
       </calloutlist>
       <para>
        The next example shows how to make a save set in an
        existing database file. We'll learn how to form a connection
        to a database and what that means. We'll then use that
        connection to create a new saveset.
       </para>
       <example>
        <title>Creating savesets in a database (makesaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {    <co id='mkset.catch' />
    set db [DBTcl connect [lindex $argv 0]]  <co id='mkset.connect' />
    set saveset [$db createSaveset "a saveset"] <co id='mkset.crset' />
    $saveset destroy                         <co id='mkset.destroy' />
    $db      destroy
} msg]

if {$status} {
    puts "Error: $msg"       <co id='mkset.errors' />
    exit -1
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='mkset.catch' >
            <para>
                This program demontsrates very simple error handling.
                The Tcl <command>catch</command> command
                performs the commands in the script passed as its
                first argument.  If there is an error, it returns
                1, if not, 0.  This value is captured in the
                <varname>status</varname> variable.
            </para>
            <para>
                The optional second argument to <command>catch</command>
                is the name of a variable.  If the command is successful,
                this will hold the result of the script.  If not,
                it will hold the error message associated with the
                failure.
            </para>
        </callout>
        <callout arearefs='mkset.connect' >
            <para>
                The <command>DBTcl connect</command> command
                creates a new command ensemble that can perform
                operations on the database file passed to the
                <command>DBTcl connect</command> command.
                This is analagous to constructing a new  object.
                The subcommands of the command captured in the
                <varname>db</varname> variable are analogous to
                object methods.
            </para>
            <para>
                This command ensemble is referred to as a
                <firstterm>data base instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.crset' >
            <para>
                Similarly the <command>createSaveset</command>
                subcommand of the databae instance command
                creates a new save set and returns another
                newly created command ensemble whose ensemble
                commands operate on the save set. As you might imagine,
                this command, captured in the <varname>saveset</varname>
                varible is called a <firstterm>saveset instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.destroy' >
            <para>
                All instance commands have a <command>destroy</command>
                ensemble command.  This destroys the command and
                releases any resources it might have.  This command
                is analogous to a destructor method
            </para>
        </callout>
        <callout arearefs='mkset.errors' >
            <para>
                This part of the script executes if any errors
                are detected by the <command>catch</command>
                command.  To see what it does, try running
                the script twice on the same database.  The secone
                time the attempt to make a saveset will fail
                because the save set already exists.
            </para>
        </callout>
       </calloutlist>
       <example>
        <title>Listing savesets in a database (lssaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]

    puts "Savesets in [lindex $argv 0]"

    foreach name [$db listSavesets] {  <co id='lssavesets.tcl.list' />
        puts $name
    }
    $db destroy
} msg]

if {$status} {
    puts "Error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='lssavesets.tcl.list' >
            <para>
                The <command>listSavesets</command> subcommand
                of the database instance command returns a
                properly formatte Tcl list of savesets contained
                by that database. This
                <command>foreach</command> loop outputs them
                to stdout.
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining parameters (pardef.tcl)</title>
            <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: pardef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]   <co id='pardef.tclgetsaveset' />
    
    $saveset createParameter p1 100            <co id='pardef.tclcreate' />
    $saveset createParameter p2 101 -10.0 10.0 100 "cm"
    
    puts "Parameters defined:"
    foreach param [$saveset listParameters] {  <co id='pardef.tcllist' />
        puts [dict get $param name]
    }
    
    $saveset destroy                            <co id='pardef.tcldestroy' />
    $db destroy
} msg]


if {$status} {
    puts stderr "error: $msg"
}                
            </programlisting>
       </example>
       <para>
        This example program creates two parameters named
        <literal>p1</literal> and <literal>p2</literal>.
        Parameter <literal>p2</literal> has full metadata.
        After creating the parameters the names of all parameters
        in the saveset are listed to stdout.
       </para>
       <calloutlist>
        <callout arearefs='pardef.tclgetsaveset' >
            <para>
                The <command>getSaveset</command> subcommand of
                a database instance command ensemble, looks up the
                named save set (in this case <literal>a saveset</literal>)
                and, if found creates a command ensemble that can
                manipulate that saveset.  If the saveset does not exist,
                an error is thrown.
            </para>
            <para>
                The command ensemble that
                <command>getSaveset</command> produces, is called a
                <firstterm>save set instance command</firstterm> and
                is captured in the <varname>saveset</varname>
                variable.
            </para>
        </callout>
        <callout arearefs='pardef.tclcreate' >
            <para>
                The <command>createParameter</command> subcommand
                of the saveset instance command ensemble creates
                new parameter definitions in the databsase.
                Mirroring SpecTcl, there are two types of parameters that
                can be created.  Raw parameters make a correspondence between
                parameter name and parameter number (in SpecTcl, parameter number
                is the index into a <classname>CEvent</classname>)
                object at which the parameter should be stored and retrieved.
                Tree parameters have additional metadata.
            </para>
            <para>
                The first command creates a raw parameter named
                <literal>p1</literal>.
                The second command creates  a tree parametr with
                metadata.  The metadata provides hints to both the
                user and SpecTcl GUI scripts about how to define axes
                of spectra that depend on this parameter.
                In this case a range of [-10.0..10.0) with 100 bins
                is recommended.  In addition, the units of measure
                of the parameter are documented as centimeters
                (<literal>cm</literal>).
            </para>
        </callout>
        <callout arearefs='pardef.tcllist' >
            <para>
                The <command>listSpectrum</command> subcommand
                of a save set instance command ensemble creates
                a Tcl list of dicts that describe the spectra
                that have been defined in the saveset.  The keys of the
                dict are:
                <variablelist>
                    <varlistentry>
                       <term><literal>id</literal></term>
                       <listitem>
                           <para>
                            Contains an integer that is the primary key of the
                            spectrum in the spectrum definition table.
                            This is useful in programs that may do ad-hoc
                            queries of the database for advanced
                            applications.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                            Text string that is the name of the parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>number</literal></term>
                       <listitem>
                           <para>
                            THe number of the parameter.  This differs from the
                            <literal>id</literal> key. It's a value that
                            the program supplies, rather than a value
                            assigned by the database engine.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>low</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree
                            parameters. It's the recommended low limit of spectrum
                            axes defined on this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>high</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.
                            It is the recommended high limit for axes defined
                            on this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>bins</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.  It is
                            the recommended number of bins on axes defined on
                            this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>units</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.  It is
                            the units of measure defined for the parameter.
                            Note that an empty string is perectly allowed an usually
                            means the parameter is unit-less (e.g. raw ADC
                            values).
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </callout>
        <callout arearefs='pardef.tcldestroy' >
            <para>
                Because the saveset instance command is dynamically
                created by the database instance command, when you are done
                with it you should destroy it and the resources associated with it.
                The <command>destroy</command> subcommand does this
                just as it also destroys database instance commands and
                their associated resources.
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining Spectra (specdef.tcl)</title>
            <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: specdef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset createSpectrum s1 1 p1 [list [list 0 1023 1024]]  <co id='specdef.tcl.cr1d' />
    $saveset createSpectrum s2 2  \                            <co id='specdef.tcl.cr2d' />
        [list p1 p2] [list [list 0 1023 1024] [list -10.0 10.0 100]]
    
    puts "Spectra in saveset:"
    foreac spectrum [$saveset listSpectra] {   <co id='specdef.tcl.list' />
        puts [dict get $spectrum name]
    }
} msg]

$saveset destroy
$db destroy

if {$status} {
    puts stderr "error: $msg"
}                
            </programlisting>
       </example>
       <para>
        This example creates a 1d and a 2d spectrum named
        <literal>s1</literal> and <literal>s2</literal>
        respectively.
       </para>
       <calloutlist>
        <callout arearefs='specdef.tcl.cr1d' >
            <para>
                The <command>createSpectrum</command> saveset instance
                subcommand creates spectrum definitions in the database.
                This command takes several parameters;
                A spectrum name, the a type code for the spectrum type,
                a list of parameters needed by the spectrum,
                a list of axis definitions and an optional
                channel data type.
            </para>
            <para>
                In the sample command, the spectrum name is
                <literal>s1</literal>. The spectrum type code,
                <literal>1</literal> means that the spectrum is
                a 1-d spectrum.  <literal>p1</literal> is a single
                element Tcl list that says the spectrum increments
                the <literal>p1</literal> value for each event in which
                it is defined.  Note that had the spectrum type been
                <literal>s</literal> (summary spectrum), or
                <literal>g1</literal> (gamma 1-d) this parameter
                list would, in general contain additional parameter
                names.  After the parameter is a list of axis definitions.
                Each axis definition, in turn is a three element list containing
                the axis low limit, high limit and number of bins
                in that order.  Thus <literal>p1</literal> will have an
                axis that runs from 0 to 1023 and has 1024 channels.
            </para>
            <para>
                By default, SpecTcl spectra contain longword (32 bit)
                channel values.  The <command>createSpectrum</command>
                subcommand also uses this as the default channel datatype.
                You can explicitly provide a data type as an additional command
                parameter.  This additional parameter can have one
                of the following values:
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>byte</literal></term>
                   <listitem>
                       <para>
                        Channels will be 8 bit values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>word</literal></term>
                   <listitem>
                       <para>
                        Channels will be 16 bit values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>long</literal></term>
                   <listitem>
                       <para>
                         Channels will be 32 bit values
                    </para>
                 </listitem>
                </varlistentry>
            </variablelist>
        </callout>
        <callout arearefs='specdef.tcl.cr2d' >
            <para>
                This command creates a 2-d spectrum.  The principles are the
                same as the previous command, but two parameters
                (x and y axis in that order) are provided as are two
                axes (x and y axis in that order).
            </para>
        </callout>
        <callout arearefs='specdef.tcl.list' >
            <para>
                The <command>listSpectra</command> subcommand
                returns a Tcl list whose entries describe the spectra defined in the
                saveset.  Each list item is dict that describes
                a single spectrum.  The dicts have the following
                key/value pairs:
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        The primary key of the spectrum in the top level
                        spectrum definition table.  This is really not
                        useful to Tcl scripts that only use the API.
                        It can be useful to scripts that also do ad-hoc
                        queries of the database (e.g. via the sqlite3
                        package).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal></term>
                   <listitem>
                       <para>
                        Name of the spectrum.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>type</literal></term>
                   <listitem>
                       <para>
                        The spectrum type code.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>parameters</literal></term>
                   <listitem>
                       <para>
                        The list of parameters the spectrum depends on.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>axes</literal></term>
                   <listitem>
                       <para>
                        List of axis definitions for each of the
                        free defined axes of the spectrum. Note that
                        each axis definition is a three element list containing
                        in order, the axis low limit, high limit and
                        number of bins.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>datatype</literal></term>
                   <listitem>
                       <para>
                        The data type code as described above.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <para>
        As with the C++ API, there are a family of subcommands that
        create gates of different types.  The sample script below
        creates several types of gates.
       </para>
       <example>
        <title>Defining gates (gatedef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: gatedef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset create1dGate slice  s p1 100 200    <co id='gatedef.tcl.1d' />
    $saveset create2dGate contour c [list p1 p2] \ <co id='gatedef.tcl.2d' />
        [list {100 10} {200 100} {200 200} {100 200} ]
    $saveset createCompoundGate and * [list slice contour] <co id='gatedef.tcl.compound' />
    $saveset createMaskGate  mask em p1 0x55555555 <co id='gatedef.tcl.mask' />
    
    puts "Gates in saveset:"
    foreach gate [$saveset listGates] {    <co id='gatedef.tcl.list' />
        puts [dict get $gate name]
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='gatedef.tcl.1d' >
            <para>
                Creates a 1d gate.  1d Gates are gates that have a single
                low and high limit defining a slice in some 1-d space.
                The <command>create1dGate</command> subcommand takes 5
                additional parameters.  The name (<literal>slice</literal>),
                the gate type (<literal>s</literal>) the list of
                parameters the gate is checked against (<literal>p1</literal>),
                note that there are 1d gates that can have more than one
                parameter; gamma slices <literal>gs</literal> for example.
                The final two parameters are the low and high limits of the
                gate.
            </para>
            <para>
                Note that the gate limits for this and all gates with
                limits are in raw parameter coordinates.  There is often
                a temptation to believe that since gates are clicked on
                on spectra they are accepted in spectrum coordinates.
                This is not the case.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.2d' >
            <para>
                Creates a 2-d gate.  With the exception of the gate limits,
                this subcommand takes the same parameters as
                <command>create1dGate</command>.  However, instead of two limit parameters,
                the command takes on parameter that is a list of
                X/Y  pairs that define a figure in some 2-d space of
                parameters.  In the example, the gate is a contour,
                which is a closed figure.  The coordinates are that of a square.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.compound' >
            <para>
                Creates a compound gate.  A compound gate is one whose
                truth or falsity only depends on the truth or falsity of other
                gates.  The form of the <command>createCompoundGate</command>
                subcommand calls for a gate name, a gate type and a list
                of the gates the compound depends on.  
            </para>
            <para>
                In this example a new gate <literal>and</literal>
                is created that is an and gate (type <literal>*</literal>)
                that depends on the gates <literal>slice</literal>
                and <literal>contour</literal>.  This gate will only be true
                of both gates are true in an event.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.mask' >
            <para>
                Creates a mask gate.  Mask gates assume their parameter
                is actually an integer and perfrom some bitwise
                operation and comparison on it.  The
                <command>createMaskGate</command> subcommand
                requires a gate name (<literal>mask</literal>),
                a gate type (<literal>em</literal> mask and compare for equality),
                and a bitmask (<literal>0x55555555</literal>).
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.list' >
            <para>
                The <command>listGates</command> command returns
                a list of dicts that describe the gates saved in the saveset.
                Each gate is described by a dict.  Interpreting this
                dict requires knowing the type of gate as the
                set of keys provided dpends on the type of gate.
                The dict introduces the concept of a
                <firstterm>gate classification</firstterm> which
                defines the set of keys a gate will have.
            </para>
            <para>
                Here's list of the gates an when they are present.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>classification</literal> (all)</term>
                   <listitem>
                       <para>
                        Gives the gate classification. All gates
                        will be one of <literal>point</literal>,
                        <literal>compound</literal>, or
                        <literal>mask</literal> gates.
                        In the keys below, after the key term parenthesized
                        text will describe which keys are present in which
                        clasifications.  Note that
                        (all) as in above means that all classification
                        types have this key.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>id</literal> (all)</term>
                   <listitem>
                       <para>
                        The primary key in the top level table
                        used to define gates.  This is normally
                        not useful to programs that use only this
                        Tcl API. It can be useful if a script also
                        uses e.g. sqlite3 to perform arbitrary
                        queries of the database.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal> (all)</term>
                   <listitem>
                       <para>
                        The name of the gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>type</literal> (all)</term>
                   <listitem>
                       <para>
                        The gate type code string.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>parameters</literal> (point, mask)</term>
                   <listitem>
                       <para>
                        The parameters that are checked by the gate.
                        Note that mask gates only have one parameter.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>gates</literal> (compound)</term>
                   <listitem>
                       <para>
                        The names of the gates this gate depends on
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>points</literal> (point)</term>
                   <listitem>
                       <para>
                        A list of two element sub lists.  Each element
                        is a point in the gate.  For 1d gates, the
                        Y coordinate is meaningless and there will only be
                        two points. For 2-d gates, the X and Y coordinate are both
                        meaningful and there can be be an arbitrary number
                        of points.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>mask</literal> (mask)</term>
                   <listitem>
                       <para>
                        The bitmask for a mask gate.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Applying gates to spectra (applydef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: applydef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset applyGate slice s2  <co id='applydef.tcl.apply' />
    
    foreach app [$saveset listApplications] { <co id='applydef.tcl.list' />
        set gate [dict get $app gate]
        set spec [dict get $app spectrum]
        puts "$gate is applied to $spec"
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}            
        </programlisting>
       </example>
       <para>
        Gates are objects that are totally passive unless
        <firstterm>applied</firstterm> to a spectrum.  When applied to a spectrum,
        a gate conditionalizes the normal incrementation of that spectrum.
        If a gate is applied to a spectrum, the spectrum will only be
        incremented if the gate is true.
       </para>
       <calloutlist>
        <callout arearefs='applydef.tcl.apply' >
            <para>
                The <command>applyGate</command> subcommand
                takes a gate name and a spectrum name in that order.
                The gate is entered in the database as being applied to the
                spectrum.
            </para>
        </callout>
        <callout arearefs='applydef.tcl.list' >
            <para>
                The <command>listApplications</command> subcommand returns a list
                whose elements are dicts. Each dict describes a
                gate application and has the following keys.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        Contains the primary key of the application in the
                        gate applications table.  This is only useful for
                        ad-hoc queries of the database performed by
                        by e.g. the sqlite3 package.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>gate</literal></term>
                   <listitem>
                       <para>
                        The name of the gate
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>spectrum</literal></term>
                   <listitem>
                       <para>
                        The spectrum to which that gate is being applied
                        in this entry.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Saving and recovering tree variables (vardef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: vardef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]

    $saveset createVariable slope 1.23 KeV/lsb <co id='vardef.tcl.make' />
    $saveset createVariable offset 10  KeV
    $saveset createVariable gainmatch 1.23    <co id='vardef.tcl.unitless' />
    
    puts "Tree variables: "
    foreach var [$saveset listVariables] {    <co id='vardef.tcl.list' />
        set name [dict get $var name]
        set val  [dict get $var value]
        set units [dict get $var units]
        
        puts "$name : $val$units"
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}            
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='vardef.tcl.make' >
            <para>
                The <command>createVariable</command> subcommand creates a new
                tree variable definition.  The command requires
                a name, a value and optionally units of measure.
            </para>
            <para>
                This and the next line of code create a pair of variables that might
                be used to do an energy calibration of a parameter.  The units
                of measure clearly show what the units of the calibrated parameter
                will be; KeV.
            </para>
        </callout>
        <callout arearefs='vardef.tcl.unitless' >
            <para>
                If the variable has no units of measure, you can leave the units
                parameter out.  In that case the actual value of the
                units of measure for the variable will look like an
                empty string.
            </para>
        </callout>
        <callout arearefs='vardef.tcl.list' >
            <para>
                The <command>listVariables</command> subcommand
                returns a list of dicts that describe the tree variables saved in
                this saveset.  Each list element is a dict that
                contains the following key/value pairs.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        Primary key of the variable in the tree variable
                        table.  This is useless for Tcl scripts that only
                        use the published API.  It can be useful if a script does
                        ad-hoc database queries (e.g. using the sqlite3 package).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal></term>
                   <listitem>
                       <para>
                        Name of the treevariable.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>value</literal></term>
                   <listitem>
                       <para>
                        Value of the tree variable (double).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>units</literal></term>
                   <listitem>
                       <para>
                        Units of measure text string.  If no units were supplied,
                        this will be an empty string.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Storing spectrum contents (specstore.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: specstore.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]

    $saveset storeChannels s1 \    <co id='specstore.tcl.store' />
        [list {100 123} {101 2000} {102 400} {103 60}]
    
    set channels [$saveset getChannels s1] <co id='specstore.tcl.get' />
    puts "Channels in s1: "
    foreach chan $channels {
        set x [lindex $chan 0]
        set v [lindex $chan 2]             <co id='specstore.tcl.list' />
        puts "Channel $x:   $v"
    }
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='specstore.tcl.store' >
            <para>
                The <command>storeChannels</command> command stores
                channel values in a spectrum whose definition is already stored in
                the saveset.  Two additional parameters are expected;
                the name of the spectrum and the values.  Values are a list
                containing either two or three element sublists.  For
                1-d spectra, two elements are expected and they are the
                channel coordinate and channel value.  For 2d spectra,
                the three elements are x channel, y channel and value.
            </para>
        </callout>
        <callout arearefs='specstore.tcl.get' >
            <para>
                The <command>getChannels</command> subcommand returns a list of
                channel values stored for the spectrum. Each channel is given
                as a three element list.  The first element is an x channel number.
                The second element, is the y channel number if the spectrum is 2
                dimensional or 0 if not. The third element is the
                channel value.
            </para>
        </callout>
        <callout arearefs='specstore.tcl.list' >
            <para>
                Since we stored a 1-d spectrum we need to pull out
                the first and last elements of each channel list
                and output them.
            </para>
        </callout>
       </calloutlist>
       <para>
        The Tcl interface supports some queries of the event
        data stored in a save set but does not support storing events
        or scaler readouts.  See the reference section for more
        information about this.
       </para>
    </chapter>
    <chapter>
       <title>SpecTcl API to the database.</title>
       <para>
        The SpecTcl API to the database knows about the SpecTcl commands that
        can list objects get their properties and uses them to simplify
        interactions with the database.  It is a pure Tcl package
        that is written to live on top of the <literal>SpecTclDB</literal>
        package that serves as a Tcl binding to the database C++ API.
       </para>
       <para>
        The package, named <literal>dbconfig</literal> is available in the TclLibs directory tree of
        the SpecTcl installation.  Therefore, adding that directory
        to the package search path, as described in the previous chapter is
        sufficient to be able to do a
        <literal>package require dbconfig</literal> to bring the package
        code into the script.
       </para>
       <para>
        For the most part, the <literal>dbconfig</literal> package
        is intended to be used as a basis for implementing  SpecTcl GUI's
        that manipulate the database.  Note that one has already been written,
        give it a try first to see if it's sufficient.  Naturally if you have
        suggestions for improvement, send them off to us and we'll consider
        them for future releases.
       </para>
       <para>
        The reference material in the appendix will describe each
        proc of the package fully.  Here we'll just take a quick tour
        of the package. Note that all procs in the package are in the
        <literal>dbconfig</literal> database.
       </para>
    <para>
        Two procs, <literal>dbconfig::makeSchema</literal> and
        <literal>dbconifg::connect</literal> support the
        creation of and connection to databases.  Here's a script
        fragment that shows how to create and connect to a new
        database:
    </para>
    <example>
        <title>dbconfig - creating and connecting to a database</title>
        <programlisting>
proc newdb {fname} {
dbconfig::makeSchema $fname
return [dbconfig::connect $fname]
}
        </programlisting>
    </example>
    <para>
        The return value from <function>newdb</function> is a handle
        that must be used for other call to database related operations.
        In fact this is a database instance command from the
        Tcl bindings to the C++ API. When you are done using it you should
        distroy by invoking it's <command>destroy</command>
        subcommand.
    </para>
    <para>
        The <literal>dbconfig</literal> package things in terms of
        configurations. A configuration is the set of parameters,
        spectra, gates, gate applications and tree variables
        currently defined in SpecTcl.  It provides several
        procs that deal with configurations:
    </para>
    <variablelist>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::openSaveSet {dbcmd name}</code></term>
           <listitem>
               <para>
                This proc opens an existing save set and returns its
                save set instance command.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::saveConfig {db name {spectra 0}}</code>
           </term>
           <listitem>
               <para>
                Saves the analysis configuration into the database
                whoese handle is <parameter>db</parameter>. The saveset used
                will be <parameter>name</parameter> and must
                not yet exist.  If <parameter>spectra</parameter>
                is provided and is non-zero, spectrum contents for all spectra
                will get saved into the database.
               </para>
               <para>
                The proc returns a handle to the saveset
                (actually the saveset instance command). This
                value must be passed to save set related operations.
                When you are done with that handle, invoke it's
                <command>destroy</command> subcommand to destroy the
                command and relase resources associated with it.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig:listConfigs cmd</code>
           </term>
           <listitem>
               <para>
                Returns a Tcl list describing all of the savesets in the
                database.  THe list contains dicts that have
                the keys <literal>id</literal> primary key
                of the saveset, <literal>name</literal> saveset name,
                <literal>timestamp</literal> the time the saveset
                was created.  This can be turned into a readable value
                via <command>clock format</command>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::restoreConfig {cmd savename {restoreSpectra 0}}</code>
           </term>
           <listitem>
               <para>
                Restores the parameter, spectrum, gate, gate applications and
                tree variable s associated with a saveset.
                <parameter>cmd</parameter> is the database instance command
                gotten from <command>dbconfig::connect</command>.
                The <parameter>savename</parameter> parameter is the name of an
                existing save set in to which the processing parameters of SpecTcl
                are stored.   Finally, <parameter>retstoreSpectra</parameter>,
                if supplied and nonzero restores any saved specrum contents.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl" >proc dbconfig::saveSpectrum {sname specname}</code>
           </term>
           <listitem>
               <para>
                Saves a single spectrum to the save set designated by the saveset
                handle (instance command) <parameter>sname</parameter>
                The spectrum <parameter>specname</parameter> is saved.
                The save set must already exist and the spectrum definition
                must be saved in that save set.  
               </para>
               <para>
                Normally this is used when a configuration has been
                saved and only <emphasis>then</emphasis> are data analyzed.
                After data analysis is complete an appropriate set of spectra
                can then be saved into the same saveset to document the
                results of the analysis.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::restoreSpectrum {sname specname}</code>
           </term>
           <listitem>
               <para>
                Restores a single spectrum; <parameter>specname</parameter>
                from the saveset associated with the handle/instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::saveAllSpectrumContents {sname}</code>
           </term>
           <listitem>
               <para>
                Saves the contents of all spectra into the saveset
                given by the handle/instance command
                <parameter>sname</parameter>. The saveset must
                already have the spectra definitions stored.
                This is normally used at some point after a call to
                <function>dbconfig::saveConfig</function>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::restoreAllSpectrumContents {sname}</code>
           </term>
           <listitem>
               <para>
                Restores all spectra with saved contents stored in the savest
                designated by the handle/saveset instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::listSavedSpectra {sname}</code>
           </term>
           <listitem>
               <para>
                Returns a list of the names of spectra that have
                channels stored in the save set designated by the
                handle/save set instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The <literal>pkgconfig</literal> does not provide the ability
        to store or playback event data directly, several procs
        <emphasis>do</emphasis> provide the ability to get information
        about the runs stored in a save set and the ability to
        get scaler data <emphasis>is</emphasis> provided.
    </para>
    <para>
        Let's take a quick tour through those procs.
    </para>
    <variablelist>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::listRuns {cmd}</code>
           </term>
           <listitem>
               <para>
                Returns a list of dicts that describe all of the
                runs in the database whose connection is indicated
                by <parameter>cmd</parameter>.  Note:
                Database, not saveset, handle/instance command, not
                name.
               </para>
               <para>
                Each dict in the, possibly empty, result list is
                a dict with the following key/value pairs:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>config</literal></term>
                   <listitem>
                       <para>
                        Contains the name of the configuration
                        (save set) that contains this run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>number</literal></term>
                   <listitem>
                       <para>
                        The run number of the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>title</literal></term>
                   <listitem>
                       <para>
                        The title string associated with the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>start_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run started. This is a timestamp
                        that can be can be turned into a human readable
                        string via <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>stop_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run stopped as a
                        timestamp suitable to be used with
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::hasRun {saveset}</code>
           </term>
           <listitem>
               <para>
                Returns a boolean that is true if the
                saveset indicated by the <parameter>saveset</parameter>
                handle/instance command has associated event data.
                If not, returns false.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::getRunInfo {saveset}</code>
           </term>
           <listitem>
               <para>
                If the saveset indicated by the handle/instance command
                <parameter>saveset</parameter> has saved event data,
                this will return a list of dicts, just like
                <function>dbconfig::hasRun</function> does, but confined
                only for the runs in the save set.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::getScalers {saveset run}</code>
           </term>
           <listitem>
               <para>
                Returns the scaler data associated with the
                run number <parameter>run</parameter> in the saveset
                indicated by the handle/instance command
                <parameter>saveset</parameter>.  The result is a list
                of dicts.  Each dict corresponds to a scaler readout.
               </para>
               <para>
                The dicts have the following key/values:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>start</literal></term>
                   <listitem>
                       <para>
                        Time into the run at which the scalers
                        started counting for this readout.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>stop</literal></term>
                   <listitem>
                       <para>
                        Time into the run at which the scaler counting
                        for this readout ended.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>divisor</literal></term>
                   <listitem>
                       <para>
                        The value to divide <literal>start</literal>
                        and <literal>stop</literal> by to get seconds
                        into the run.  This allows for subsecond
                        accuracy in those values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>timestamp</literal></term>
                   <listitem>
                       <para>
                        The timestamp associated with the
                        scaler readout.  This is suitable for input
                        to <command>clock format</command>.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>sourceid</literal></term>
                   <listitem>
                       <para>
                        The id of the data source that contributed these data.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>channels</literal></term>
                   <listitem>
                       <para>
                        A list of the channel values that have been
                        readout.
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        In addition to the <literal>dbconfig</literal> package,
        a command ensemble in the <literal>SpecTclDB</literal> package is used by
        the SpecTcl to manage event recording to the database and event playback
        from a database. 
    </para>
    <para>
        The base command for this command ensemble is
        <command>daqdb</command>.  This command ensemble is not
        separable from SpecTcl.  It is intended to support the needs
        of graphical user interfaces that control the recording of
        and playback of data within SpecTcl.  Again, have a look
        at the SpecTcl user interface that is available before
        you start writing your own.
    </para>
    <para>
        The remainder of this chapter is a brief guided tour of the
        the subcommands of this command ensemble.
    </para>
    <variablelist>
        <varlistentry>
           <term><command>open</command><replaceable>file-name</replaceable></term>
           <listitem>
               <para>
                Access the database <parameter>file-name</parameter>.
                If the event processor and event sink needed to record
                data are not yet set up, they are set up.  Note that
                they are setup in the disabled state. It is necessary
                to enable event recording before that can take
                place.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>enable</command></term>
           <listitem>
               <para>
                Enables event recording beginning with the next run.  The
                next run is defined as SpecTcl receiving a begin run item
                on its data source, that is the event recording
                event processor's <methodname>OnBegin</methodname>
                method is called.
               </para>
               <para>
                Note that when event recording starts:
               </para>
                <itemizedlist>
                    <listitem>
                       <para>
                          A new saveset is created with a name derived from
                          the run number.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          The analysis state is saved to the new saveset. 
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Events and scaler readouts will be stored in this
                          new save set.
                       </para>
                    </listitem>
                </itemizedlist>
                <para>
                    When <methodname>OnEnd</methodname> is called,
                    the run description is given its end time.
                    At that time, the contents of any
                    spectra in the auto save are written to the saveset.
                    See below.
                    This
                    does not disable event recording. Each run
                    will repeat this sequence.
                </para>
                <para>
                 This implies that SpecTcl, using this package will not
                 let you save more than one run per saveset, and that an single run
                 can only be saved once per database.
                </para>
                
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>disable</command></term>
           <listitem>
               <para>
                Disbables evfent recording instantly.  If data are
                actively being recorded, any active run will not have an
                end time.  This does not prevent the data from
                being played back.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>close</command></term>
           <listitem>
               <para>
                Closes the database and tears down the recording
                event processor and event sink.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>autosave</command> <replaceable>spectrum-list</replaceable></term>
           <listitem>
               <para>
                The event recording subsystem allows you to provide a list of
                spectrum names whose contents will be saved when an
                end run is encountered while writing event data.
                This list is called the <firstterm>autosave list</firstterm>.
               </para>
               <para>
                The <parameter>spectrum-list</parameter> parameter to this
                command is a list of the names of spectra.  The autossave list
                is set to this list.  Any spectra on this autosave list prior to
                to this command are no longer on the autosave list.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>listruns</command></term>
           <listitem>
               <para>
                Returns a list of dicts.  Each dict describes a
                run that is recorded in the event file.  The dicts
                 have the following key/value pairs:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>number</literal></term>
                   <listitem>
                       <para>
                        The number of the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>config</literal></term>
                   <listitem>
                       <para>
                        The name of the save set containing that run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>title</literal></term>
                   <listitem>
                       <para>
                        The title string associated with the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>start_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run started.  This
                        value can be formatted for humans via
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>end_time</literal></term>
                   <listitem>
                       <para>
                        The time at wich the run ended.  This value
                        can be formatted with
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>play</command> <replaceable>run-number</replaceable></term>
           <listitem>
               <para>
                Begins playback of the run <parameter>run-number</parameter>.
                While playback is in progress, the event loop is
                periodically flushed, which keeps the user interface alive.
                Note that playback and recording cannot be done simultaneously due
                to the way in which recording data locks the database.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>stop</command></term>
           <listitem>
               <para>
                Stops any ongoing playback.
               </para>
            </listitem>
        </varlistentry>
    </variablelist>
    </chapter>
    <chapter>
       <title>The SpecTcl database GUI.</title>
       <para>
        The SpecTcl database GUI provides a simple graphical user interface
        to the database.  It allows you to
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Create empty databases and access existing ones. 
           </para>
        </listitem>
        <listitem>
           <para>
              View the contents of a database in a tree-like graphical
              form.
           </para>
        </listitem>
        <listitem>
           <para>
              Save configurations to and restore them from savesets. 
           </para>
        </listitem>
        <listitem>
           <para>
              Save and store the contents of spectra to a save set. 
           </para>
        </listitem>
        <listitem>
           <para>
               Initiate and end event recording.
           </para>
        </listitem>
        <listitem>
           <para>
              Specify auto save spectrum lists for event recording. 
           </para>
        </listitem>
        <listitem>
           <para>
              Initiate and stop event playback from runs saved in a
              saveset.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        You can use the GUI by adding the following lines to your
        <filename>SpecTclRC.tcl</filename>:
       </para>
       <example>
        <title>Incorporating the database GUI in your SpecTcl</title>
        <programlisting>
lappend auto_path [file join $SpecTclHome TclLibs]
...
package require dbgui
        </programlisting>
       </example>
       <para>
        With a database file open, the GUI might look like this:
       </para>
       <figure>
        <title>The SpecTcl database GUi window</title>
        <graphic format='PNG' fileref='GUI.png' scalefit='1'/>
       </figure>
       <para>
        Each saveset is shown as a folder.  Within open folders, the entities
        stored in the saveset are identified by various icons.
        These are describe in the figure.  Note that an item in the
        user interface may be selected by clicking it.  If an item
        is selected it is highlighted as shown.  The status line
        at the bottom of the window includes the database name,
        the name of the current configuration, the currently selected item and,
        not shown, a digital clock.
       </para>
       <para>
        You interact with the graphical user interface via commands
        on its menubar and pop-up <firstterm>context menus</firstterm>
        accessed by right clicking on selected items in the
        main window of the GUI.
       </para>
       <para>
        First we'll look at the menubar menus and their contents.
        Then we'll look at the context menus that are available.
       </para>
       <section>
        <title>The GUI Menubar</title>
        <formalpara>
            <title>File Menu</title>
            <para>
                The File menu has the following commands:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>New...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a new file.
                            The file will be initialized with the
                            schema needed to serve as a database file.
                            The resulting, presumably empty database will then be opened and
                            used as the current database.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Open...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a file. The
                            selected file must be a previously initialized database
                            file.  The selected file is opened and
                            becomes the new database file.
                           </para>
                           <para>
                            The view of the current database is updated to reflect
                            all of the savesets in the file.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>The Save Menu</title>
            <para>
                This menu allows you to save various things into
                the database:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Configuration...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a new save set
                            and saves the current SpecTcl analysis configuration
                            into that saveset. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for spectra to save. The
                            contents of the selected spectra are saved to the
                            current save set.  If there is no current savset,
                            An error dialog tells you that.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Recording</title>
            <para>
                This menu supports various aspects of event recording
                into the database.
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Enable Recording</guimenuitem></term>
                       <listitem>
                           <para>
                            This checkbutton turns on or off event recording.
                            While event recording is active the main window
                            actions are disabled because event recording
                            locks the entire database.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Autosave spectra...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the spectra whose contents are automatically
                            saved at the end of a recorded run.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Help</title>
            <para>
                The <guimenu>Help</guimenu> menu only contains
                the <guimenuitem>About...</guimenuitem>
                entry.  That entry pops up a message box that
                provides information about the GUI and its
                version.
            </para>
        </formalpara>

       </section>
       <section>
        <title>Pop Up context menus</title>
        <para>
            Each of the object types in the GUI has a context menu that can
            be popped up by right clicking that object. This
            section describes those menuse and what their commands do.
        </para>
        <formalpara>
            <title>Configurtion context menu</title>
            <para>
                This context menu is activated by right clicking
                on a saveset or the configuration saved in that saveset.
                It makes the following commands available:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Save...</guimenuitem></term>
                       <listitem>
                           <para>
                            Requests a new save set name, creates that save set
                            and saves the current analysis
                            configuration in that saveset.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Save Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Requests a spectrum name and saves that
                            spectrum's contents in the currently selected save set.
                            Note that activating the context menu
                            makes the configuration the mouse is over
                            the current configuration.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Load</guimenuitem></term>
                       <listitem>
                           <para>
                            Loads the configuration into SpecTcl.
                            This restores the parameter, tree parameter,
                            spectrum and gate definitions as well as the
                            gate applications and tree variable definitions and
                            values into SpecTcl.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                If you post this menu by mistake, the escape keyboard key
                will unpost it.
            </para>
        </formalpara>
        <formalpara>
            <title>Spectrum context menu</title>
            <para>
                This context menu is activated when you right click
                a spectrum object in a save set.  It has the following commands:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Resave</guimenuitem></term>
                       <listitem>
                           <para>
                            The current contents of the spectrum indicated are
                            saved into the current save set.  Prior contents are
                            cleared first.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Save Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for a spectrum whose contents will be
                            saved in the currently selected save set.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Load</guimenuitem></term>
                       <listitem>
                           <para>
                            Loads the contents of the selected spectrum
                            into the same spectrum in SpecTcl.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Run context menu</title>
            <para>
                This menu supports event playback:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Play...</guimenuitem></term>
                       <listitem>
                           <para>
                            After prompting for confirmation warning of the
                            consequences of playing back data:
                            Turn off any active recording. Prompts to
                            ask if the user wants to restore the
                            analysis configuration prior to playback,
                            Asks as well if you want to clear all spectra
                            prior to playback.
                           </para>
                           <para>
                            On confirmation, initiates playback.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Stop</guimenuitem></term>
                       <listitem>
                           <para>
                            Disables any playback in progress.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
       </section>
    </chapter>
    <appendix>
        <title>Reference material</title>
        <section>
            <title>Reference material for the C++ API classes.</title>
            <para>
                This section will provide reference information for
                the database API classes. The order in which this documentation
                is given is roughly hierarchical. For classes that encapsulate
                database objects, the order follows dependency.
                That is many object types depend on the existence
                of other object types, the most primitive objects
                come first and no class comes prior to the classes
                that have data it might depend on.
            </para>
            <refentry>
               <refmeta>
                  <refentrytitle>CDatabase</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CDatabase</refname>
                  <refpurpose>Database creation and access</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;SpecTclDatabase.h&gt;
namespace SpecTclDB {
    
    class CDatabase {
        
    public:
        static void create(const char* database);

        CDatabase(const char* database);
        
        SaveSet* createSaveSet(const char* name);
        SaveSet* getSaveSet(const char* name);
        SaveSet* getSaveSet(int id);
        std::vector&lt;SaveSet*&gt; getAllSaveSets();
        
    };
    
}                         // SpecTclDB namespace.



                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>INTRODUCTION</title>
                      <para>
                        The <classname>SpecTclDB::CDatabase</classname>
                        class provides services for creating new databases
                        and opening existing databases.  Objects
                        of this type allow you to create new savesets
                        and perform queries about existing save sets.
                      </para>
                </refsect1>
                <refsect1>
                    <title>methods</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static void </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>database</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                IF <parameter>database</parameter>
                                does not exist, that file will be created.
                                The database scheme will be added to that file.
                                If this is called on a file that already has the
                                SpecTcl database schema, nothing bad happeens
                                because all elements of the schema are created
                                using
                                <code language="sql">CREATE xxx IF NOT EXISTS</code>
                               </para>
                               <para>
                                If the file already exists and is an Sqlite3 database,
                                the schema for a SpecTcl database is added to that
                                database.  This may have some valid use case.  If
                                the file exists but is not an
                                Sqlite3 database file, an exception
                                derived from
                                <classname>std::exception</classname>
                                is thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CDatabase</methodname>
                                <methodparam>
                                    <type>const char* </type><parameter>database</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The constructor creates an object that
                                wraps a specific, existing database.
                                If the <parameter>database</parameter>
                                does not exist or does not have the correct schema,
                                a <classname>std::invalid_argument</classname>
                                exception is thrown.
                                If <parameter>database</parameter> is not an Sqlite3
                                database file, <classname>CSqliteException</classname>
                                is thrown.  Note that <classname>std::exceiption</classname>
                                is a parent class for <classname>CSqliteException</classname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>SaveSet* </type>
                               <methodname>createSaveSet</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new save set in the database encapsulated
                                by the object.  The name of the saveset will be
                                <parameter>name</parameter>.  
                               </para>
                               <para>
                                On
                                success, a pointer to a
                                <classname>SpecTclDB::SaveSet</classname>
                                object is returned that encapsulates
                                the save set.  
                                The return value is dynamically
                                allocated and, therefore, must be
                                deleted when your program is done with it.
                               </para>
                               <para>
                                On failure an
                                <classname>std::invalid_argument</classname>
                                exception is thrown.  This is most often because
                                there already is a save set
                                named <parameter>name</parameter>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>SaveSet* </type>
                               <methodname>getSaveSet</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a pointer to a dynamically created
                                <classname>SpecTclDB::SaveSet</classname> object
                                that encapsulates the save set
                                <parameter>name</parameter>.
                                The caller must, at some point,
                                delete this object to avoid resource leaks.
                                On failure, usually because
                                <parameter>name</parameter>, is not the name
                                of a save set, an
                                <classname>std::invalid_argument</classname>
                                exception is thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>SaveSet* </type>
                               <methodname>getSaveSet</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as above however
                                <parameter>id</parameter> is the
                                primary key of the save set we're looking up.
                                If you know a saveset's id, this is
                                nominally faster than a lookup by name.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;SaveSet*&gt; </type>
                               <methodname>getAllSaveSets</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector that contains
                                the savesets contained by the database.
                                Each saveset is encapsulated in a
                                <classname>SpecTclDB::SaveSet</classname>
                                object.  The vector contains pointers to these
                                objects which are dynamically
                                created and must, therefore, be
                                destroyed at some point by the
                                caller.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>SaveSet</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>SaveSet</refname>
                  <refpurpose>Encapsulate a save set.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;SaveSet.h&gt;

namespace SpecTclDB {
    class DBParameter;
    class DBSpectrum;
    class DBGate;
    class DBApplication;   
    class DBTreeVariable;
    
    /**
     * @class SaveSet
     *    This class encapsulates a save set and all the things
     *    you can do to it _except_ playing back events.
     *
     */
    class SaveSet {
    public:
        struct Info {
            int         s_id;
            std::string s_name;   // requires copy construction etc.
            time_t      s_stamp;
        Info() {}
        Info(const Info&amp; rhs) {
            copyIn(rhs);
        }
        Info&amp; operator=(const Info&amp; rhs) {
            if (&amp;rhs != this) copyIn(rhs);
            return *this;
        }
        void copyIn(const Info&amp; rhs) {
            s_id = rhs.s_id;
            s_name = rhs.s_name;
            s_stamp = rhs.s_stamp;
        }
        };
        struct SpectrumAxis {
            double s_low;
            double s_high;
            int    s_bins;
        };
        // Stuff having to do with run playback:
        
        struct RunInfo {
            int         s_runNumber;
            std::string s_title;
            time_t      s_startTime;
            time_t      s_stopTime;
            
        };
        struct ScalerReadout {
            int    s_sourceId;
            int    s_startOffset;
            int    s_stopOffset;
            int    s_divisor;
            time_t s_time;
            std::vector&lt;int&gt; s_values;
        };
        struct EventParameter {   // Event blobs are a soup of these.
            int     s_number;
            double  s_value;
        };
        typedef std::vector&lt;EventParameter&gt; Event;
    public:
        static bool exists(CSqlite&amp; conn, const char* name);
        static SaveSet* create(CSqlite&amp; conn, const char* name);
        static std::vector&lt;Info&gt; list(CSqlite&amp; conn);

    public:
        SaveSet(CSqlite&amp; conn, const char* name);     // Construct given name
        SaveSet(CSqlite&amp; conn, int id);
    
    // Object methods:
    public:
        const Info&amp; getInfo();
        

        
        std::vector&lt;DBParameter*&gt; listParameters();
        DBParameter* createParameter(const char* name, int number);
        DBParameter* createParameter(
            const char* name, int number,
            double low, double high, int bins, const char* units
        );
        DBParameter* findParameter(const char* name);
        DBParameter* findParameter(int number);
        DBParameter* getParameter(int id);
        
        // Spectrum API:
        
        bool spectrumExists(const char* name);
        DBSpectrum* createSpectrum(const char* name, const char* type,
                const std::vector&lt;const char*&gt;&amp; parameterNames,
                const std::vector&lt;SpectrumAxis&gt;&amp; axes,
                const char* datatype="long"
        );

        std::vector&lt;DBSpectrum*&gt; listSpectra();

        DBSpectrum* lookupSpectrum(const char* name);
    
        // Gate api:
        
        bool gateExists(const char* name);
        DBGate*  create1dGate(
            const char* name, const char* type,
            const std::vector&lt;const char*&gt;&amp; params, double low, double high
        );
        DBGate* create2dGate(
            const char* name, const char* type,
            const std::vector&lt;const char*&gt;&amp; params,
            const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; points
        );
        DBGate* createCompoundGate(
            const char* name, const char* type,
            const std::vector&lt;const char*&gt;&amp; gates
        );
        DBGate* createMaskGate(
            const char* name, const char* type,
            const char* parameter, int imask
        );
        DBGate* lookupGate(const char* name);
        DBGate* lookupGate(int id);
        std::vector&lt;DBGate*&gt; listGates();
        
        // Gate application api:
        
        DBApplication* applyGate(const char* gate, const char* spectrum);
        DBApplication* lookupApplication(const char* gate, const char* spectrum);
        std::vector&lt;DBApplication*&gt; listApplications();
        
        // Treevariable API

        DBTreeVariable* createVariable(
            const char* name, double value, const char* units=""
        );
        DBTreeVariable* lookupVariable(const char* name);
        bool variableExists(const char* name);
        std::vector&lt;DBTreeVariable*&gt; listVariables();
        
        // Event recording in the database.
        
        int startRun(
            uint32_t run, const char* title, time_t start
        );
        void endRun(int id, time_t endtime);
        int saveScalers(
            int id, int sourceid,
            int startOffset, int stopOffset, int divisor, time_t when,
            int nScalers, const uint32_t* scalers
        );
        void* startEvents(int id);
        void  rollbackEvents(void* savept);
        void  endEvents(void* savept);
        void  saveEvent(
            int id,  int event, int nParams,
            const int* paramids, const double* params
        );
        
        std::vector&lt;int&gt; listRuns();
        
        // Accessing runs
        
        int openRun(int number);
        
        void* openScalers(int runid);
        int   readScaler(void* context, ScalerReadout&amp; result);
        void  closeScalers(void* context);
        void* openEvents(int runid);
        int   readEvent(void* context, Event&amp; result);
        void closeEvents(void* context);
        
        RunInfo getRunInfo(int id);
        
        
    

    };
}                                  // SpecTclDB 

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                      <title>INTRODUCTION</title>
                      <para>
                        The <classname>SpecTclDB::SaveSet</classname>
                        class encapsulates a save set in an object.
                        Methods are provided to create save sets and
                        the constructor wraps a save set into an object.
                      </para>
                      <para>
                        Once you have a save set, you can us it to
                        prerform a number of operations on the save set.
                        These operations may require a number
                        of data type definitions.
                        See <literal>METHODS</literal>
                        and <literal>DATA TYPES</literal> for more.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal>
                                if the save set named
                                <parameter>name</parameter> has been
                                created in the database connected to
                                <parameter>conn</parameter>.
                                Normally, this method is used by the
                                <classname>SpecTclDB::CDatabase</classname> class
                                whose objects encapsulate a raw
                                <classname>CSqlite</classname> object.
                               </para>
                               <para>
                                For information about the
                                <classname>CSqlite</classname>
                                class, see the
                                <literal>3sqlite++</literal> reference
                                section.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static SaveSet* </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new save set named
                                <parameter>name</parameter> in the
                                database connected to <parameter>conn</parameter>.
                                This is normally  used by
                                <classname>SpecTclDB::CDatabase</classname>.
                                The resulting
                                <classname>SpecTclDB::SaveSet</classname>
                                object pointed to by the return value is
                                dynamically allocated and must be deleted
                                when your program is done using it.
                               </para>
                               <para>
                                On error, the method throws a
                                <classname>std::invalid_argument</classname>
                                exception.  The most common error is
                                that there is already a save set named
                                <parameter>name</parameter> in the database.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;Info&gt; </type>
                               <methodname>list</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector whose elements are pointers to
                                every save set defined in the database connected
                                via <parameter>conn</parameter>.
                                Normally, this is used by
                                <classname>SpecTclDB::CDatabase</classname>.
                                The pointers in the result are pointers to dynamically
                                created objects that must, eventually be
                                deleted.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>SaveSet</methodname>
                                <methodparam>
                                    <type>CSqlite&amp;</type><parameter> conn</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type><parameter>name</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Constructs a
                                <classname>SpecTclDB::SaveSet</classname> object
                                wrapping one named <parameter>name</parameter>
                                in the database connected to
                                <parameter>conn</parameter>.
                                This is normally used by the
                                <classname>SpecTclDB::CDatabase</classname>
                                class.  <parameter>name</parameter>
                                must already exist.  If not, a
                                <classname>std::invalid_argument</classname>
                                exception is thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>SaveSet</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>conn</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int</type><parameter> id</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as previous constructor but the
                                specific save set is selected by the
                                primary key of the save set (
                                <parameter>id</parameter>
                                ).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Information about the save set wrapped
                                by a
                                <classname>SpecTclDB::SaveSet</classname>
                                object is cached in an information structure
                                (<type>SpecTclDB::SaveSet::Info</type>).
                                This returns a const reference to that struct.
                                Examining the struct members allows you to
                                know essentially everything about the top level
                                save set definition.
                               </para>
                               <para>
                                The members of the
                                <type>SpecTclDB::SaveSet::Info</type>
                                struct are described in the
                                <literal>DATA TYPES</literal> section of this
                                manpage.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;DBParameter*&gt; </type>
                               <methodname>listParameters</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector of pointers to
                                <classname>SpecTclDB::DBParameter</classname> objects
                                that provide poiners to objects encapsulating
                                all parameter definitions. These
                                pointers are to dynamically allocated objects and
                                therefore must, at some point, have
                                delete operate on them.
                               </para>
                               <para>
                                See the reference page for
                                <classname>SpecTclDB::DBParameter</classname>
                                for information about the objects that
                                are returned.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBParameter* </type>
                               <methodname>createParameter</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new minimal parameter definition.
                                <parameter>name</parameter> is the name of the new
                                parameter while <parameter>number</parameter>
                                is the parameter number.  In addition, the database
                                assigns the parameter a primary key which
                                can be used for retrieval.
                               </para>
                               <para>
                                The return value is a pointer to a dynamically
                                created
                                <classname>SpecTclDB::DBParameter</classname>
                                which encapsulates the ata store for the parameter
                                in the database.   The parameter pointer points to a
                                dynamically allocated object and, therefore,
                                must be operated on by delete when you are done
                                with it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBParameter*</type>
                               <methodname> createParameter</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>low</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double</type><parameter> high</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>bins</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter> units</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as the previous overload of
                                <methodname>createParameter</methodname>, however
                                this version of the method includes, in addition to the
                                minimal values of <parameter>name</parameter>
                                and <parameter>number</parameter>, metadata.
                                The metadata provided provides hints to the user and
                                graphical user interfaces when constructing
                                spectrum axes that represent the parameter.
                               </para>
                               <para>
                                <parameter>low</parameter> and
                                <parameter>high</parameter> are suggested low and
                                high limits for such axes.
                                <parameter>bins</parameter> is the suggested
                                number of bins for the axis. Finally,
                                <parameter>units</parameter> is a reminder to users
                                of the units of measure in which the parameter is
                                produced.  Note that a normal convention for
                                unitless parameters is to provide an empty string.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBParameter*</type>
                               <methodname> findParameter</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Encapsulates the parameter named by <parameter>name</parameter>
                                in a <classname>SpecTcl::DBParameter</classname>
                                object.  The object is dynamically created and
                                a pointer to it returned.  When the object is no
                                longer deleted the pointer should be operated on by
                                delete.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBParameter* </type>
                               <methodname>findParameter</methodname>
                               <methodparam>
                                   <type>int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as above, but the lookup is by the number
                                 of the parameter passsed to
                                 <methodname>createParameter</methodname>.
                                 In the context of SpecTcl, the number is a slot
                                 in <classname>CEvent</classname> objects that
                                 represent unpacked events.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBParameter* </type>
                               <methodname>getParameter</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Retrievs a parameter by its primary key value.
                                Unlike the parameter number which is assigned by the
                                application, the primary key is an integer that is
                                assigned to each row of the parameter definition
                                table by the database when an insert is performed.
                               </para>
                               <para>
                                This is most often useful to lookup parameters that are
                                referred to by other objects in the database.
                                In order to create a database that is in one of the
                                normal forms, references to objects that other
                                objects depend on are stored as the primary key.
                                In database terminology these are called
                                <firstterm>foreign keys</firstterm>.
                               </para>
                               <para>
                                Most realtional databases are constructed so that
                                lookups by primary key are very fast.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>spectrumExists</methodname>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if the saveset
                                contains a spectrum definition for a spectrum
                                called <parameter>name</parameter>. If not
                                <literal>false</literal> is returned.
                               </para>
                            </listitem>
                        </varlistentry>
                    
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBSpectrum* </type>
                               <methodname>createSpectrum</methodname>
                               <methodparam>
                                   <type>const char*</type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                                 <methodparam>
                                    <type>const char* </type><parameter>type</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const std::vector&lt;const char*&gt;&amp; </type><parameter>parameterNames</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const std::vector&lt;SpectrumAxis&gt;&amp; </type><parameter>axes</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type><parameter>datatype=</parameter>
                                    <initializer>"long"</initializer>
                                </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new spectrum definition in the database.
                                The name of the spectrum is <parameter>name</parameter>.
                                The spectrum type code is <parameter>type</parameter>.
                                
                               </para>
                               <para>
                                All spectra are defined on some set of parameters.
                                The order of these parameters is important, and
                                stored in the data base in a way that it can be recovered.
                                <parameter>parameterNames</parameter> is an ordered 
                                vector of parameters the spectrum depends on.  The
                                names of these parameters must match the name of a
                                previously defined parameter in
                                <emphasis>this</emphasis> saveset.
                               </para>
                               <para>
                                Spectra have one or two free axes.  By free axes,
                                I mean axes whose definition is not obvious from the
                                spectrum type and must be provided to complete the
                                spectrum definition.  For example, the X axis of
                                a summary spectrum is fully determined by the number
                                of parameters the summary is defined on and therefore
                                not a free axis.  Axis specification order is important,
                                for example, in a <literal>2</literal> spectrum, the
                                the first axis description is the X axis and the scond
                                the Y.  <parameter>axes</parameter> is an ordered
                                vector
                                of axis specifications that describe the axis
                                low limite, high limit and number of bins for each free
                                axis. See the <literal>DATA TYPES</literal> section
                                that, among other things describes the
                                <type>SpecTclDB::SaveSet::SpectrumAxis</type>
                                data type used here.
                               </para>
                               <para>
                                Finally, an optional <parameter>datatype</parameter>
                                parameter specifies the data type used to store
                                each bin of spectrum data. This defaults to
                                <literal>"long"</literal>. Valid string values are:
                                <literal>"long"</literal> which creates bins that are
                                32 bits wide, <literal>"word"</literal> which creats
                                bins that are 16 bits wide and <literal>"byte"</literal>
                                which creates bins that are 8 bits wide.
                               </para>
                               <para>
                                The return value from this method is a pointer
                                to a <classname>SpecTclDB::DBSpectrum</classname> object
                                that wraps the spectrum definition in the
                                database.  This object is dynamically created.
                                Once the program no longer needs it, delete should operate
                                on that pointer in order to free the object.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;DBSpectrum*&gt; </type>
                               <methodname>listSpectra</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector containing pointers to objects
                                that encapsulate all spectrum definitions in this
                                save set. Note that these objects are all
                                dynamically allocated and, therefore delete
                                must operate on these pointers.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBSpectrum* </type>
                               <methodname>lookupSpectrum</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the saveset has a definition for the spectrum
                                named <parameter>name</parameter>,  a pointer to an object
                                wrapping of the spectrum is returned.
                                When the program no longer needs this object,
                                it should be deleted.  
                               </para>
                               <para>
                                If no spectrum with that name has been defined in the
                                saveset, an <classname>std::invalid_argument</classname>
                                exception is thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>gateExists</methodname>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the saveset has a definition for a gate named
                                <parameter>name</parameter>, this method returns
                                <literal>true</literal>, if not,
                                <literal>false</literal> is returned instead.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate*  </type>
                               <methodname>create1dGate</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const std::vector&lt;const char*&gt;&amp; </type><parameter>params</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>low</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double</type><parameter> high</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a 1-d gate definition in the saveset.
                                Gates come in three broad categories, depending on the
                                data they need to express them:
                               </para>
                               <orderedlist>
                                <listitem>
                                   <para>
                                      Point gates require parameters and one or
                                      more sets of points in parameter space.
                                   </para>
                                   <para>
                                    Polnt gates are further subdivided into
                                    1-d and 2-d points which are determined by
                                    the dimensionality of the region of interest
                                    defined by the gate.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      Compound gates are gates that are checked by
                                      performing a logical operation on some other
                                      set of gates.
                                   </para>
                                </listitem>
                               
                               <listitem>
                                  <para>
                                     Mask gates are gates that require one parameter
                                     and a bitmask. The parameter value is treated
                                     as an integer.  Some bitwise operation is
                                     performed between the mask and parameter and
                                     a check is performed on the result.
                                  </para>
                               </listitem>
                            </orderedlist>
                            <para>
                             This method creates a 1-d point gate. Examples of
                             such gates are slices and gamma slices.
                             <parameter>name</parameter> is the name of the gate
                             that will be created in the save set.
                             <parameter>type</parameter> is a textual gate type
                             string.
                            </para>
                            <para>
                             As this is a point gate, <parameter>params</parameter>
                             is a vector of parameters the gate will be checked against.
                             for slice gates this will be a single parameter, for gamma
                             slices, more than one. <parameter>low</parameter>
                             and <parameter>high</parameter> define a segment
                             of 1-d parameter space.  Parameters must be in this
                             gate to make the gate true for this event.
                             See SpecTcl's documentation for more information on
                             what makes a gamma slice true.
                            </para>
                            <para>
                             The returned value is a pointer to a dynamically
                             created <classname>SpecTclDB::DBGate</classname>
                             object.  When your program no longer needs this
                             object, it should be deleted.
                            </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate* </type>
                               <methodname>create2dGate</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type> const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const std::vector&lt;const char*&gt;&amp; </type><parameter>params</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const std::vector&lt;std::pair&lt;double, double&gt;&gt;&amp; </type><parameter>points</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a point gate where the region of interest is a
                                2-dimensional figure.  Examples are bands, contoures,
                                gamma contours etc.
                               </para>
                               <para>
                                As before, the <parameter>name</parameter>
                                parameter specifies the name of the gate and
                                <parameter>type</parameter> a gate type
                                string.  Again as before <parameter>parameters</parameter>
                                are the parameters on which the gate is defined.
                                Order can be important.  For example for a contour,
                                the first parameter is the X parameter the second the
                                Y parameter.
                               </para>
                               <para>
                                <parameter>points</parameter> is an ordered list
                                of X, Y pointes in parameter space that define
                                the region of acceptance of the gate.  See the SpecTcl
                                documentation for information about how the
                                region of acceptance is intepreted when evaluating
                                a gate.
                               </para>
                               <para>
                                The returned value is a pointer to a dynamically
                                created <classname>SpecTclDB::DBGate</classname>
                                object.  When your program no longer needs this
                                object, it should be deleted.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate* </type>
                               <methodname>createCompoundGate</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const std::vector&lt;const char*&gt;&amp; </type><parameter></parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a compound gate definition. Compound gates
                                are dependent on other gates, some of which could,
                                themselves, also be compound gates.  In SpecTcl,
                                compound gates can nest to any depth as long as
                                there are no circular dependencies.
                               </para>
                               <para>
                                As before, <parameter>name</parameter> is the
                                name of the gate definition now being made,
                                <parameter>type</parameter> is the type of the gate
                                (e.g. <literal>"*"</literal> for an and gate).
                                <parameter>gates</parameter> is a vector of
                                names of gates that are already defined in the
                                save set.
                               </para>
                               <para>
                                Note that when saving the gate definitions in
                                SpecTcl, you must be careful to determine the gate
                                dependencies to ensure that gates are not defined
                                in the database prior to all their dependent gate
                                definitions.  The Tcl high level SpecTcl
                                API does this dependency analysis.
                               </para>
                               <para>
                                The database is organized that the method
                                <methodname>listGates</methodname> will return
                                gates in the order in which they were defined
                                which means that if dependency analysis was done when
                                saving gates, it does not need to be done when
                                restoring them.
                               </para>
                               <para>
                                The returned value is a pointer to a dynamically
                                created <classname>SpecTclDB::DBGate</classname>
                                object.  When your program no longer needs this
                                object, it should be deleted.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate* </type>
                               <methodname>createMaskGate</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name, const char* type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>parameter</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>mask</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a mask gate definition.  As before,
                                <parameter>name</parameter> is the name of the
                                gate and <parameter>type</parameter> is the
                                gate type (e.g. <literal>"em"</literal>).
                                Mask gates only take a single parameter:
                                <parameter>parameter</parameter> is the name of that
                                parameter, which  must already be defined in this
                                saveset. <parameter>mask</parameter> is the
                                mask.
                               </para>
                               <para>
                                The returned value is a pointer to a dynamically
                                created <classname>SpecTclDB::DBGate</classname>
                                object.  When your program no longer needs this
                                object, it should be deleted.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate* </type>
                               <methodname>lookupGate</methodname>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the gate named <parameter>name</parameter> has
                                a definition in this saveset, a pionter to
                                an object encapsulating that gate definition is returned.
                                If <parameter>name</parameter> has not been defined
                                in the save set, an
                                <classname>std::invalid_exception</classname>
                                is thrown.
                                The object pointed to by the return value is
                                dynamically allocated and must therefore be
                                deleted when the program has no further need for it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBGate* </type>
                               <methodname>lookupGate</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as above, but lookup is by the primary
                                key of the gate in the top level table for
                                gate definitions.  This is generally a faster
                                way to find a gate if its primary key is known
                                (for example, in a compound gate, the dependent
                                gates are stored as gate ids).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;DBGate*&gt; </type>
                               <methodname>listGates</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector of pointer to
                                <classname>SpecTcl:DBGate</classname> objects.
                                The vector will contain pointers to objects that will
                                encapsulate all gates defined in this save set.
                                The vector order will be such that no gate will
                                appear in the vector without all of its dependencies
                                appearing first.
                               </para>
                               <para>
                                The pointers point to dynamically created objects.
                                All pointers must be deleted once the program
                                has no further need of them.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBApplication* </type>
                               <methodname>applyGate</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>gate</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>spectrum</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new gate application entry in the
                                save set.  Gates applied to spectra conditionalize that
                                spectrum's increment on the gate.  Even an event has
                                all the parameters needed to increment the spectrum,
                                if a gate is applied to a spectrum, it will
                                not be incremented unless that gate is true.
                               </para>
                               <para>
                                <parameter>gate</parameter> is the name of the
                                gate to apply and <parameter>spectrum</parameter>
                                is the name of the spectrum it should be applied to.
                                Bot gate and spectrum must already be defined in the
                                saveset.  Note that gate application is a one to
                                many thing.  A gate can be applied to as many
                                spectra as desired, but only one gate can be
                                applied to any single spectrum.
                               </para>
                               <para>
                                In fact, SpecTcl simplifies its gate checking logic
                                by requiring that all spectra always have
                                exactly one gate applied to it.  When a spectrum
                                is created a true gate is applied to it.
                                It is not necessary to store the application of
                                true gates to a spectrumm, unless once restored,
                                that gate may be changed to a different type of
                                gate.
                               </para>
                               <para>
                                The return value fromt his method is a
                                pointer to a 
                                <classname>SpecTclDB::DBApplication</classname> object.
                                The object encapsulates information about the
                                application and is dynamically created. When the
                                program no longers needs the object, therefore,
                                it should be destroyed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBApplication* </type>
                               <methodname>lookupApplication</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>gate</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>spectrum</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Looks up an application and returns a pointer
                                to an object wrapping of the data for it in the
                                database.  Note that applications are not named entities.
                                They can only be looked up by providing both the
                                gate name (<parameter>gate</parameter>) and the
                                target spectrum (<parameter>spectrum</parameter>).
                               </para>
                               <para>
                                The returned value is a pointer to a dynamically
                                created object. As such, when the calling program
                                no longer needs it, it should be deleted.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;DBApplication*&gt; </type>
                               <methodname>listApplications</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector containing pointers to all of the
                                gate applications defined in the save set.
                                These objects are all dynamically created and must be
                                deleted when the program no longer needs them.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBTreeVariable* </type>
                               <methodname>createVariable</methodname>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double</type><parameter>value</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>units</parameter>
                                <initializer>""</initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a tree variable definition.  <parameter>name</parameter>
                                is the name of the variable whose definition is
                                being captured.  <parameter>value</parameter>
                                is the value for it that will be stored.
                                <parameter>units</parameter> are the units of
                                measure of the variable.  If not supplied, this
                                defaults to an empty string which, by convention,
                                means a unit-less variable.
                               </para>
                               <para>
                                The return value is a pointer to a
                                <classname>SpecTclDB::DBTreeVariable</classname>
                                that encapsulates the database entry just made.
                                This is a pointer to a dynamically created object and,
                                therefore, must be deleted when it is no longer
                                needed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>DBTreeVariable* </type>
                               <methodname>lookupVariable</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If there is a definition for
                                the tree variable <parameter>name</parameter>
                                in the database it is retrieved and wrapped
                                with a <classname>SpecTclDB::DBTreeVariable</classname>
                                object.  If not, an <classname>std::invalid_argument</classname>
                                exception is thrown.  The return value is
                                dynamically constructed and, therefore, when the
                                program is done using it, you should delete it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>variableExists</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If there is a variable definition for
                                <parameter>name</parameter> in the saveset,
                                this method returns <literal>true</literal>.
                                If not, <literal>false</literal> is returned instead.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;DBTreeVariable*&gt;</type>
                               <methodname>listVariables</methodname>
                                <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a vector containing pointers to
                                <classname>SpecTclDB::DBTreeVariable</classname>
                                objects that describe all of the variable definitions
                                in the save set.  The pointers are to dynamically
                                allocated objects and therefore, once the
                                program is done with the objects they should be
                                deleted.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int </type>
                               <methodname>startRun</methodname>
                               <methodparam>
                                   <type>uint32_t </type><parameter>run</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>title</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>time_t </type><parameter>start</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates an entry in the save set for a begin run.
                                <parameter>run</parameter> is the run number of that
                                run, <parameter>title</parameter> is the run title
                                and <parameter>start</parameter> the clock time
                                a which the run actually started.
                                The return value is the primary key of the
                                run entry which should be used as a handle in future
                                calls to store data associated with the run.
                               </para>
                               <para>
                                Note tha the entry in the database has a
                                run end time.  This is initialized to null.
                                It can be set by a call to
                                <methodname>endRun</methodname> described below.
                                The two are separated because if you are building up
                                run data from a serial event file, there will
                                be a separation between the begin run record
                                and end run record of, potentially several million events.
                               </para>
                               <para>
                                The <parameter>start</parameter> time should not
                                be now, but the time the run actually started,
                                nopefully recorded in the start run
                                record of the event file being analyze.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>endRun</methodname>
                               <methodparam>
                                   <type>int</type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>time_t </type><parameter>endtime</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Sets the end of run time for the run with the
                                <parameter>id</parameter> returned from
                                <methodname>startRun</methodname>.  the
                                time used will be <parameter>endtime</parameter>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int </type>
                               <methodname>saveScalers</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sourceid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>startOffset</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>stopOffset</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>divisor</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>time_t when</type><parameter></parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>nScalers</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const uint32_t* </type><parameter>scalers</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Saves a scaler readout entry for the run
                                identified by <parameter>id</parameter>. This
                                id should have been returned from
                                <methodname>startRun</methodname>.
                               </para>
                               <para>
                                <parameter>sourceid</parameter> is an integer
                                that represents the source id that identifies data
                                from a specific source of data to the event builder.
                               </para>
                               <para>
                                <parameter>startOffset</parameter> and
                                <parameter>stopOffset</parameter> identifier the start and stop times of the
                                most recent scaler readout.  <parameter>divisor</parameter>
                                is the value to divide the offsets by to get a time
                                in seconds since the run started.
                               </para>
                               <para>
                                <parameter>nScalers</parameter> are the number of
                                scalers that were readout and <parameter>scalers</parameter>
                                is a pointer to that many scalers.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void* </type>
                               <methodname>startEvents</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                 Indicates that a set of decoded events
                                 are about to be stored in the database.
                                 Single database operations are comparitively slow,
                                 while doing several entries within a transaction
                                 or save point is much more efficient.  This
                                 method starts a save point and returns
                                 a handle to it.
                               </para>
                               <para>
                                The <parameter>id</parameter> parameter should be
                                the return value from the
                                <methodname>startRun</methodname> for the
                                run for which we are going to enter events.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void  </type>
                               <methodname>rollbackEvents</methodname>
                               <methodparam>
                                   <type>void* </type><parameter>savept</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Rolls back the save point created by a
                                call to <methodname>startEvents</methodname>.
                                <parameter>savept</parameter> is the value
                                returned from <methodname>startEvents</methodname>.
                                Once this is called, that pointer should not
                                be used as it is no longer pointing to anything
                                valid.
                               </para>
                               <para>
                                A rollback effectively cancels all database
                                insertions performed since the call to
                                <methodname>startEvents</methodname>.
                                This applies not just to event data but:
                               </para>
                               <itemizedlist>
                                <listitem>
                                   <para>
                                      Calls to <methodname>saveScalers</methodname> 
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      Calls to methods that create definitions
                                      for objects in this saveset.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      Calls to methods that result in insertions
                                      to the database that are performed on any
                                      object connected to the same database
                                      as this saveset.
                                   </para>
                                </listitem>
                               </itemizedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void  </type>
                               <methodname>endEvents</methodname>
                               <methodparam>
                                   <type>void* </type><parameter>savept</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Commits the save point created by the call to
                                <methodname>startEvents</methodname> that
                                returned the value passed to this method
                                as <parameter>savept</parameter>.
                                All insertions become finalized and become
                                visible to other clients of the database.
                               </para>
                               <para>
                                In actual fact, the save point affects more than
                                event data, see the description in
                                <methodname>rollbackEvents</methodname>
                                above.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void  </type>
                               <methodname>saveEvent</methodname>
                               <methodparam>
                                   <type>int </type><parameter>id</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>event</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>nParams</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const int* </type><parameter>paramid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const double* </type><parameter>params</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Saves an event either to the database directly or
                                to the set of queued events in the save point
                                created by a recent call to
                                <methodname>startEvents</methodname>.
                                <parameter>id</parameter> is the id of the run that
                                owns the event (returned from <methodname>startRun</methodname>).
                                <parameter>event</parameter> is the event number.
                                (should be a counter incremented after each event).
                                <parameter>nParams</parameter> the number
                                of unpacked parameters to be saved.
                                <parameter>paramids</parameter> points to the array
                                of parameter numbers for the parameters in the event.
                                By parameter numbers I mean the value of the
                                number field of a parameter definition.
                                <parameter>params</parameter>, pointer to an array of
                                corresponding parameter values.
                               </para>
                               <para>
                                If you are preparing to call this from a
                                <classname>CEvent</classname> object in SpecTcl,
                               </para>
                               <orderedlist>
                                <listitem>
                                   <para>
                                      <parameter>nParams</parameter>  is the size
                                      of that event's dope vector.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <parameter>parmids</parameter>  is the
                                      pointer returned from the call to
                                      <methodname>data</methodname> on the
                                      dope vector.
                                   </para>
                                </listitem>
                                <listitem>
                                   <para>
                                      <parameter>params</parameter>  can
                                      be produced by pushing the values corresponding
                                      to parameter ids in the dope vector intp a
                                      vector of doubles
                                      and then using the value returned from
                                      <methodname>data</methodname> called on that
                                      vector.
                                   </para>
                                </listitem>
                               </orderedlist>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;int&gt; </type>
                               <methodname>listRuns</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                returns a vector run number for the runs that
                                have data stored in this saveset.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int </type>
                               <methodname>openRun</methodname>
                               <methodparam>
                                   <type>int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Given a run number makes it available for data
                                retrieval by returning the primary key of the
                                run in the database.  The resultis known in the API
                                variously as a runid or just an id.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>RunInfo </type>
                               <methodname>getRunInfo</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Given a run primary key (run id) returns
                                information about it in a
                                <classname>SpecTclDB::SaveSet::RunInfo</classname>
                                struct.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void*</type>
                               <methodname>openScalers</methodname>
                               <methodparam>
                                   <type>int</type><parameter>runid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Begins pulling scaler readout data from the
                                whose run id is <parameter>runid</parameter>.
                                The return value is actually a handle into the
                                scaler data retrieval result set and
                                should be used in calls to
                                <methodname>readScaler</methodname>, and ultimately
                                <methodname>closeScalers</methodname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int   </type>
                               <methodname>readScaler</methodname>
                               <methodparam>
                                   <type>void*</type><parameter> context</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>ScalerReadout&amp;</type><parameter>result</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the next scaler read from the
                                result set, <parameter>context</parameter> that
                                was returned from a call to
                                <methodname>openScalers</methodname>.
                                The data are returned in the <parameter>result</parameter>
                                parameter.  The shape of the
                                <type>SpecTclDB::SaveSet::ScalerReadout</type>
                                type is described in the section
                                <literal>DATA TYPES</literal>.
                               </para>
                               <para>
                                If the return value was non zero there was another
                                readout and the data in
                                <parameter>result</parameter> is valid.  If not,
                                then there was no additional data and the
                                <parameter>result</parameter> data should
                                not be relied on.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void  </type>
                               <methodname>closeScalers</methodname>
                               <methodparam>
                                <type>void* </type><parameter>context</parameter>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                frees all reasources that are used by the
                                <parameter>context</parameter> parameter
                                returned from a previous call to
                                <methodname>openScalers</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void* </type>
                               <methodname>openEvents</methodname>
                               <methodparam>
                                   <type>int </type><parameter>runid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Prepares a result set for the events
                                associated with the run whose primary key is
                                <parameter>runid</parameter>.  The return
                                value is a context that should be used
                                to iterate over the result set.
                                See <methodname>readEvent</methodname>
                                and <methodname>closeEvents</methodname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int   </type>
                               <methodname>readEvent</methodname>
                               <methodparam>
                                   <type>void*</type><parameter> context</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>Event&amp;</type><parameter>result</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Retrieves the next event in the result set
                                indicted by <parameter>context</parameter>
                                (gotten from <methodname>openEvents</methodname>).
                                The eventis stored in <parameter>result</parameter>
                                The shape of the
                                <type>SpecTclDB::SaveSet::Event</type>
                                data type is described in
                                <literal>DATA TYPES</literal> below.
                               </para>
                               <para>
                                If there is another event in the result set,
                                the return value is nonzero.  If, however
                                there are no more events, the return value is zero.
                                If the return value is zero, the
                                contents of <parameter>result</parameter>
                                should not be considered to be reliable.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        Several public data types are defined.  When reading
                        the description below, all data type names should be
                        prefixed in code with
                        <literal>SpecTclDB::SaveSet::</literal> that is the
                        types are defined as local types within the
                        <classname>SpecTclDB::SaveSet</classname> class.
                    </para>
                    
                    <refsect2>
                        <title><type>Info</type></title>
                        <para>
                            The <type>Info</type> type is a structure
                            that caches information about the saveset retrieved
                            from the database.  It has the following fields:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term><type>int</type><structfield>s_id</structfield></term>
                               <listitem>
                                   <para>
                                    The save set's primary key in its top level
                                    table.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::string </type><structfield>s_name</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The name of the save set.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>time_t</type><structfield>s_stamp</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The time of day at which the save set was
                                    created.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                        <para>
                            Note that an appropriate set of copy constructors
                            and assignment operators have been defined to make
                            the struct copy and assignment safe.
                        </para>
                    </refsect2>
                    <refsect2>
                        <title><type>RunInfo</type></title>
                        <para>
                            This struct provides information about a run
                            that was saved in the database.  It as the
                            following fields:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int</type><structfield> s_runNumber</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The run number of the run.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::string </type><structfield>s_title</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The title string of the run.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>time_t</type><structfield>s_startTime</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The clock time at which the run started.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>time_t </type><structfield>s_stopTime</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The clock time at which the run ended.
                                    It is possible, if the run ended badl or wasn ot
                                    completely saved to the databas, that this
                                    field will be zero meaning that the end time
                                    of the run is not known.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </refsect2>
                    <refsect2>
                        <title><type>ScalerReadout</type></title>
                        <para>
                            This struct contains the information from a
                            scaler readout.  The struct contains not only the
                            scaler channel data but also the metadata
                            describing it.  Here are the fields in that
                            struct:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_sourceId</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    When data are event built, each source for the
                                    event builder has its own unique integer source id.
                                    Each data source may readout periodic
                                    scalers and the meaning of the scalers
                                    read from source to source vary.
                                   </para>
                                   <para>
                                    This field contains the source id of the
                                    data source that produced this readout.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_startOffset</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    This is a time offset into the run at which
                                    the period over which the scalers accumulated
                                    started. The units depend on
                                    <structfield>s_divisor</structfield>
                                    below.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_stopOffset</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The time offset into the run at which the
                                    period over which the scalers accumulated for
                                    this readout ended.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_divisor</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    If you do a floating point division of
                                    <structfield>s_startOffset</structfield>
                                    or <structfield>s_stopOffset</structfield>
                                    by this value you will get those times
                                    in units of seconds.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::vector&lt;int&gt; </type><structfield>s_values</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    This vector are the scaler values for
                                    this counting period.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </refsect2>
                    <refsect2>
                        <title><type>EventParameter</type> and <type>Event</type></title>
                        <para>
                            These two data types are closely related and
                            are used when returning a processed event from
                            the database.  <type>EventParameter</type>
                            is a struct that represents a single parameter:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int</type><structfield>s_number</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The number of the parameter represented by
                                    this struct. Note that this refers not
                                    to a primary key for a parameter but
                                    its number field.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>double</type><structfield>s_value</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The actual value of the parameter.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                        <para>
                            This representation of parameters assumes that,
                            in general, events are sparse.  Finally,
                            the <type>Event</type> is just a
                            <classname>std::vector&lt;EventParameter&gt;</classname>,
                            and represents an entire event extracted
                            from the database.                                
                        </para>

                    </refsect2>
                    <refsect2>
                        <title><type>SpectrumAxis</type></title>
                        <para>
                            This data type describes a single spectrum
                            axis and is used when creating spectra:
                        </para>
                        <variablelist>
                           <varlistentry>
                              <term>
                                <type>double </type><structfield>s_low</structfield>
                              </term>
                              <listitem>
                                <para>
                                    The axis low limit in parameter coordinates.    
                               </para>
                            </listitem>
                           </varlistentry>
                           <varlistentry>
                              <term>
                                <type>double </type><structfield>s_high</structfield>
                              </term>
                              <listitem>
                                <para>
                                    The axis high limit in parameter coordinates.
                               </para>
                            </listitem>
                           </varlistentry>
                           <varlistentry>
                              <term>
                                <type>int</type><structfield>s_bins</structfield>
                              </term>
                              <listitem>
                                <para>
                                    The number of bins on that axis.
                               </para>
                            </listitem>
                           </varlistentry>
                        </variablelist>
                        <para>
                            Note that axes are inclusive on the low side and
                            exclusive of the high end.  In SpecTcl it's perfectly
                            legal to have a reversed axis.  That is an axis
                            where <structfield>s_low</structfield> is
                            greater than <structfield>s_high</structfield>.
                        </para>
                    </refsect2>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>DBParameter</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>DBParameter</refname>
                  <refpurpose>Encapsulate database parameter definitions.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;DBParameter.h&gt;

namespace SpecTclDB {
    class SaveSet;
    
    class DBParameter {
    public:
        struct Info {
            int         s_id;
            int         s_savesetId;
            std::string s_name; 
            int         s_number;
            bool        s_haveMetadata;
            double      s_low;
            double      s_high;
            int         s_bins;
            std::string s_units;
        };
    public:
        static bool exists(CSqlite&amp; connection, int sid, const char* name);
        static bool exists(CSqlite&amp; connection, int sid, int id);
        
        static DBParameter* create(
            CSqlite&amp; connection, int sid, const char* name, int number
        );
        static DBParameter* create(
            CSqlite&amp; connection, int sid, const char* name, int number,
            double low, double high, int bins, const char* units
        );
        static DBParameter* get(CSqlite&amp; connection, int sid, int id);
        static std::vector&lt;DBParameter*&gt; list(CSqlite&amp; connection, int sid);
    public:
        DBParameter(CSqlite&amp; conn, int saveid, const char* name);
        DBParameter(CSqlite&amp; conn, int saveid, int number);

        const Info&amp; getInfo();
        

        
    };
}                      
                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                      <para>
                        <classname>SpecTclDB::DBParameter</classname>
                        encapsulates the data in the database for
                        a single parameter definition.  It also
                        provides services that are related to parameters.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <para>
                        Note that most methods described below require
                        that you have a database connection and the
                        primary key of a save set.  These methods are not
                        intended for general use but are used by
                        API methods for the parameter definitions in
                        <classname>SpecTclDB::SaveSet</classname> which
                        has these pieces of information available.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid </parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Determines if the parameter <parameter>name</parameter>
                                exists in the saveset with the
                                primary key <parameter>sid</parameter>
                                that is in the database with the connection
                                <parameter>conn</parameter>.
                                If the parameter exists, <literal>true</literal>
                                is returned, if not, <literal>false</literal>.
                                Note that if there are errors, they are signalled
                                by exceptions that are derived from
                                <classname>std::exception</classname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as the previous method but looks up the
                                parameter by its primary  key
                                <parameter>id</parameter>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBParameter* </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name </parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This method creates a new parameter definition
                                in the saveset with the primary key
                                <parameter>sid</parameter> in the
                                database <parameter>conn</parameter>.
                                The parameter is a primitive parameter that
                                only has a <parameter>name</parameter>
                                and <parameter>number</parameter>.
                               </para>
                               <para>
                                When the definition comes from SpecTcl, the
                                <parameter>number</parameter> is a slot in the
                                <classname>CEvent</classname> object where the unpacked
                                parameter will be stored.
                               </para>
                               <para>
                                The result is a pointer to a
                                new <classname>SpecTclDB::DBParameter</classname>
                                object that wraps the new definition.
                                The object is dynamically created so you
                                must delete it when your program no longer
                                needs it.
                               </para>
                               <para>
                                On errors like duplicate parameter name or
                                number or no such save set,
                                an <classname>std::invalid_argument</classname>
                                exception is thrown.  Other errors
                                result in exceptions that are derived from
                                <classname>std::exception</classname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBParameter* </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>CSqlite&amp;</type><parameter> connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type> int </type><parameter>number</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>low</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>high</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> bins</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>units</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Exactly like the previous method, however the
                                additional parameters supply the metadata
                                that is normally available in a tree parameter.
                                <parameter>low</parameter> is the
                                recommended axis low limit for axes that
                                defined on these parameters. <parameter>high</parameter>
                                is the recommended axis high limt for axes that are
                                defined on this parameter.
                                <parameter>bins</parameter>
                                is the recommended number of bins for axes
                                defined on this parameter using the
                                recommended limits.
                                <parameter>units</parameter> are the
                                units of measure of the parameter.
                                Note that for unitless parameters, by convention
                                an empty string is used.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBParameter* </type>
                               <methodname>get</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> id</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Fetchs the parameter definition
                                with the primary key
                                <parameter>id</parameter> from
                                the saveset with a primary key of
                                <parameter>sid</parameter> from
                                the database connected via
                                <parameter>connection</parameter>.
                               </para>
                               <para>
                                If found, the parameter definition is
                                wrapped in
                                <classname>SpecTclDB::DBParameter</classname> object
                                and a pointer to that object is returned.
                                The object is dynamically created, therefore
                                when the program no longer needs it it must
                                be deleted
                               </para>
                               <para>
                                If the parameter does not exist,
                                <classname>std::invalid_argument</classname>
                                is thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;DBParameter*&gt; </type>
                               <methodname>list</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Given a connection to a database
                                <parameter>connection</parameter> and the
                                primary key of a saveset,
                                <parameter>sid</parameter> lists all of the
                                parameter definitions that are in that saveset.
                                The result is a vector that contains pointers
                                to object wrappers for the data in the
                                database for each parameter.
                                These objects are dynamically generated and,
                                thereforem, must be deleted when no longer
                                needed by the program.
                               </para>
                               <para>
                                Any errors are reported as exceptions that are
                                derived from <classname>std::exception</classname>.
                                
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBParameter</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>conn</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>saveid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type><parameter>name</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Looks up the parameter definition for
                                <parameter>name</parameter> and constructs
                                a <parameter>SpecTclDB::DBParameter</parameter>
                                object to wrap it.  <parameter>connection</parameter>
                                represents the connection to the database
                                and <parameter>sid</parameter> is the
                                primary key of the saveset the parameter
                                is defined in.
                               </para>
                               <para>
                                If there is no parameter named
                                <parameter>name</parameter> in the
                                designated save set
                                <classname>SpecTclDB::invalid_argument</classname>
                                is thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBParameter</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>conn</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>saveid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>number</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This constructor locates the parameter definition
                                it wraps based on the parameter
                                <parameter>number</parameter>. The parameter
                                number is not the primary key of the parameter but
                                a number associated with the paramater name
                                when the definition is created. In the context of
                                SpecTcl, this number represents a slot in the
                                <classname>CEvent</classname> passed to
                                event processors into which the parameter will
                                be placed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                When a <classname>SpecTclDB::DParameter</classname>
                                is constructed, it fetches information about the
                                parameter from the database and caches it
                                internally in a
                                <type>SpecTclDB::DBParameter::Info</type>
                                struct.  This fetches a const reference to that
                                struct.
                               </para>
                               <para>
                                The members of the
                                <type>SpecTclDB::DBParameter::Info</type> are
                                described in <literal>DATA TYPES</literal>
                                below.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
        
                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        <classname>SpecTclDB::DBParameter</classname>
                        exports a single data type; <type>Info</type>
                        (fully qualified name <type>SpecTclDB::DBParameter::Info</type>).
                        This is a struct that is used to cache the database
                        definition of the parameter represented by instances
                        of <classname>SpecTclDB::DBParameter</classname>.
                    </para>
                    <para>
                        <type>Info</type> has the following fields:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_id</structfield>
                           </term>
                           <listitem>
                               <para>
                                The primary key of the database entry for
                                this parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_savesetId</structfield>
                           </term>
                           <listitem>
                               <para>
                                A foreign key to the saveset that owns
                                the parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>std::string </type><structfield>s_name</structfield>
                           </term>
                           <listitem>
                               <para>
                                The name of the parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_number</structfield>
                           </term>
                           <listitem>
                               <para>
                                A number associated with the parameter.
                                For SpecTcl, this is the slot of the
                                <classname>CEvent</classname> passed to
                                event processors into which the parameter
                                value for an event will be placed.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>bool</type><structfield>s_haveMetadata</structfield>
                           </term>
                           <listitem>
                               <para>
                                Parameters in SpecTcl come in two flavors.
                                Raw parameters only have a number, the
                                index into <classname>CEvent</classname>
                                objects into which they get unpacked.
                                <firstterm>Tree parameters</firstterm>
                                also have metadata about the parameter.
                                This metadata, provides additional information
                                about the parameter.
                               </para>
                               <para>
                                If metadata is supplied for the parameter,
                                this flag will be <literal>true</literal>.
                                If not, this flag will be <literal>false</literal>.
                                The subsequent fields in
                                <type>Info</type> will only have valid values
                                if <structfield>s_haveMetadata</structfield>
                                is <literal>true</literal>.  If not those
                                fields should be ignored.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double </type><structfield>s_low</structfield>
                           </term>
                           <listitem>
                               <para>
                                Metadata.  This is the lowest value expected
                                to be valid for the parameter.  It is a suggested
                                low limit of histogram axes that represent this
                                parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double</type><structfield>s_high</structfield>
                           </term>
                           <listitem>
                               <para>
                                Metadata.  This is the largest value expected to be
                                valid for this parameter.  It is a suggested
                                upper limit of histogram axes that
                                represent this parameter.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_bins</structfield>
                           </term>
                           <listitem>
                               <para>
                                Metadata.  This value says something about
                                the resolution with which the parameter is
                                represented. It recommends that if you
                                follow the axis limit suggestions provided
                                you parcel that axis out into
                                <structfield>s_bins</structfield> bins.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>std::string </type><structfield>s_units</structfield>
                           </term>
                           <listitem>
                               <para>
                                Metadata: This provides units of measure for the
                                parameter.  This and the
                                <structfield>s_name</structfield> field can
                                be used to derive axis labels for the parameter.
                                By convention, unitless parameters have
                                an empty string for this field.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>DBSpectrum</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>DBSpectrum</refname>
                  <refpurpose>Encapsulate Spectrum definitions.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
namespace SpecTclDB {
    class DBSpectrum {
    public:
        
        struct ChannelSpec {
            int  s_x;
            int  s_y;
            int  s_value;
        };
        
        struct BaseInfo {
            int         s_id;       
            int         s_saveset;  
            std::string s_name;
            std::string s_type;
            std::string s_dataType;
        };
        typedef std::vector&lt;int&gt; Parameters;
        struct Axis {
            int      s_id;
            double   s_low;
            double   s_high;
            int      s_bins;   
        };
        typedef std::vector&lt;Axis&gt; Axes;
        
        struct Info {
            BaseInfo   s_base;
            Parameters s_parameters;
            Axes       s_axes;
        };
        public:
            static bool exists(CSqlite&amp; connection, int sid, const char* name);
            static DBSpectrum* create(
                CSqlite&amp; connection, int sid, const char* name, const char* type,
                const std::vector&lt;const char*&gt;&amp; parameterNames,
                const Axes&amp; axes,
                const char* datatype="long"
            );
            static std::vector&lt;DBSpectrum*&gt; list(CSqlite&amp; connection, int sid);

        public:
            DBSpectrum(CSqlite&amp; connection, int sid, const char* name);

            const Info&amp; getInfo() const;
            std::vector&lt;std::string&gt; getParameterNames();
            void storeValues(const std::vector&lt;ChannelSpec&gt;&amp; data);
            std::vector&lt;ChannelSpec&gt;  getValues();
            bool hasStoredChannels();
        
        

    };
}                                         // namespace SpecTclDB.

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                      <classname>SpecTclDB::DBSpectrum</classname>
                      encapsulates spectrum definitions in a database.
                      It contains data cached from the database that
                      describes the spectrum, and provides services
                      for clients.  Note that the intended client for
                      most of these services is
                      <classname>SpecTclDB::SaveSet</classname>.
                    </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <para>
                        Most of these methods are not intended for
                        general public use but are exported for
                        <classname>SpecTclDB::SaveSet</classname>.
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp;</type><parameter> connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Checks for the existence of a spectrum
                                definition in a saveset
                                by <parameter>name</parameter>.
                                <parameter>connection</parameter> is the
                                connection to the database, and
                                <parameter>sid</parameter> is the primary
                                key of the save set.
                               </para>
                               <para>
                                If the saveset designated by
                                <parameter>sid</parameter> has a spectrum
                                defined named <parameter>name</parameter>,
                                the method returns <literal>true</literal>.
                                If not <literal>false</literal> is returned.
                                Errors will throw exceptions that are subclasses
                                of <classname>std::exception</classname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBSpectrum* </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const std::vector&lt;const char*&gt;&amp; </type><parameter>parameterNames</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const Axes&amp; </type><parameter>axes</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>datatype</parameter>
                                <initializer>"long"</initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a new spectrum definition in the
                                save set with the primary key <parameter>sid</parameter>
                                in the database connected via
                                <parameter>connection</parameter>.
                                The spectrum will be named <parameter>name</parameter>
                                and have a type given by <parameter>type</parameter>.
                               </para>
                               <para>
                                Each spectrum requires a set of
                                <parameter>parameterNames</parameter>
                                that specify the parameters that the spectrum
                                uses to compute how or if it is incremented for
                                each event. The parameter names must correspond
                                to parameter definitions that are already
                                in the saveset.  Each spectrum type will
                                require a specific number of parameter defintions.
                                See the SpecTcl user guide and command reference
                                for more.
                               </para>
                               <para>
                                Spectra have either one or two axis specifications.
                                These are passed in as <parameter>axes</parameter>.
                                The data type
                                <type>SpecTclDB::DBSpectrum::Axes</type>
                                used to pass these is described in
                                <literal>DATA TYPES</literal> below.
                               </para>
                               <para>
                                Bins in a spectrum have a data type. By default
                                this type is <literal>long</literal>.
                                If you supply a data type it must be one of
                                <literal>long</literal>; 32 bit bins,
                                <literal>word</literal>; 16 bit bins or
                                <literal>byte</literal>; 8 bit bins.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;DBSpectrum*&gt; </type>
                               <methodname>list</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>connection</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>sid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Lists the spectrum definitions in the
                                saveset indicated by the primary key
                                <parameter>sid</parameter> in the
                                database connected to <parameter>connection</parameter>.
                                The result is a vector of
                                pointers to
                                <classname>SpecTclDB::DBSpectrum</classname>
                                objects.  Those objects wrap all of the
                                spectrum definitions in the saveset.
                                The objects are dynamically created.
                                When the program no longer needs them it
                                should pass the pointers to delete.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBSpectrum</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>connection</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>sid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type><parameter>name</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Looks up the spectrum <parameter>name</parameter>
                                in the saveset <parameter>sid</parameter>
                                in the database <parameter>connection</parameter>.
                                Construction wraps the object arond the
                                spectrum if found.  If not found a
                                <classname>std::invalid_argument</classname>
                                exception is thrown. 
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Database information about the spectrum
                                is cached in an
                                <type>SpecTclDB::DBSpectrum::Info</type>
                                struct.  This returns a const reference to that
                                struct.  Note that the shape of this structure
                                is documented in
                                <parameter>DATA TYPES</parameter> below.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;std::string&gt; </type>
                               <methodname>getParameterNames</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the names of the parameters the spectrum
                                depends on.  The spectrum's parameter dependencies
                                are stored as foreign keys into the table
                                that defines the parameter.  This convenience
                                function converts those parameter ids into
                                their names and returns them.  The vector
                                order will be the same as that used when
                                defining the spectrum (parameter order is important).
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>hasStoredChannels</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                In addition to spectrum definitions, channel
                                data (the contents of a spectrum) can
                                be stored in a saveset. This method]
                                returns <literal>true</literal> if the
                                spectrum represented by this object has
                                channel data stored.  If not,
                                <literal>false</literal> is returned instead.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>void </type>
                               <methodname>storeValues</methodname>
                               <methodparam>
                                   <type>const std::vector&lt;ChannelSpec&gt;&amp; </type><parameter>data</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Stores channel data for a spectrum. Note that
                                any previously stored channel data are replaced.
                                Thus multiple calls are not cumulative.
                                The <type>SpecTclDB::DBSpectrum::ChannelSpec</type>
                                datatype used to describe the contents of a channel
                                is described in <literal>DATA TYPES</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;ChannelSpec&gt;  </type>
                               <methodname>getValues</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns any channel data stored for this
                                spectrum.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
            
                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        <classname>SpecTclDB::DBSpectrum</classname>
                        exports several data types.
                    </para>
                    <refsect2>
                        <title><type>SpecTclDB::DBSpectrum::ChannelSpec</type></title>
                        <para>
                            This type is used to describe channel values.
                            The assumption is that for the biggest spectra (large 2-d)
                            data are sparse.  Therefore, only non-zero channels
                            need to be stored.  Each non zero channel
                            is described by a
                            <type>SpecTclDB::DBSpectrum::ChannelSpec</type> struct
                            which has the following fields:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_x</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    X channel coordinate of the data. This is always
                                    present
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type> int </type><structfield> s_y</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Y channel  coordinate of the data. This is
                                    only used for 2d spectra.  It is ignored
                                    for 1-d spectra.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int  </type><structfield>s_value</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    The value in the channel. Usually, this is nonzero.
                                    Note that
                                    A program  may try to save a spectrum that is
                                    empty. If that is the case, in order to ensure there
                                    is detectable channel data, it is
                                    useful to store a single channel
                                    (does not matter which) with no counts
                                    in it.  In that case,
                                    <structfield>s_value</structfield>
                                    <emphasis>can</emphasis> be zero.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </refsect2>
                    <refsect2>
                        <title><type>SpecTclDB::DBSpectrum::Axis</type></title>
                        <para>
                            The <type>Axis</type> data type is a struct that
                            defines a spectrum axis.  A vector of
                            <type>Axis</type> is the datatype
                            <type>Axes</type>.  The fields of an
                            <type>Axis</type> struct are as follows:
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int</type><structfield>s_id</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    This field is ignored when an Axis
                                    is used to create a spectrum. When it is
                                    part of the cached data
                                    (see <type>SpecTclDB::DBSpectrum::Info</type> below),
                                    it contains the primary key of the axis
                                    in the table of axes.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>double</type><structfield>s_low</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Contains the lowest value on the axis.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>double</type><structfield>s_high</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Contains the highest value on the axis.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int  </type><structfield>s_bins</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Contains the number of bins into which
                                    the axis is subdivided.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </refsect2>
                    <refsect2>
                        <title><type>SpecTclDB::DBSpectrum::Info</type></title>
                        <para>
                            The <type>SpecTclDB::DBSpectrum::Info</type>
                            contains data that is cached from the database
                            when a <classname>SpecTclDB::DBSpectrum</classname>
                            is wrapped around a spectrum definition.
                            It is a struct that consists of three elements:
                        </para>
                        <variablelist>
                                <varlistentry>
                                   <term>
                                    <type>BaseInfo </type><structfield>s_base</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Contains information that identifies the
                                        spectrum and its type. See below
                                        for a description of it.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>Parameters </type><structfield>s_parameters</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Contains the ordered vector of parameters
                                        this spectrum depends on.  The
                                        <type>SpecTclDB::DBSpectrum::Parameters</type>
                                        data type is just a vector of integers.
                                        The vector contents are the primary keys of
                                        entries in the parameters table.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>Axes</type><structfield>s_axes</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Contains the ordered descriptions of all
                                        of the free axes of the spectrum.
                                        See above for a description of the
                                        <type>SpecTclDB::DBSpectrum::Axes</type>
                                        data types.
                                       </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        
                        <para>
                            Where the <type>SpecTclDB::DBSpectrum::BaseInfo</type>
                            type is a struct that provides basic identification
                            of the spectrum.
                            <type>SpecTclDB::DBSpectrum::BaseInfo</type> has
                            the follwing fields:    
                        </para>
                        <variablelist>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_id</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Spectrum definitions are spread over several
                                    tables.   One table, however is the
                                    root of all spectrum tables. This field
                                    is the primary key of the spectrum definition
                                    from this table.
                                   </para>
                                   <para>
                                    See the <link linkend='app.schema' endterm='app.schema' />
                                    for more information about how the database
                                    tables are structured.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>int </type><structfield>s_saveset</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Each spectrum definition belongs to a save set.
                                    This member is the primary key of the saveset
                                    this spectrum definition belongs to.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::string </type><structfield>s_name;</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Contains the name of the spectrum.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::string </type><structfield>s_type</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    Contains the spectrum type string. You might
                                    expect this to be a key that's used to
                                    lookup the actual type in a secondary table.
                                    That would constrain spectrum types and make
                                    it harder to adapt the database to other,
                                    non-SpecTcl applications.  Therefore
                                    this field is free text.
                                   </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                               <term>
                                <type>std::string</type><structfield> s_dataType</structfield>
                               </term>
                               <listitem>
                                   <para>
                                    This string contains the channel data type
                                    specification. It too is a free text field
                                    to allow for expansion outside of
                                    SpecTcl.
                                   </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </refsect2>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>DBGate</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>DBGate</refname>
                  <refpurpose>Encapsulate database gate definitions</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;DBGate.h&gt;

namespace SpecTclDB {
   
/**
 * @class DBGate
 *   This class encapsulates a gate.  Note that gates are pretty
 *   complicated things.  There is a type dependency that determines
 *   the sorts of dependent things their root table entry (gate_defs)
 *   has linked to it.  Primarily there are three type of gates:
 *   - Gates that have associated points.
 *   - Gates that have associated gates.
 *   - Gates that are masks and have an associated mask.
 * @note the c2band gate is not directly stored in the database.  Instead
 *       the equivalent contour is stored.  An attempt to store a c2band
 *       will result in an error.
 *
 *    Let's look at the dependent data for each of these types of gates:
 *
 *    - Gates with associated points have parameters, and points.  These
 *      are in  the table (gate_paramters and gate_points).
 *    - Gates with associated gates have only gates in the component_gates
 *      table. Note that since gate ids are stored in that table,
 *      we only allow a compound gate to be stored if its component gates have
 *      been stored.  This requires the client code to do gate dependency
 *      analysis.
 *    - mask gates have a parameter (gate_parameters) and a mask (gate_masks).
 *
 *    To make all of this easier, we'll be providing different creationals
 *    for each of these classifications of gate types.
 *
 */
class DBGate {
    
    public:
        typedef std::vector&lt;const char*&gt; NameList;
        typedef std::vector&lt;int&gt;         IdList;
        
        typedef enum _BasicGateType {point, compound, mask}
            BasicGateType; 
        
        struct BaseInfo {
            int           s_id;                   // Id in gate_defs table.
            int           s_saveset;              // id of saveset.
            std::string   s_name;                 // gate name.
            std::string   s_type;                 // detailed gate type.
            BasicGateType s_basictype;            // what to expect.
            
        };
        
        struct Point {
            double    s_x;
            double    s_y;
        };
        typedef std::vector&lt;Point&gt; Points;
        
        struct Info {
            BaseInfo       s_info;
            IdList         s_parameters;
            IdList         s_gates;
            Points         s_points;
            int            s_mask;
        };
        public:
            static bool exists(CSqlite&amp; conn, int saveid, const char* name);
            static DBGate* create1dGate(
                CSqlite&amp; conn, int saveid,
                const char* name, const char* type,
                const NameList&amp; params, double low, double high
            );
            static DBGate* create2dGate(
                CSqlite&amp; conn, int saveid,
                const char* name, const char* type,
                const NameList&amp; params, const Points&amp; points
            );
            static DBGate* createCompoundGate(
                CSqlite&amp; conn, int saveid,
                const char* name, const char* type,
                const NameList&amp; gates
            );
            static DBGate* createMaskGate(
                CSqlite&amp; conn, int saveid,
                const char* name, const char* type,
                const char* pName, int imask
            );
            static std::vector&lt;DBGate*&gt; listGates(CSqlite&amp; conn, int saveid);

        public:
            DBGate(CSqlite&amp; conn, int saveid, const char* name);
            DBGate(CSqlite&amp; conn, int id);
        

        
            const Info&amp; getInfo() const;
            std::vector&lt;std::string&gt; getParameters();
            std::vector&lt;std::string&gt; getGates();
            Points   getPoints();
            int      getMask();
                        
};      
}     


                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                        The <classname>SpecTclDB::DBGate</classname>
                        class encapsulates gate definitions.  A gate
                        is a condition that, when applied to a spectrum
                        must be true on an event by event basis to allow
                        that spectrum to be incremented. 
                    </para>
                    <para>
                        The richness in the types of gates supported by
                        SpecTcl, makes the data in this class the most complex
                        of all objects that are stored in the database.
                        This is reflected by the fact that fully five tables
                        in the database are used to hold information
                        that defines gates.
                    </para>
                    <para>
                        Gates come in three overall types:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term><literal>Point gates</literal></term>
                           <listitem>
                               <para>
                                A point gate is a gate that defines a region of
                                acceptance in parameter space.  Simplistically,
                                if an event falls inside this acceptance region
                                the gate is true. 
                               </para>
                               <para>
                                Point gates further break down into one dimensional
                                and two dimensional gates depending on the
                                dimensionality of the acceptance region.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>Mask gates</literal></term>
                           <listitem>
                               <para>
                                Mask gates are defined on a single parameter.
                                The parameter is treated as an integer and a
                                specific bitwise operation is performed
                                on that parameter with a constant bitmask.
                                The results of that operation are used to deermine
                                the truth or falsity of a gate.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>Compound gates</literal></term>
                           <listitem>
                               <para>
                                A compound gate accepts a list of
                                dependent gates and performs some logical
                                operation on them to determine its truth or
                                falisty.  For example, a not gate has a single dependent
                                gate and is true for events where that gate is false.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        For more information on gate types and how they are
                        evaluated, see the SpecTcl user manual and
                        command reference.
                    </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <para>
                        Manyof the methods in
                        <classname>SpecTclDB::DBGate</classname> that are public
                        are intended to be called by
                        <classname>SpecTclDB::SaveSet</classname>.
                        These methods can be distinguished from methods
                        intended for general public use because they have
                        <classname>CSqlite</classname> parameters identifying
                        the database, and a save set primary key parameter
                        identifying the saveset.
                    </para>
                    <para>
                        If you see methods like these and want the functionality
                        they provide, see the methods in
                        <classname>SpecTclDB::SaveSet</classname> that
                        offer the same functionality and use them instead.
                    </para>
                    <para>
                        The public methods of the class are:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp;</type><parameter> conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns  <literal>true</literal> if a gate
                                named <parameter>name</parameter> is defined
                                in the saveset with the primary key
                                <parameter>sid</parameter> and with the connection
                                to a database 
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBGate* </type>
                               <methodname>create1dGate</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter> type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const NameList&amp; </type><parameter>params</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>low</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double </type><parameter>high</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis> 
                           </term>
                           <listitem>
                               <para>
                                This method creates a 1-d poing gates.
                                1-d point gates are defined on a set of parameters
                                and specify a slice of parameter space.
                                The reason that more than one parameter might be
                                needed has to do with SpecTcl's
                                gamma slice gate.
                               </para>
                               <para>
                                <parameter>name</parameter> will be the
                                name of the gate definition that will be created,
                                <parameter>type</parameter> the gate type
                                code (which, to support expansion from SpecTcl
                                applications is jut a free text value).
                                <parameter>params</parameter> is a vector
                                of parameter names the gate needs to operate.
                                For e.g. slice gates, this is the single
                                parameter the gate is checked on.
                                <parameter>low</parameter> and <parameter>high</parameter>
                                define the acceptance region.
                               </para>
                               <para>
                                In addition to these parameters, which specify
                                the gate characteristics,
                                <parameter>saveid</parameter> specifies the
                                primary key of the save set this gate definition
                                will belong to. <parameter>conn</parameter>
                                is the database connection that implies
                                the Sqlite3 database file the save set, in turn
                                lives in.
                               </para>
                               <para>
                                After createing the gate definition in the database,
                                it is wrapped in a <classname>DBGate</classname>
                                object and a pointer to that object returned to the caller.
                                Note that this object is dynamically created and
                                therefore must be deleted when the caller
                                no longer needs it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBGate* </type>
                               <methodname>create2dGate</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type> int</type><parameter> saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type> const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const NameList&amp; params</type><parameter></parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const Points&amp; </type><parameter>points</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                This method creates a gate definition for a 2-d
                                point gate.  The only difference between it
                                and <methodname>create1dGate</methodname>
                                is that the acceptance region is a 2-d shape
                                that is defined both by <parameter>points</parameter>
                                and the gate type's interpretation of those points
                                (for example, a band interprets those points differently
                                than a contour).
                               </para>
                               <para>
                                After createing the gate definition in the database,
                                it is wrapped in a <classname>DBGate</classname>
                                object and a pointer to that object returned to the caller.
                                Note that this object is dynamically created and
                                therefore must be deleted when the caller
                                no longer needs it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBGate* </type>
                               <methodname>createCompoundGate</methodname>
                               <methodparam>
                                   <type>CSqlite&amp;</type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const NameList&amp; </type><parameter>gates</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a compound gate.  The
                                <parameter>name</parameter> and
                                <parameter>type</parameter> parameters,
                                as usual specify the name and type of gate.
                                <parameter>gates</parameter> specify the
                                names of gates the gate depends on.
                                <parameter>gates</parameter> contain the names of gates
                                already defined in the save set.  This implies
                                that saving gates requires some dependency
                                analysis on the part of the caller.
                               </para>
                               <para>
                                As with other creation methods;
                                <parameter>saveid</parameter> specifies the
                                primary key of the save set this gate definition
                                will belong to. <parameter>conn</parameter>
                                is the database connection that implies
                                the Sqlite3 database file the save set, in turn
                                lives in.
                               </para>
                               <para>
                                After createing the gate definition in the database,
                                it is wrapped in a <classname>DBGate</classname>
                                object and a pointer to that object returned to the caller.
                                Note that this object is dynamically created and
                                therefore must be deleted when the caller
                                no longer needs it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBGate* </type>
                               <methodname>createMaskGate</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int</type><parameter> saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter> name</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>type</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>pName</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>imask</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Create a definition for a mask gate.
                                The gate is described by the parameter
                                name, <parameter>pName</parameter> and
                                <parameter>mask</parameter>. Its name is
                                <parameter>name</parameter> and
                                type <parameter>imask</parameter>
                               </para>
                               <para>
                                As before,
                                <parameter>saveid</parameter> specifies the
                                primary key of the save set this gate definition
                                will belong to. <parameter>conn</parameter>
                                is the database connection that implies
                                the Sqlite3 database file the save set, in turn
                                lives in.
                               </para>
                               <para>
                                After createing the gate definition in the database,
                                it is wrapped in a <classname>DBGate</classname>
                                object and a pointer to that object returned to the caller.
                                Note that this object is dynamically created and
                                therefore must be deleted when the caller
                                no longer needs it.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;DBGate*&gt; </type>
                               <methodname>listGates</methodname>
                               <methodparam>
                                   <type>CSqlite&amp;</type><parameter> conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Lists the gates in the save set with the primary key
                                <parameter>saveid</parameter> in the
                                database connected with <parameter>conn</parameter>.
                                The gate information is returned as a vector
                                of pointers to
                                <classname>SpecTclDB::DBGate</classname> objects
                                that are dynamically constructed.  Each object
                                wraps one of the gates in the save set.
                                Once the program no longer needs those pointers
                                they should be deleted.
                               </para>
                               <para>
                                Recall that gates must be defined such that
                                dependent gates are defined prior to a gate itself.
                                This implies that the program has performed a
                                dependency analysis when defining the gates.
                                The order of the gates in the vector
                                will be the same as the order in which the
                                gates were defined in the database. Therefore,
                                on restoration, it is not necessary for the
                                program to do dependency analysis again.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                                <constructorsynopsis>
                                    <methodname>DBGate</methodname>
                                    <methodparam>
                                        <type>CSqlite&amp; </type><parameter>conn</parameter>
                                        <initializer></initializer>
                                    </methodparam>
                                    <methodparam>
                                        <type>int </type><parameter>saveid</parameter>
                                        <initializer></initializer>
                                    </methodparam>
                                    <methodparam>
                                        <type>const char*</type><parameter> name</parameter>
                                        <initializer></initializer>
                                    </methodparam>
                                </constructorsynopsis>
                               
                           </term>
                           <listitem>
                               <para>
                                Construction involves looking up the gate defintions
                                for <parameter>name</parameter> in the
                                save set with the primary key
                                <parameter>saveid</parameter>.  If found,
                                the constructed object wraps the data for
                                that gate caching it locally.  If not,
                                <classname>std::invalid_argument</classname>
                                is thrown.
                               </para>
                               <para>
                                <parameter>conn</parameter> represents the
                                database in which the lookup and retrieval are
                                done.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBGate</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; conn</type><parameter></parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>id</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as the previous constructor except the
                                gate is specified by its primary key.
                                Since the primary key is unique for all gates
                                in the database, it is not necessary to
                                specify a saveset.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Cached data describing the gate is stored
                                internal to the object.  This method obtains
                                a const reference to the data structure that
                                contains that data.  See the
                                <literal>DATA TYPES</literal> section for more information
                                about the <type>Info</type> data structure.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;std::string&gt; </type>
                               <methodname>getParameters</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Parameters a gate depends on are stored
                                as foreign keys (the value of the primary key
                                of the paramter in the parameter table).
                                This method returns a vector of the names of the
                                parameters the gate depends on.   Note
                                that since, for some gates, order is important,
                                the vector preserves the order in which the
                                parametes were passsed to the original
                                gate creation method.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::vector&lt;std::string&gt; </type>
                               <methodname>getGates</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Compound gates store their dependent gates as
                                the primary keys of those gates in the top level
                                table describing gates.  This method converts
                                those keys into names and returns a vector
                                of the gate names.
                               </para>
                               <para>
                                While gate order is not imporant to the results of
                                compound gates, the use of short circuit evaluation
                                in <literal>+</literal> and <literal>*</literal>
                                gates can mean the order affects the performance
                                of the evaluation of those gates
                                (for a + gate the most commonly true gate
                                should be first while for a * gate the most
                                commonly false gate).  Therefore the
                                gates are ordered in the order in which they
                                were passed to the gate creation operation.
                                This preserves any attempt by the gate definer
                                to optimize performance.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>Points  </type>
                               <methodname> getPoints</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the points associated with a point
                                gate.  These are returned in the order in which
                                they were presented at definition time.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>int</type>
                               <methodname>getMask</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the mask value for a mask gate.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    
                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        The <classname>SpecTclDB::DBGate</classname>
                        exports several data types.  These will be
                        described in this section.  Most, but not all
                        of them build to form components of the
                        <type>Info</type> struct which contains
                        cached data fetched from the database for
                        this gate.  We will define these types from most
                        to least primitive.
                    </para>
                    <formalpara>
                        <title>Vector types</title>
                        <para>
                             Two types are just typedef'ed vectors:
                             <type>NameList</type> is a vector of
                             <type>const char*</type> it is used to
                             store things like parameter names or
                             other simple string entities when building
                             a gate.  The second, <type>IdList</type>
                             is a vector of <type>int</type>. It's used to
                             store collections of foreign or primary keys.
                            <type>IdList</type> is mainly used internally.
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>BasicGateType</title>
                        <para>
                            The data a gate contains depends on a broad
                            clasification of its type.  The
                            <type>BasicGateType</type> is an enumeration
                            that provides symbolic meaning to those
                            classification.  A <type>BasicGateType</type>
                            value or variable can be one of (note to get a
                            fully scoped value, prepend the items below with
                            SpecTclDB::DBGate::) :
                            <variablelist>
                                <varlistentry>
                                   <term><literal>point</literal></term>
                                   <listitem>
                                       <para>
                                        This classification of gate has parameters and
                                        points.  The points describe an acceptance
                                        region in either 1 or 2-d space.
                                        Events that fall into that region, in general
                                        make the gate true.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>compound</literal></term>
                                   <listitem>
                                       <para>
                                        This classification of gate has <firstterm>dependent gates</firstterm>.
                                        The truth or falsity of the gate are determined
                                        by applying a boolean functionto the
                                        dependent gates.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term><literal>mask</literal></term>
                                   <listitem>
                                       <para>
                                        This classification of a gate has a single
                                        parameter and a mask.
                                       </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </para>
                    </formalpara>
                    <formalpara>
                        <title>BaseInfo</title>
                        <para>
                            This struct is part of the <type>Info</type>
                            struct.  It provides basic information
                            about the gate and enough additional information
                            for software to know what fields of the
                            <type>Info</type> struct to expect to
                            have data.  It has the following members:
                            <variablelist>
                                <varlistentry>
                                   <term>
                                    <type>int</type><structfield> s_id</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        The primary key of the gate in the top
                                        level gate table.  The top level
                                        table basically has the information
                                        in the <type>BaseInfo</type>
                                        struct.  All other data about a gate
                                        live in other tables with a foreign
                                        key back to the top level table.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>int</type><structfield>s_saveset</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Contains a foreign key that identifies the
                                        save set this gate definition belongs to.
                                        By foreign key, we mean that this value is
                                        the primary key of a record in the
                                        save sets table.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>std::string</type><structfield>s_name</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        The name of the gate.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>BasicGateType </type><structfield>s_basictype</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Provides the broad classification of
                                        gate for this gate.  As described in the
                                        documentation for this type, above, the value
                                        of this type tells your software which
                                        parts of the <type>Info</type> struct
                                        have useful data.  It tells the software
                                        in this library which dependent tables
                                        have data for this gate when filling in
                                        the <type>Info</type> struct.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>std::string   </type><structfield>s_type</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        The detailed gate type string.  This is the
                                        SpecTcl gate type string.
                                       </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </para>
                    </formalpara>
                    <formalpara>
                        <title><type>Point</type> and <type>Points</type></title>
                        <para>
                            Point gates require two or more points in one or
                            two dimensional space to specify a region of acceptance.
                            The <type>Point</type> struct represents a single point
                            with two doubles: <structfield>s_x</structfield>,
                            the x coordinate and <structfield>s_y</structfield>
                            the y coordinate of each point (not meaningful for
                            a one dimensional acceptance region).
                            <type>Points</type> is just a vector of points.
                        </para>
                    </formalpara>
                    <formalpara>
                        <title><type>Info</type></title>
                        <para>
                            This type contains all of the information
                            fetched from the database that describes
                            a single gate.  It has several fields. Which
                            fields are actually used, depends on the
                            gate classification.
                            <variablelist>
                                <varlistentry>
                                   <term>
                                    <type>BaseInfo</type><structfield>s_info</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        The base information described
                                        above.  The
                                        <structfield>s_basictype</structfield>
                                        field tells software which other
                                        fields of this struct are
                                        useful.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>IdList</type><structfield>s_parameters</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Used by point and mask gates, this field
                                        contains foreign keys for the
                                        parameter definitions for the parametes used
                                        by this gate.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>IdList</type><structfield>s_gates</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Used by compound gates, this field contains
                                        foreign keys for all gates this gate
                                        depends on.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>Points </type><structfield>s_points</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Used only by point gates.  This field contains
                                        the points that describe the gate's region of
                                        acceptance.
                                       </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                   <term>
                                    <type>int </type><structfield>s_mask</structfield>
                                   </term>
                                   <listitem>
                                       <para>
                                        Used only by mask gates.  Contains
                                        the mask value.
                                       </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </para>
                    </formalpara>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>DBApplication</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>DBApplication</refname>
                  <refpurpose>Wrap database definitions of gate applications</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;DBApplications.h&gt;

namespace SpecTclDB {
    
/**
 * @class DBApplication
 *    Gates by themselves are simply conditions that return a boolean
 *    for each event.  They are only useful when they are used to conditionalize
 *    something.  In SpecTcl, that something, is normally the incrementing
 *    of a spectrum.  Each SpecTcl spectrum has exactly one gate that is
 *    conditionlizes its increments. That gate is said to be "applied" to that
 *    spectrum.  Spectra in SpecTcl come into being with a predefined "T"
 *    gate applied to them.  The SpecTcl database gate_applications table
 *    keeps track of any gates other than the pre-defined T gate that are
 *    applied to spectra.  It's not much more than a JOIN table between the
 *    spectrum_defs and gate_defs tables.
 */
class DBApplication {
public:
    struct Info {
        int s_id;
        int s_gateid;
        int s_spectrumid;
    };
public:
    static DBApplication* applyGate(
        CSqlite&amp; conn, int saveid, const char* gate, const char* spectrum
    );
    static std::vector&lt;DBApplication*&gt; listApplications(
        CSqlite&amp; conn, int saveid
    );
    

public:
    // constructors

    DBApplication(
        CSqlite&amp; conn, int saveid,
        const char* gateName, const char* spectrumName
    );    
    
    
public:
    const Info&amp; getInfo() const;
    std::string getGateName();
    std::string getSpectrumName();

    
};
}                         // SpecTclDB namespace.

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                    <para>
                      Gates define conditions that are evaluated on
                      paramters or other gates.  A gate does something useful
                      when it is applied to a spectrum.  All spectra in
                      SpecTcl have a gate applied.  The spectrum is only
                      checked to see if it can be incremented if the gate
                      applied to it is true for the event.  Note that when
                      first created, a spectrum has a <literal>True</literal>
                      gate applied to it.
                    </para>
                    <para>
                        <classname>SpecTclDB::DBApplication</classname>
                        captures this fact.  It allows you to create
                        a record of gate applications in a saveset in a database.
                        It also allows you to wrap an existing gate application
                        stored in a savset with a
                        <classname>SpecTclDB::DBApplication</classname> object.
                    </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBApplication* </type>
                               <methodname>applyGate</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; conn</type><parameter></parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>gate</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char*</type><parameter> spectrum</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Creates a gate application definition in
                                the database indicated by <parameter>conn</parameter>
                                in the saveset <parameter>saveid</parameter>.
                                The gate named <parameter>gate</parameter> is
                                entered as applied to the spectrum
                                named <parameter>spectrum</parameter>.
                               </para>
                               <para>
                                The method returns the application
                                definition wrapped in a
                                <classname>SpecTclDB::DBApplication</classname>
                                object.  The object is dynamically created and a
                                pointer to it is returned.  When the application
                                no longer needs this object, it must be
                                deleted.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;DBApplication*&gt; </type>
                               <methodname>listApplications</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Lists the applied gates stored in the
                                save set <parameter>saveid</parameter>
                                from the database connected to <parameter>conn</parameter>.
                                The list is a vector containing pointers
                                to applications wrapped in
                                <classname>SpecTclDB::DBApplication</classname>
                                objects.  The objects are dynamically
                                created and therefore must be deleted when
                                the application no longer needs them.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBApplication</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>conn</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>saveid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char*     </type><parameter>gateName</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char* </type><parameter>spectrumName</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Locates the application definition that
                                applies the gate <parameter>gateName</parameter>
                                to the spectrum <parameter>spectrumName</parameter>
                                in the saves set <parameter>svaeid</parameter>
                                in the database connected to <parameter>conn</parameter>.
                                If the sought after application does not exist,
                                <classname>std::invalid_argument</classname>
                                will be thrown.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void /><modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns a const reference to the
                                data that has been cached from the database that
                                describes this gate application.
                                See <literal>DATA TYPES</literal> below
                                for a description of that structure.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::string </type>
                               <methodname>getGateName</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The name of the gate is stored in the database
                                and the <type>Info</type> struct as a
                                foreign key to the gate top level table.
                                This returns the name of the gate that's
                                applied.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::string </type>
                               <methodname>getSpectrumName</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                The spectrum to which the gate is applied
                                is stored as a foreign key to the top level
                                spectrum table.  This method returns
                                the name of that spectrum.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        The <classname>SpecTclDB::DBApplication</classname>
                        class exports a single data type;
                        <type>SpecTclDB::DBApplication::Info</type>.
                        This struct caches the information about this
                        application definition as it is stored in the
                        database. It contains the following fields:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_id</structfield>
                           </term>
                           <listitem>
                               <para>
                                The primary key of this entry in the
                                applications table.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_gateid</structfield>
                           </term>
                           <listitem>
                               <para>
                                A foreign key to the gate being applied in the
                                top level gate table.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int </type><structfield>s_spectrumid</structfield>
                           </term>
                           <listitem>
                               <para>
                                A foreign key to the top leve spectrum table,
                                this indicates the spectrum the gate is being
                                applied to.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
            <refentry>
               <refmeta>
                  <refentrytitle>DBTreeVariable</refentrytitle>
                  <manvolnum>3db</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>DBTreeVaroab;e</refname>
                  <refpurpose>Ecapsulate tree variable definitions.</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;DBTreeVariable.h&gt;

namespace SpecTclDB {
    
class DBTreeVariable {
public:
    struct Info {
        int         s_id;
        int         s_saveset;
        std::string s_name;
        double      s_value;
        std::string s_units;
        
    };
public:
    static bool exists(CSqlite&amp; conn, int saveid, const char* name);
    static DBTreeVariable* create(
        CSqlite&amp; conn, int saveid, const char* name, double value,
        const char* units=""
    );
    static std::vector&lt;DBTreeVariable*&gt; list(CSqlite&amp; conn, int saveid);

public:
    DBTreeVariable(CSqlite&amp; connection, int saveid, const char* varname);
public:
    const Info&amp; getInfo() const;
    std::string getName() const;
    double      getValue() const;
    std::string getUnits() const;
    
    
   

};
}                              // namespace SpecTclDB

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                         <title>DESCRIPTION</title>
                      <para>
                        Event processor computatations in SpecTcl
                        sometimes require tuning or steering parameters.
                        These may need to be modified at run-time.  For
                        example; an energy calibration will need to have the
                        coefficients of whatever polynomial is used to
                        approximate the transformation from raw paramter
                        value to energy. These values are often not known
                        before looking at raw spectra with known peaks.
                      </para>
                      <para>
                        Tree Variables are variables that can be set at run-time
                        from the SpecTcl GUI or command prompt, and accessed
                        from C++ code as if they were simply C++ double
                        precision floating point variables.  The
                        <classname>SpecTclDB::DBTreeVariable</classname>
                        encapsulates the data associated with tree variable
                        definitions in database save-sets.
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static bool </type>
                               <methodname>exists</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>name</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns <literal>true</literal> if a tree variable
                                called <parameter>name</parameter> has
                                been defined in the save set with the primary
                                key of <parameter>saveid</parameter> in
                                the database connected with
                                <parameter>conn</parameter>.  If no such
                                tree variable exists, <literal>false</literal>
                                is returned instead.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static DBTreeVariable* </type>
                               <methodname>create</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>nam</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>double</type><parameter> value</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>const char* </type><parameter>units</parameter>
                                <initializer>""</initializer>
                               </methodparam>
                            </methodsynopsis>
                            
                           </term>
                           <listitem>
                               <para>
                                Creates a new treevariable definition.
                                In addition to having a name
                                (<parameter>name</parameter>) and
                                value (<parameter>value</parameter>),
                                tree variables have an associated units of measure
                                (<parameter>units</parameter>). By convention,
                                if a tree variable is unit-less, the
                                <parameter>units</parameter> should be an empty
                                string.
                               </para>
                               <para>
                                The <parameter>saveid</parameter> parameter is the
                                primary key of the saveset the variabl
                                will be defined in.  The database is
                                <parameter>conn</parameter>
                               </para>
                               <para>
                                The return value is a pointer to a
                                <classname>SpecTGclDB::DBTreeVariable</classname>.
                                This object encapsulates the variable definition.
                                The object pointed to is dynamically
                                create so when the program no longer needs it
                                it it should be deleted.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static std::vector&lt;DBTreeVariable*&gt; </type>
                               <methodname>list</methodname>
                               <methodparam>
                                   <type>CSqlite&amp; </type><parameter>conn</parameter>
                                <initializer></initializer>
                               </methodparam>
                               <methodparam>
                                   <type>int </type><parameter>saveid</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Lists the tree variable definitions that
                                are stored in the save set with primary key
                                <parameter>saveid</parameter> in te database
                                connecte via <parameter>conn</parameter>.
                                The list is returned as a vector of pointers
                                to dynamically created
                                <classname>SpecTclDB::DBTreeVariable</classname>
                                that must be deleted when the program
                                no longer needs them.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>DBTreeVariable</methodname>
                                <methodparam>
                                    <type>CSqlite&amp; </type><parameter>connectioN</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>saveid</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>const char*</type><parameter> varname</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Looks up the tree variable definition
                                named <parameter>varname</parameter>
                                in the saveset with the primery key
                                <parameter>saveid</parameter> in the
                                database open on <parameter>connection</parameter>.
                                Information about the tree variable is wrapped
                                in the <classname>SpecTclDB::DBTreeVariable</classname>
                                object being constructe..
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>const Info&amp; </type>
                               <methodname>getInfo</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Tree variable objects wrapped cached information
                                about the variable they wrap in a
                                <type>SpecTclDB::DBTreeVarible::Info</type>
                                struct.  This method returns a const reference
                                to that structure allowing free access to this
                                data.  Note that this struct is described
                                in the <literal>DATA TYPES</literal> section
                                below.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::string </type>
                               <methodname>getName</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the name of the tree variable wrapped
                                by this object.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>double</type>
                               <methodname>getValue</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the current value of the variable wrapped
                                by the this tree variable object.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>std::string </type>
                               <methodname>getUnits</methodname>
                               <void />
                               <modifier>const</modifier>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the units string of the tree variable
                                wrapped by this object.  Note that by convention,
                                unitless values simply have an empty units string.
                                The units string is only provided for human
                                consumption. 
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>

                </refsect1>
                <refsect1>
                    <title>DATA TYPES</title>
                    <para>
                        As with all database objects in this library,
                        the <classname>SpecTclDB::DBTreeVariable</classname>
                        class provides an <type>Info</type> type defined
                        internally. A const reference to this attribute can
                        be retrieved using the <methodname>getInfo</methodname>
                        method.  The attribute caches information about the
                        treevariable wrapped by the object and contains
                        the following fields:
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_id</structfield>
                           </term>
                           <listitem>
                               <para>
                                The primary key of the tree variable in the
                                top level database table for tree variables.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>int</type><structfield>s_saveset</structfield>
                           </term>
                           <listitem>
                               <para>
                                The primary key of the save set that contains
                                this tree variable definition in the top
                                level table for save sets.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>std::string </type><structfield>s_name</structfield>
                           </term>
                           <listitem>
                               <para>
                                The name of the tree variable.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>double</type><structfield>s_value</structfield>
                           </term>
                           <listitem>
                               <para>
                                The saved value of the tree variable.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>std::string </type><structfield>s_units</structfield>
                           </term>
                           <listitem>
                               <para>
                                The units string of the tree variable at the time
                                it was saved to the database.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
            </refentry>
        </section>
        <section>
            <title>Object oriented Sqlite3 wrapper</title>
            <para>
                The database C++ software uses an object wrapping of SQLite3
                called sqlite3pp.  It was written here at the NSCL/FRIB and
                is built and installed inthe SpecTcl installation directory.
            </para>
            <para>
                To use this library you'll need to add the following
                compilation and link flags:
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>-I$SPECTCLHOME/include</literal></term>
                   <listitem>
                    <para>
                        In this flag and others, <literal>SPECTCLHOME</literal>
                        is assumed to be an environment variable that points
                        to where the SpecTcl top level installation directory is.
                       </para>
                       <para>
                        Adds the SpecTcl header directory to the search path
                        for files in <code>#include</code> preprocessor directives.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>-L$SPECTCLHOME/lib</literal></term>
                   <listitem>
                       
                       <para>
                        This flag adds the SpecTcl library directory to the
                        link library search path.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>-lSqlite3pp</literal></term>
                   <listitem>
                       <para>
                        Adds the libsqlite3pp.so shared object to the set of libraries
                        searched to resolve undefined symbols in your code.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>-lsqlite3</literal></term>
                   <listitem>
                       <para>
                        Adds the Sqlite3 API library to the libraries that are
                        searched to resolve undefined symbols in your code.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>-Wl,-rpath="$SPECTCLHOME/lib</literal></term>
                   <listitem>
                       <para>
                        Adds the SpecTcl library directory to the run-time
                        search path for shared objects that are loaded when
                        your program starts up.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The library is quite small and represents a minimal simple
                wrapping of SQLite3.  The refererence pages that follow are
                organized in a sort of logical order rather than alphabetically.
            </para>
            <refentry>
               <refmeta>
                  <refentrytitle>CSqlite</refentrytitle>
                  <manvolnum>3sqlite3pp</manvolnum>
               </refmeta>
               <refnamediv>
                  <refname>CSqlite</refname>
                  <refpurpose>Connection to Sqlite3</refpurpose>
                </refnamediv>
                <refsynopsisdiv>
                    <programlisting>
#include &lt;CSqlite&gt;

class CSqlite {

    // public data connection flags:
public:    
    static const int nomutex;
    static const int fullmutex;
    static const int sharedcache;
    static const int privatecache;
    static const int uri;
    static const int readonly;
    static const int readwrite;
    static const int create;
    
    // canonicals (these do the real work).
public:
    CSqlite(const char* database);
    CSqlite(const char* database, int flags);
    
public:
    sqlite3* connection();
    
    static const char* version();
    static int         versionNumber();
public:
    bool tableExists(const char* tableName);
    static void checkStatus(int status);
    
};

                    </programlisting>
                </refsynopsisdiv>
                <refsect1>
                    <title>DESCRIPTION</title>
                      <para>
                        Encapsulates an <type>sqlite3</type> opaque object
                        pointer used by the underlying API to connect to
                        a database.  
                      </para>
                </refsect1>
                <refsect1>
                    <title>METHODS</title>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname> CSqlite</methodname>
                                <methodparam>
                                    <type>const char* </type><parameter>database</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Connects the object under construction to the database
                                designated by <parameter>database</parameter>.
                               </para>
                               <para>
                                If <parameter>database</parameter> is the string
                                <literal>:memory:</literal>, a private temporary
                                in memory database is constructed.  This
                                is useful for testing or for rapid access that
                                is later flushed to disk using the native
                                database backup functions in the base API.
                                Sqlite3 reserves the right to add additional
                                special database designators that begin with
                                <literal>:</literal>, therefore if your actual
                                <parameter>database</parameter> would begin
                                with that character it is recommended that you
                                prefix the filename with a path e.g.
                                <literal>./:colonfile</literal>.
                               </para>
                               <para>
                                I believe that each <literal>:memory:</literal>
                                database opened is distinct rather than shared.
                               </para>
                               <para>
                                An empty string for <parameter>database</parameter>
                                opens an on disk termporary database.  This database
                                will be deleted automatically when the database
                                connection is closed.
                               </para>
                               <para>
                                Errors in creating the native database
                                handle are signalled via an exception of the
                                type <classname>CSqliteException</classname>.
                                Note that this exception is derived
                                from <classname>std::exception</classname>.
                                See its reference page  for more information.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <constructorsynopsis>
                                <methodname>CSqlite</methodname>
                                <methodparam>
                                    <type>const char*</type><parameter> database</parameter>
                                    <initializer></initializer>
                                </methodparam>
                                <methodparam>
                                    <type>int </type><parameter>flags</parameter>
                                    <initializer></initializer>
                                </methodparam>
                            </constructorsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Same as the previous  constructor however
                                a bitwise or of several flags more tightly
                                controls the open.  See <literal>PUBLIC ATTRIBUTES</literal>
                                for the legal flag values.
                                Note that using the native SQLite3 flags
                                is also supported.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>sqlite3* </type>
                               <methodname>connection</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the raw SQLite3 connection handle
                                encapsulated by this object.  We hope you never
                                have to use this method.  If you do
                                please let us know why and we'll consider
                                adding the functionality you needed to this
                                library for the next person.
                               </para>
                               <para>
                                If you close the database handle, you will, at best,
                                make all subsequent calls using it
                                fail.  You may also cause program failure.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>tatic const char* </type>
                               <methodname>version</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the SQLite3 version string for
                                the underlying library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static int         </type>
                               <methodname>versionNumber</methodname>
                               <void />
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                Returns the version number value.  The SQlite3
                                version consist of three fields of three
                                digits.  Thus a value of
                                <literal>1002003</literal> corresponds to
                                version <literal>1.2.3</literal>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>bool </type>
                               <methodname>tableExists</methodname>
                               <methodparam>
                                   <type>const char* </type><parameter>tableName</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If the encapsulate database has a table named
                                <parameter>tableName</parameter> defined,
                                this returns <literal>true</literal> othewise,
                                <literal>false</literal> is returned.
                                It is strongly suggested this be called before
                                assuming a database file passed by a user
                                is actually a database file initialized for
                                your application.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <methodsynopsis>
                               <type>static void </type>
                               <methodname>checkStatus</methodname>
                               <methodparam>
                                   <type>int </type><parameter>status</parameter>
                                <initializer></initializer>
                               </methodparam>
                            </methodsynopsis>
                           </term>
                           <listitem>
                               <para>
                                If <parameter>status</parameter> is not
                                <literal>SQLITE_OK</literal> throws a
                                <classname>CSqliteException</classname> object.
                                Used throughout the database library for
                                error checking/handling.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>
                <refsect1>
                    <title>PUBLIC ATTRIBUTES</title>
                    <para>
                        Several public attributes are exported by this
                        class.   These are static values that are usable
                        in the <parameter>flags</parameter> parameter
                        for the constructor.  They are synonyms for
                        API flag values available for use in the native
                        library function:
                        <function>sqlite3_open_v2</function>
                    </para>
                    <variablelist>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>nomutex</varname>
                           </term>
                           <listitem>
                               <para>
                                Equivalent to <literal>SQLITE3_OPEN_NOMUTEX</literal>:
                                The new database connection will use the
                                "multi-thread" threading mode.
                                This means that separate threads are
                                allowed to use SQLite at the same time, as
                                long as each thread is using a different
                                database connection.
                               </para>
                               <para>
                                In the context of this library, a different
                                connection means a different
                                <classname>CSqlite</classname> object.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>fullmutex</varname>
                           </term>
                           <listitem>
                               <para>
                                Equivalent to <literal>SQLITE_OPEN_FULLMUTEX</literal>:
                                The new database connection will use the
                                "serialized" threading mode. This means
                                the multiple threads can safely attempt
                                to use the same database connection at
                                the same time. (Mutexes will block any
                                actual concurrency, but in this mode there is no
                                harm in trying).
                               </para>
                               <para>
                                This can be used best when short database
                                accesses are interleaved with longer computing and
                                that the accesses and computing across
                                several threads.  In an appliction with this
                                balance of computing/database operation, the
                                probability of collision on a mutex is low.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>sharedcache</varname>
                           </term>
                           <listitem>
                               <para>
                                Equivalent to
                                <literal>SQLITE_OPEN_SHAREDCACHE</literal>:
                                The database is opened shared cache enabled,
                                overriding the default shared cache setting
                                provided by
                                <function>sqlite3_enable_shared_cache</function>.
                                Note that the SQlite3 documentation does not
                                recommend using this flag.
                               </para>
                               <para>
                                Sharing the cache allows a common cache to be used
                                between several objects open on the same database
                                all with this flag set.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>privatecache</varname>
                           </term>
                           <listitem>
                               <para>
                                Mutually exclusive of <varname>sharedcache</varname>.
                                This is synonymous with
                                <literal>SQLITE_OPEN_PRIVATCACHE</literal>:
                                The database is opened shared cache disabled,
                                overriding the default shared cache setting
                                provided by
                                <function>sqlite3_enable_shared_cache</function>.
                               </para>
                               <para>
                                This is the recommended and by default shared cache
                                is globally in the SQLite3 library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int</type><varname> uri</varname>
                           </term>
                           <listitem>
                               <para>
                                A synonym for :
                                <literal>SQLITE_OPEN_URI</literal>
                                    The filename can be interpreted as a URI if
                                    this flag is set.  This has several
                                    implications.
                               </para>
                               <para>
                                The first of these implications is that
                                open flags can be provided as query strings
                                on on the URI (see the SQLite3 documentation
                                for more information about this).  The
                                second is that using the query parameter
                                <literal>memory</literal> in different connections
                                with the same URI allows several connections to the
                                same memory database to be made.
                                See the SQLite3 documentation regarding
                                URI filenames.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>readonly</varname>
                           </term>
                           <listitem>
                               <para>
                                Identical to <literal>SQLITE_OPEN_READONLY</literal>:
                                The database is opened in read-only mode.
                                If the database does not already exist, an
                                error is returned, which is then thrown
                                as an <classname>CSqliteException</classname>.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int</type><varname>readwrite</varname>
                           </term>
                           <listitem>
                               <para>
                                Equivalent to <literal>SQLITE_OPEN_READWRITE</literal>:
                                The database is opened for reading and writing
                                if possible, or reading only if the file is write
                                protected by the operating system. In either
                                case the database must already exist, otherwise
                                an error is returned and thrown as a
                                <classname>CSqliteException</classname>
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term>
                            <type>static const int </type><varname>create</varname>
                           </term>
                           <listitem>
                               <para>
                                Equivalent to
                                <literal>SQLITE_OPEN_CREATE</literal>,
                                should be used in combination with
                                <varname>readwrite</varname>:
                                The database is opened for reading and writing,
                                and is created if it does not already exist.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect1>                
            </refentry>
            
        </section>
        <section>
           <title>Tcl bindings to the C++ API</title>
           <para>
           </para>
        </section>
        <section>
            <title id='app.schema'>Database schema.</title>
            <para>
                Database schema are divided into tables.  Each table
                usually has a field called its <firstterm>primary key</firstterm>.
                The value of the primary key is a unique identifier for
                records in the table.  It is normally very quick to look up
                a record by its primary key.
            </para>
            <para>
                In a relational databae, such as sqlite3, it is normal
                for records in one table to refer to records in another table.
                This reference is expressed by having fields that contain
                <firstterm>foreign keys</firstterm> to the other table.
                A foreign key is a field whose values are primary keys in
                another table.
            </para>
            <para>
                Foreign keys express a belonging/ownership relationship.
                The ownership, in turn may express a 'has many' or a
                 'has one' relationship depending on the multiplicity of the
                 relationship.   This multiplicity is defined by the
                 logic that populates the database.
            </para>
            <para>
                This appendix will describe the set of tables
                defined by a daq database and their relationships.
            </para>
            <para>
                The top level table is the <literal>save_sets</literal>
                table.  It contains one entry for each save set in the
                database. All other tables are owned either directly or indirectly
                by a row in the <literal>save_set</literal> table.
                The schema of this table is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS  save_sets 
            (id  INTEGER PRIMARY KEY,
             name TEXT UNIQUE,
             timestamp INTEGER)
                </programlisting>
            </informalexample>
            <para>
                The fields have the following meaning:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>id</structfield></term>
                    <listitem>
                        <para>
                            The primary key for the row.  Our convention is
                            that each table's primary key is an integer named
                            <literal>id</literal> and is the first field
                            declared in the table.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the save-set.  Sqlite3 does
                            not require us to declare lengths of text items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> timestamp</term>
                    <listitem>
                        <para>
                            The time at which the record was created.
                            This is a unix timestamp.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The primary purpose of save sets is to store the analysis
                configuration of SpecTcl.  This consists of parameter/treeparameter
                definitions, Spectrum definitions, gate definitions,
                gate applications and tree variables.  At present,
                pseudo parameter definitions are not stored. If there
                is a need for that, please contact us as these can be
                added.
            </para>
            <para>
                Parameter definitions require a single table:
                <literal>parameter_defs</literal>.  This table
                contains the base SpecTcl parameter definition as well
                as any optional metadata supplied by a treeparameter that
                might wrap it.  If a tree parameter is not wrapping
                the parameter, then the metadata values are NULL.
            </para>
            <para>
                Here's the table definition for the <literal>parameter_defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS parameter_defs
            (id      INTEGER PRIMARY KEY,                    
             save_id INTEGER NOT NULL,  -- foreign key to save_sets.id
             name    TEXT NOT NULL,
             number  INTEGER NOT NULL,
             low     REAL,
             high    REAL,
             bins    INTEGER,
             units   TEXT)
                </programlisting>
            </informalexample>
            <para>
                As with all tables, by convention, <structfield>id</structfield>
                is the primary key and is an integer.  Here are the
                definitions for the remaining fields of the table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>save_id</structfield></term>
                    <listitem>
                        <para>
                            This is a foreign key that contains the
                            <literal>id</literal> of the <literal>save_set</literal>
                            to which this parameter definition belongs.
                            We can say that a parameter definition belongs
                            to a save set and a save set has many
                            parameter definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            This field contains the name of the spectcl
                            parameter.  It is never null as all SpecTcl
                            parameter must have unique names.  The
                            field is not marked as unique because different
                            save sets may have parameter definitions with the
                            same name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> number</term>
                    <listitem>
                        <para>
                            This is the SpecTcl parameter number.
                            Each parameter in SpecTcl has a unique number
                            that defines it's slot in <classname>CEvent</classname>
                            objects containing unpacked event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>low</structfield></term>
                    <listitem>
                        <para>
                            This field is not null if there is a tree
                            parameter wrapping of the parameter.  In that
                            case, the field will contain the tree parameter's
                            suggested low limit for the parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>high</structfield></term>
                    <listitem>
                        <para>
                            As with <structfield>low</structfield>, is
                            not null if the parameter is wrapped by a tree
                            parameter.  In that case, this field contains
                            the suggested high limit for this parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> <structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped with  a tree parameter,
                            this contains the suggested binning for this
                            parameter.  Otherwise, this field is null.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>units</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped by a tree parameter,
                            this field contains the units of measure of that
                            parameter.  It can be an empty string as well as
                            NULL.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of tables hold information about spectrum definitions
                and spectrum contents.  These tables are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>spectrum_defs</literal></term>
                    <listitem>
                        <para>
                            The top level (or <firstterm>root</firstterm>) table
                            for spectrum definitions.  This table has
                            one entry per spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>axis_defs</literal></term>
                    <listitem>
                        <para>
                            Depending on the dimensionality of the spectrum,
                            each record in <literal>spectrum_defs</literal>
                            will have one or two records in this table.
                            Each entry describes a spectrum axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_params</literal></term>
                    <listitem>
                        <para>
                            Each spectrum depends one or more parameters.
                            Thus <literal>spectrum_defs</literal> has many
                            <literal>spectrum_params</literal> each
                            describing a parameter the spectrum depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_contents</literal></term>
                    <listitem>
                        <para>
                            If a spectrum has contents stored, this
                            table will contain the spectrum contents.
                            There will be a record in this table for
                            every non-zero channel in the spectrum.
                        </para>
                        <para>
                            Note in the special case were an empty spectrum
                            is being saved, there will be one record for
                            the spectrum with a channel value of 0.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's look at these tables in detail.
            </para>
            <para>
                <literal>spectrum_defs</literal> is the top level table
                for capturing spectrum definitions and contents.  All of
                the other tables involved in spectrum definitions have
                foreign keys linking them back to this table.  This
                table, in turn, has a foreign key that links it back
                to the save set it belongs to.
            </para>
            <para>
                The defintion of <literal>spectrum_defs</literal> is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS spectrum_defs
            (id      INTEGER PRIMARY KEY,
             save_id INTEGER NOT NULL,     -- Foreign key to save_sets.id
             name    TEXT NOT NULL,
             type    TEXT NOT NULL,
             datatype TEXT NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                Besides the <structfield>id</structfield> which is the
                usual primary keh and the <structfield>save_id</structfield>
                which is the foreign key pointing back to the
                <literal>save_sets</literal> table, the following fields
                are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl's name for the spectrum.  Each spectrum
                            in a save set has a unique name. Usually
                            humans refer to the spectrum using that name.
                            While SpecTcl assigns an integer number to that
                            spectrum, that number is actually not used
                            at all externally or internally and is, therefore,
                            not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>type</structfield></term>
                    <listitem>
                        <para>
                            Each spectrum has a type that determines how
                            it is incremented by the parameters it depends on.
                            In SpecTcl, these types are represented by short
                            textual type codes.  This field contains the
                            type code for the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>datatype</structfield></term>
                    <listitem>
                        <para>
                            Histograms storing a spectrum have a data type
                            that can be one of
                            byte (uint8_t), word (uint16_t) or
                            long (uint32_t).  This field captures that
                            datatype.  By default, given that memory is much
                            cheaper than when SpecTcl was originally written,
                            a spectrum's data type is long.  Regardless,
                            this field explicitly stores the spectrum's
                            datatype.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Each spectrum has one or two axes (SpecTcl does not support 3d
                spectra).  These axes are described in the
                <literal>axis_defs</literal> table.   When fetching from
                this table, it's important to order the results by the
                <structfield>id</structfield> field.  When this is done,
                the first (or only) axis for a spectrum is the X axis
                and the second, if it exists is the Y axis definition.
            </para>
            <para>
                Here is the definitino of the <literal>axis+defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS axis_defs
            (
                id           INTEGER PRIMARY KEY,
                spectrum_id  INTEGER NOT NULL,  -- FK to spectrum_defs.id
                low          REAL NOT NULL,
                high         REAL NOT NULL,
                bins         INTEGER NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                As usual, <structfield>id</structfield> is the primary
                key.  It also serves to order axis definitions for a spectrum.
                <structfield>spectrum_id</structfield> is a foreign key
                to the <structfield>id</structfield> field of the
                <literal>spectrum_defs</literal> table.  Its value
                indicates which spectrum in the <literal>spectrum_defs</literal>
                table, a record in this table belongs to.
            </para>
            <para>
                The remaining fields in this table are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>real</type><structfield>low</structfield></term>
                    <listitem>
                        <para>
                            The low limit of the axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type><structfield>high</structfield></term>
                    <listitem>
                        <para>
                            The high limit of the axis.  The axis is
                            considered to run over the interval
                            [low, high).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            Number of bins into which the axis is divided.
                            Note that in SpecTcl bins are all equal sized.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Spectra are defined on  parameters.  The values of parameters
                in an event can increment a spectrum depending on that
                spectrum's type and whether or not parameters needed are
                present.  The number of parameters a spectrum may have
                are dependent on may be anywhere from 1 to unbounded depending
                on the spectrum type (e.g. gamma spectra). 
            </para>
            <para>
                 Where parameter
                ordering is important, ordering the retrieval of parameters
                from the <literal>spectrum_params</literal> table
                recovers that ordering.  
            </para>
            <para>
                The contents of this table consist of the primary key
                <structfield>id</structfield>, and two foreign keys:
                <structfield>spectrum_id</structfield> which ties the
                record back to the spectrum it belongs to and
                <structfield>parameter_id</structfield> which ties the
                entry back to the parameter in the
                <literal>parameter_defs</literal> table that defines
                the parameter.
            </para>
            <para>
                In this way, it is not necessary to actually repeat
                the parameter definitions.  This point is an important
                concept in database design. This sort of table is also
                sometimes called a <firstterm>join table</firstterm>
                because you can use the SQL join operation to marry the
                <literal>spectrum_defs</literal> table to the
                <literal>parameter_defs</literal> table through this
                table.
            </para>
            <para>
                Finlly,
                If the contents of the spectrum have been saved in a
                save set there will be several entries in the
                <literal>spectrum_contents</literal> table to
                represent this.  With the exception of the special case
                of a spectrum with no counts, the table will contain one
                entry for each  non-zero channel.  If the spectrum is empty,
                it will contain a single entry for a valid channel in the
                spectrum containing a value of zero.
            </para>
            <para>
                The table contains the usual <structfield>id</structfield>
                primary key column.  It also has a
                <structfield>spectrum_id</structfield> foreign key into the
                <literal>spectrum_defs</literal> table that ties each
                record back to a spectrum definition which, in turn, ties the
                entry back to a save set.
            </para>
            <para>
                The remaining fields are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type><structfield>xbin</structfield></term>
                    <listitem>
                        <para>
                            This value is a bin number on the X axis
                            of the spectrum.  If the spectrum is one-dimensional,
                            this value is the only coordinate needed
                            to specify a spectrum bin.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>ybin</structfield></term>
                    <listitem>
                        <para>
                            If the spectrum is two dimensional (for this purpose,
                            summary spectra are two dimensional),
                            this value is the y bin coordinate of a channel
                            in the spectrum.   If the spectrum is
                            one dimensional, the value  of this field is NULL.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            This field is the value that was stored in the
                            channel designated by the
                            <structfield>xbin</structfield> and possibly
                            <structfield>ybin</structfield> fields.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                SpecTcl provides a very rich set of gate types.  For database
                definition purposes, these actually fall into three categories:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        <firstterm>Parameter/point</firstterm>; these gates
                        depend on parameters and points in parameter space.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Parameter/mask</firstterm>; these gates
                        depend on parameters and a bitmask.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Compound</firstterm>; these gates depend on
                        other gates.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                There are also the special cases of True and False gates
                that depend on nothing.
            </para>
            <para>
                This richness in gate types and dependecies leads to a root
                <literal>gate_defs</literal> table and quite a few
                subordinate tables some of which are used and other not used
                for any given gate type:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>gate_defs</literal></term>
                    <listitem>
                        <para>
                            This is the root table.  Every gate has an
                            entry in this table.  All subordinate tables
                            have foreign keys pointing back to this table.
                        </para>
                        <para>
                            Note that if you fetch gate definitions from this table
                            ordered by primary key, the API ensures that
                            you will not encounter a gate definition that
                            for a compound gate that depends on a gate you
                            have not already seen previously in the
                            retrieval.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>gate_points</term>
                    <listitem>
                        <para>
                            This table is used by Parameter/point gates to
                            store the points that define the region of
                            interest that makes up the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>component_gates</literal></term>
                    <listitem>
                        <para>
                            This table is used by Compound gates to store the
                            gates a compound gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_parameters</literal></term>
                    <listitem>
                        <para>
                            This table stores the parameters a Parameter/point
                            or Parameter/mask gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_masks</literal></term>
                    <listitem>
                        <para>
                            This table stores the mask values for
                            Parameter/mask gates.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's starg going over the contents of each of these
                tables one at a time.  The
                <literal>gate_defs</literal> table, as expected,
                has the <structfield>id</structfield> primary key
                and <structfield>saveset_id</structfield>  foreign key
                fields, uniquely defining the entry and which save set
                the gate definition belongs to.
            </para>
            <para>
                Additionally, each record of this table has the following
                fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Each gate has a unique name.  This
                            field contains that name. While SpecTcl
                            assigns gates numbers, these numbers are not
                            used internally or externally and, therefore,
                            are not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>type</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl uses short textual strings to
                            describe the gate type.  This field
                            stores that gate type.  The gate type
                            is going to determine which other tables
                            have data for this gate.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For Parameter/Points gates, the <literal>gate_points</literal>
                table defines a region of interest in parameter space in
                which the gate is true.  These gates will also have
                entries in the <literal>gate_parameters</literal> table.
                Where point ordering is important (e.g contours and bands),
                ordering the retrieval by <structfield>id</structfield>
                recovers that order.
            </para>
            <para>
                In addition to the <structfield>id</structfield> primary
                key, this table contains a
                <structfield>gate_id</structfield> field which is a
                foreign key into the <literal>gate_defs</literal> table
                identifying the gate each point belongs to.
            </para>
            <para>
                Real <structfield>x</structfield> and possibly
                null <structfield>y</structfield> fields identify the
                point coordinates.  One dimensional regions of interest
                (e.g. slices) have null y values.
            </para>
            <para>
                Compound gates require a list of dependent gates.
                These are stored in the join table
                <literal>component_gates</literal>.  In addition to the
                <structfield>id</structfield> primary key and
                <structfield>parent_gate</structfield> foreign key back to the
                <literal>gate_defs</literal> table indicating the gate
                each record belongs to, a <structfield>child_gate</structfield>
                foreign key back to the <literal>gate_defs</literal>
                table points to the dependent gate.
            </para>
            <para>
                Compound gates need not have ordering, however for some
                gate types (and, or gates), the ordering could be chosen
                to improve the efficiency of gate computation if the
                frequency with which a dependent gate is satisfied is known.
                This s because these gates do short-circuit evaluation,
                where possible to avoid checking all dependent gates.
                Once more retrieving from this table ordered by
                <structfield>id</structfield> will recover the original
                order of dependent gates.
            </para>
            <para>
                Parameter/point and parameter/mask gates require
                entrie(s) in the <literal>gate_params</literal> table.
                This is a join table with primary key
                <structfield>id</structfield> and
                <structfield>parent_gate</structfield> pointing to
                the owning gate in the <literal>gate_defs</literal> table
                and <structfield>parameter_id</structfield> pointing to the
                parameter in the <literal>parameter_defs</literal> table.
            </para>
            <para>
                As usual, retrieving the data from this table ordered by
                primary key will recover any required ordering of these parameters
                (for example band aand contour gates require the first
                parameter be the X parameter and second the Y).
            </para>
            <para>
                Finally, the <literal>gate_masks</literal> table stores the
                mask values for gates Parameter/Mask gate types.
                This table, in addition to the primary key
                <structfield>id</structfield>, and foreign key
                <structfield>parent_gate</structfield> that refers
                back to the <literal>gate_defs</literal> table
                has an integer <structfield>mask</structfield> parameter
                that contains the mask value.
            </para>
            <para>
                Defined gates can be applied to a spectrum in SpecTcl.
                When applied, that gate acts as a condition that is
                checked, event by event, and must be true for the
                spectrum to be incremented.  Actually all spectra
                have gates applied to them. When a spectrum is created
                it has a True gate applied to it so that it is always
                incremented.
            </para>
            <para>
                Gate applications are captured in a join table called,
                <literal>gate_applications</literal> in addition to the
                primary key <structfield>id</structfield>, this table
                has two foreign keys:
                <structfield>spectrum_id</structfield> that indicates which spectrum
                is being conditionalized by the gate that is
                indicated by <structfield>gate_id</structfield>.
            </para>
            <para>
                The final analysis cofiguration item we need to describe
                in the database are tree variables.  These map to Tcl
                variables and <classname>CTreeVariable</classname> objects
                that are used to steer computations performed by the
                user's event analysis pipeline.
            </para>
            <para>
                Tree variable definitions are captured in the
                <literal>treevariables</literal> table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS treevariables (
                id             INTEGER PRIMARY KEY,
                save_id        INTEGER NOT NULL,
                name           TEXT NOT NULL,
                value          DOUBLE NOT NULL,
                units          TEXT
            )
                </programlisting>
            </informalexample>
            <para>
                In addition to the <structfield>id</structfield> primary
                key and <structfield>save_id</structfield> foreign
                key into the <literal>save_sets</literal> table,
                the following fields are present in this table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the tree variable.  This
                            is also the name of the Tcl global variable
                            the tree variable maps to.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            Contains the value of the tree variable.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>units</structfield></term>
                    <listitem>
                        <para>
                            Contains the units of measure metadata for
                            this tree variable.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <section>
                <title>Storing event data</title>
                <para>
                    The event data for a single run can also be
                    stored in a save-set. At present, only
                    run state transitions, event data and scaler
                    readouts can be stored.
                </para>
                <para>
                    The SpecTcl code that
                    can write event data into the database creates
                    a new save set when the run begins, and saves
                    the analysis configuration.  It then puts data
                    into a set of additional tables.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>runs</literal></term>
                        <listitem>
                            <para>
                                Contains the root information for
                                event and scaler data. All event
                                like data for the run are linked back
                                to this table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>events</literal></term>
                        <listitem>
                            <para>
                                Stores the parameters for each event
                                that were produced by the user's event
                                analysis pipeline.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_readouts</literal></term>
                        <listitem>
                            <para>
                                Stores information about when a scaler
                                readout occured and on which source id
                                it occured.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_channels</literal></term>
                        <listitem>
                            <para>
                                Stores the data  from each channel
                                of a scaler ring item
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>runs</literal> table has the following definition
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS runs (    -- Runs that were saved.
                id         INTEGER PRIMARY KEY,
                config_id  INTEGER,              -- Configuration at begin of run.
                run_number INTEGER UNIQUE NOT NULL,
                title      TEXT NOT NULL,
                start_time INTEGER,
                stop_time  INTEGER              -- End of run time
            )
                    </programlisting>
                </informalexample>
                <para>
                    As expected, the <structfield>config_id</structfield>
                    is a foreign key into the <literal>save_sets</literal>
                    table indicating which save set this run was saved in.
                    <structfield>id</structfield> is a primary key which
                    provides a handle for dependent data to link back to.
                </para>
                <para>
                    In addition to these fields, we store:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>run_number</structfield></term>
                        <listitem>
                            <para>
                                The run number for the run captured
                                by this data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>text</type><structfield>title</structfield></term>
                        <listitem>
                            <para>
                                The title of the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which the
                                run begun. In Tcl this can be turned into
                                a human readable time with
                                <command>clock format</command>, in
                                C/C++ with <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which
                                the run was ended. Note that if the run
                                does not have a valid end run item,
                                this will be NULL
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>events</literal> table is a bit odd.
                    A normal database definition for it would look like
                    this:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
        id          INTEGER PRIMARY KEY,
        run_id      INTEGER NOT NULL,
        event_number INTEGER_NOT NULL,
        parameter_id INTEGER NOT NULL,
        parameter_value REAL NOT NULL
    )
                    </programlisting>
                </informalexample>
                <para>
                    Each parameter of each event would have an entry in the
                    table that would contain its parameter id
                    (foreign key to the <literal>parameter_defs</literal>
                    table), and its value.  In fact this was the first
                    try to implement this table.  What we found, however,
                    was that while this table would have made some interesting
                    queries to support data analysis possible, reconstructing
                    events from it was not time-efficient.
                </para>
                <para>
                    We therefore wound up settling on this compromise
                    definition:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
                id         INTEGER PRIMARY KEY,
                run_id     INTEGER NOT NULL,   -- fk to runs(id).
                event_number INTEGER NOT NULL, -- Event number in the run.
                parameter_count INTEGER NOT NULL, -- Hints at the event blob size.
                event_data  BLOB NOT NULL
            )
                    </programlisting>
                </informalexample>
                <para>
                    As in the first attempt, in addition to the
                    primary key <structfield>id</structfield>,
                    the <structfield>run_id</structfield>, a foreign key
                    tying the event back to the run it belongs to
                    and the <structfield>event_number</structfield>,
                    which represents the trigger number in the run;
                    we have:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>parameter_count</structfield></term>
                        <listitem>
                            <para>
                                Contains the number of parameters
                                that have values in this event.  SpecTcl
                                provides a <classname>CEvent</classname>
                                data type that is an array like object
                                whose values know if they've been assigned
                                values or not.  This
                                count represents the count of parameters
                                that have been assigned values.
                            </para>
                            <para>
                                Some event processing pipelines initialize
                                all parameters to some value.
                                While this avoids having to
                                check the validity of parameters, it also
                                throws away a major SpecTcl optimization
                                at histogramming time.  This is not
                                recommended practice.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>blob</type><structfield>event_data</structfield></term>
                        <listitem>
                            <para>
                                This contains the actual parameters that
                                were given values in the event.  So first,
                                what does <firstterm>blob</firstterm> mean?
                                <literal>blob</literal> is an acronym for
                                <literal>Binary Large Object</literal>.
                                Blobs allows arbitrary binary data to
                                occupy a field in the database.
                            </para>
                            <para>
                                In this case the blob stores a sequence
                                of <structfield>parameter_count</structfield>
                                <type>DBEvent::blobElement</type> structs. Where
                                this struct contains the following fields:
                            </para>
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <type>uint32_t</type>
                                        <structfield>s_parameterNumber</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The number/id of a parameter
                                            (foreign key into
                                            <literal>parameter_defs</literal>).
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <type>double</type>
                                        <structfield>s_parameterValue</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The value of that parameter for
                                            this event.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                
                            </variablelist>
                            <para>
                                The SpecTclHeader
                                <filename>CDBEvents.h</filename>
                                contains a definition of the
                                <type>DBEvent::blobElement</type>
                                data type.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Scaler data is captured in two tables.
                    The first, <literal>scaler_readouts</literal>
                    contains one record per
                    <literal>PERIODIC_SCALERS</literal>
                    ring item SpecTcl sees.  The second,
                    <literal>scaler_channels</literal> contains the
                    actual values of the scaler contained by that
                    ring item.
                </para>
                <para>
                    The <literal>scaler_readouts</literal> table looks like
                    this:
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS scaler_readouts (
                id            INTEGER PRIMARY KEY,
                run_id        INTEGER NOT NULL,      -- fk for runs.
                source_id     INTEGER NOT NULL,      -- Event builder source.
                start_offset  INTEGER NOT NULL,
                stop_offset   INTEGER NOT NULL,
                divisor       INTEGER NOT NULL,
                clock_time    INTEGER NOT NULL
            )                    
                    </programlisting>
                </informalexample>
                <para>
                    The <structfield>id</structfield>
                    field is the primary key
                    value and <structfield>run_id</structfield>
                    is a foreign key into the <literal>runs</literal>
                    table that indicates which run this readout belongs to.
                </para>
                <para>
                    The remainder of the fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>source_id</structfield></term>
                        <listitem>
                            <para>
                                This is the source id from the body header
                                of the ring item. In event built data
                                it indicates which event source produced
                                this scaler item.  If the scaler item
                                does not have a body header, this wil
                                contain the value <literal>0</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_offset</structfield></term>
                        <listitem>
                            <para>
                                Scaler data represents scaler counts over
                                some interval in the run.  This value
                                contains the time offset into the run
                                at which that interval began.  See, however
                                <structfield>divisor</structfield> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_offset</structfield></term>
                        <listitem>
                            <para>
                                Describes the time offset into the run
                                at which the counting intervale ended.
                                Again see the <structfield>divisor</structfield>
                                field below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>divisor</structfield></term>
                        <listitem>
                            <para>
                                In order to allow for sub-second timing in
                                scaler readout, either for higher precision,
                                or for cases when readouts must happen more
                                often than once per second, this field is
                                supplied.  This field represents the number
                                of seconds per <firstterm>tick</firstterm>
                                in the start and stop offset fields.
                                That is, dividing those fields by this value
                                (in floating point) results in seconds into
                                the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>clock_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type>
                                at which this scaler readout happened.
                                This can be converted to a humann readable
                                time in Tcl using
                                <command>clock format</command>
                                and in C/C++ using
                                <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Associated with each scaler channel in the ring item
                    that resulted in an entry in <literal>scaler_readouts</literal>
                    is a record in the <literal>scaler_channels</literal>
                    table.  This table has the usual
                    <structfield>id</structfield> primary key.
                    A foreign key pointing it back to an entry in the
                    <literal>scaler_readouts</literal> table named
                    <structfield>readout_id</structfield> and the following
                    additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>channel</structfield></term>
                        <listitem>
                            <para>
                                The channel number of this entry.
                                This is the index into the array of scalers
                                that was readout.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>value</structfield></term>
                        <listitem>
                            <para>
                                The number of counts in that scaler
                                channel for
                                the asssociated readout.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
    </appendix>
</book>