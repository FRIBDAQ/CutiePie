<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Sqlite3 interfaces</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>January 23, 2020</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This document describes a package distributed with SpecTcl that provides
            support for saving and restoring data from sqlite3 databases.
            For more information about Sqlite3 see
            <ulink url='http://sqlite.org' /> for information about that database and
            package.   If you want to extend the database access but don't know SQL,
            the query language used by Sqlite3, you can have a look at this
            SQL tutorial online.  <ulink url='www.w3schools.com/sql' />
        </para>
        <para>
            The remainder of this document describes
        </para>
        <itemizedlist>
            <listitem>
               <para>
                    What the SpecTcl Sqlite interface provides and how to
                    incorporate it into your SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    The low level, program neutral C++ API which allows database
                    object to be stored and recovered without the user
                    needing to know the database schema or the SQL query language
                    used to maintain and query the database contents.
                </para>
            </listitem>
            <listitem>
                <para>
                    The C++ classes SpecTcl uses to store event data into the
                    database and read it back out into SpecTcl.
                </para>
            </listitem>
            <listitem>
               <para>
                   A description of the Tcl APIs to the C++ API.
               </para>
            </listitem>
            <listitem>
               <para>
                   SpecTcl database GUI. The GUI bolts on to SpecTcl providing
                   a user interface you can use to interact with SpecTcl databases.
               </para>
            </listitem>
            
            <listitem>
               <para>
                   Appendix A provides a detailed description of the SQL schema
                   (database organization) of the database files as well as
                   reference information about the APIs described in the
                   various chapters of this manual.
               </para>
            </listitem>
            
        </itemizedlist>
        <para>
            Why use Sqlite instead of some other database library?  Most, though not all, database
            libraries work in a client server environment.  In this environment, new databases
            must be created by requesting them from a database administrator.  Sqlite, however
            stores its database in an ordinary file.  This means no overhead is required to create
            dabases and you can hand out databases to your collaborators as simply as handing them
            the database file.
        </para>
        <para>
            All of this comes at one cost.  Sqlite, provides only a single writer and multiple
            reader model.  With a lot of fancy footwork in detecting and responding to database locked
            conditions, this can be overcome, however one writer and a single reader is not normally
            a hindrance in this application.
        </para>
    </chapter>
    <chapter>
       <title>What you can do with the SpecTcl Sqlite database package.</title>
       <para>
        Databases are useful when storing data that has some well defined format and
        capturing the relationships between those data.  SpecTcl data analysis
        configurations, spectra and even event data match that description.
        Below, let's look at glossary of terms that will be used throughout
        the rest of this manual.  The glossary will also give an idea
        of what the SpecTcl Sqlite data package can do in conjunction with SpecTcl.
       </para>
       <variablelist>
        <varlistentry>
           <term>Database</term>
           <listitem>
               <para>
                In this manual database means a relational database, specifically
                and sqlite3 database.  Sqlite3 databases live in a file. While
                there are mechanisms to join several files together int one
                database, these are not used by this package.
               </para>
               <para>
                Relational databases have a schema that describes a set of tables.
                Each table has several fields.  Fields in one table can link
                rows of that table to rows of a nother table.  These are the
                relations in relational databases.
               </para>
               <para>
                The SpecTcl database package provides schema definitions
                and code to manipulate an Sqlite3 database file to store
                several types of objects interesting to SpecTcl.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Save Set</term>
           <listitem>
               <para>
                A saved set is a named entity that stores objects.  Save sets
                are analgous to directories.  Each save set owns a set of objects
                that are stored and can be retrieved.  Save sets provide a
                mechanism for users to organize the data saved in the database
                and to tag related data with a user friendly name.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Configuration</term>
           <listitem>
               <para>
                One of the things that can be stored in a save set is a configuration.
                A configuration is the SpecTcl analysis configuration at some
                point in time.  This includes parameter and tree parameter
                definitions, Spectrum definitions, gate definitions, the application
                of gates to spectra and tree variables and their values.
               </para>
               <para>
                Configurations represent repeatable SpecTcl analysis conditions.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Spectra</term>
           <listitem>
               <para>
                SpecTcl's purpose in life is to produce histograms, which it
                calls spectra.  The contents of one or more spectra can be saved
                 in a save set.   This represents the products of an analysis
                 of a specific run.  It is normal, though not required, that
                 spectra be saved in the same saveset as the configuration
                 that produced them.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Event Data</term>
           <listitem>
               <para>
                When SpecTcl analyzes raw data, either from a data file or
                from an online data source, the first thing it does
                is pass each event through a user define event processing
                pipeline.  The purpose of that pipeline is to extract useful
                parameters from the raw data into raw parameters or tree parameters.
                SpecTcl then histograms these unpacked parameters.
               </para>
               <para>
                It is possible to save the parameters extraced from raw data
                for a run in a save set.  When this done, subsequent playback
                of the run from the save set is much faster than from the
                original raw data set.  This is because the entire user
                event processing pipline, which is normally where the majority
                of the time is spent, is completely bypasssed.  
               </para>
               <para>
                This capability provides a mechanism to quickly reply  runs over
                and over again, optimizing the analysis configuration in SpecTcl.
                It also provides an analysis neutral format from which, theoretically,
                any other analysis program can analyze the data.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
    </chapter>
    <chapter>
        <title>C++ Low level API</title>
        <para>
            This section provides an overview of the C++ classes that make up the
            database API.  Before we start, the API philosophy is that you
            will write once, never modify but restore several times.
            As such you'll see that there are no methods supporting
            either removing entities saved in the database or, with the exception
            of saved spectrum contents, modifying existing stored objects.
            This is a design choice and not an oversight.
        </para>
        <para>
            The API consists of several classes all living in the <literal>SpecTclDB</literal>
            namespace:
        </para>
        <variablelist>
            <varlistentry>
               <term><classname>CDatabase</classname></term>
               <listitem>
                   <para>
                    Represents database files.  Methods in this file allow you
                    to create a properly initialized database file, connect
                    to the file, create and get information about the save set
                    objects in the file.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>SaveSet</classname></term>
               <listitem>
                   <para>
                    This class represents save set objects.  Given a database
                    object, one can create savesets in that data base and
                    load them.  Given a save set object, one can create
                    and manipulate any of the objects in the save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBParameter</classname></term>
               <listitem>
                   <para>
                    These represent parameter definitions within a save set.
                    This class can create and lookup parameter definitions
                    give a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBSpectrum</classname></term>
               <listitem>
                   <para>
                    Represents spectrum objects within a save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBGate</classname></term>
               <listitem>
                   <para>
                    Represents a gate object in a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBApplication</classname></term>
               <listitem>
                   <para>
                    Represents the application of a gate to a spectrum.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>DBTreeVariable</term>
               <listitem>
                   <para>
                    Represents a tree variable saved in a save set.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Top level classes, <classname>CDatabase</classname> and
            <classname>SaveSet</classname> are written so that normally,
            you will not have to create or manually lookup the other
            individual objects.
        </para>
        <section>
            <title><classname>SpecTclDB::CDatabase</classname></title>
            <para>
                This section will introduce the <classname>CDatabase</classname>
                class through a set of simple examples.  These examples
                include code fragments that:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Create and attach a database. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Create and lookup a save set. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      List the savesets that are already known to a database.
                   </para>
                </listitem>
            </orderedlist>
             <para>
                These examples and a sample Makefile built along the lines
                described below are installed in the
                <filename>share/dbexamples</filename> directory of SpecTcl's installation
                directory tree.
             </para>
            <para>
                If you intend to do serious programming with this class library,
                you should study the reference material in the appendix.
            </para>
            <para>
                Before we can write any code, we need to be able to link
                compile and link our programs to this library. This requires
                a set of compilation and link flags.  In both cases below, in order
                to factor out the distribution directory for SpecTcl, we'll assume
                that the environment variable SPECTCLHOME is defined to be the
                top level directory of the SpecTcl installation  you are using.
                Note that environment variables are imported to Makefiles as
                Makefile variables (e.g. $(SPECTCLHOME) is the environment variable
                SPECTCLHOME).  SpecTcl depends on Root so we're also going to
                assume that ROOTSYS is defined and points to the directory
                from wich SpecTcl was linked with root.  As of version 5.3-007,
                the $SPECTCLHOME/VERSION file will tell you the value used for
                ROOTSYS.
            </para>
            <formalpara>
                <title>Compilation flags:</title>
                <para>
                    Compilation flags must ensure that the SpecTcl Headers
                    <variablelist>
                        <varlistentry>
                           <term><literal>-I$SPECTCLHOME/include</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's include file
                                directory searchable for <literal>#include</literal>
                                directives in your source code.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <formalpara>
                <title>Link flags</title>
                <para>
                    <variablelist>
                        <varlistentry>
                           <term><literal>-L$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's library directory
                                searchable for libraries on the link line.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Adds the SpecTcl library directory to the search
                                path used by the run time loader to locate shared
                                libraries needed by your program.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$ROOTSYS/lib</literal></term>
                           <listitem>
                               <para>
                                Adds root's library directory to the shared object
                                load search path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSpecTclDb</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl database API.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lTclGrammerApp</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl main library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSqlite3pp</literal></term>
                           <listitem>
                               <para>
                                Pulls in a C++ encapsulation of sqlite3.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lsqlite3</literal></term>
                           <listitem>
                               <para>
                                Pulls in the Sqlite3 API.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <para>
                A final note.  If root was not built with internal -rpath's
                turned on the sample program in this manual (and even
                SpecTcl itself) may fail with an error like
            </para>
            <para>
                <literal>
                    ./makedb: error while loading shared libraries: libvdt.so:
                cannot open shared object file: No such file or directory
            </literal>
                If that is the case then set up the full Root environment
                by $ROOTSYS/bin/thisroot.sh
            </para>
            <para>
                Let's look at the simplest example.  A complete program
                that creates an empty database. The program takes a
                databsae filename on the command line as a single argument.
            </para>
            <example>
                <title>Createing an empty database (makedb.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;               <co id='makedb.includes' />
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makedb db-filenme\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::CDatabase::create(argv[1]);          <co id='makedb.create' />

  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='makedb.includes' >
                    <para>
                        Including this header brings the class definition of
                        <classname>SpecTclDB::CDatabase</classname> into our
                        program.
                    </para>
                </callout>
                <callout arearefs='makedb.create' >
                    <para>
                        This line creates a new empty database. The
                        static method <methodname>create</methodname> in
                        <classname>SpecTclDB::CDatabase</classname> takes
                        a null terminated (C) string and creates a new database
                        in that file.
                    </para>
                    <para>
                        It is not harmful to call this on a database file that
                        has already been initialized with the SpecTcl database
                        schema as the SQL used is of the form
                        <literal>CREATE ... IF NOT EXISTS</literal>.
                    </para>
                    <para>
                        Using this method on an existing database file used for
                        another purpose will add the schema needed to
                        also use that file as a SpecTcl database; as long
                        as there are no collisions in table and index names.
                    </para>
                    <para>
                        Using this method on a file that is not an sqlite database
                        will result in an error message indicating the file is
                        not a database file.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at another simple full program.  This
                program will open an existing  database and create a saveset
                named <literal>a saveset</literal> in the database.
                The program will also demonstrate very simple error detection.
            </para>
            <example>
                <title>Creating savesets in a database (makesaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;                <co id='makesvset.savesetheader' />
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makesaveset database-name\n";
    exit(EXIT_FAILURE);
  }
  try {
    SpecTclDB::CDatabase db(argv[1]);     <co id='makesvset.opendb' />

    SpecTclDB::SaveSet* pSaveset = db.createSaveSet("a saveset"); <co id='makesvset.makeset' />
    delete pSaveset;
  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; <co id='makesvset.errors' />
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);

}

                </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='makesvset.savesetheader' >
                <para>
                    We'll be using a method from the
                    <classname>SpecTclDB::SaveSet</classname> class. This
                    <literal>#include</literal> pulls the definition of that
                    class and its methods into our program.
                </para>
               </callout>
               <callout arearefs='makesvset.opendb' >
                   <para>
                    In the previous example, we saw that the static
                    <methodname>create</methodname> method for the
                    <classname>SpecTclDB::CDatabase</classname> class
                    created and initialized a database file.  The
                    <classname>SpecTclDB::CDatabase</classname> class constructor
                    creates a database object that is connected to an already
                    created database file.
                </para>
               </callout>
               <callout arearefs='makesvset.makeset' >
                   <para>
                    This line asks the database object to create a new saveset.
                    On success, a pointer to the saveset object that encapsulates
                    the saveset in the database is created. Note that savesets
                    must have unique names.  Try running this program on
                    the same database twice.
                </para>
               </callout>
               <callout arearefs='makesvset.errors' >
                   <para>
                        The database API reports errors by throwing exceptions that
                        are derived from <classname>std::exception</classname>.
                        Errors, therefore are handled by this catch block. Any
                        meaningful message held by the exception object is
                        reported here.
                    </para>
                    <para>
                        If you do try the experiment of runing this program
                        on a saveset twice, this code will tell you the
                        saveset already exists.
                    </para>
               </callout>
            </calloutlist>
            <para>
                As an excersise, modify this program to accepts, as a second
                parameter, the name of the save set to create.  In the
                next, and last example in this section,
                we'll list the names of all of the savesets
                in a database.
            </para>
            <example>
                <title>Listing savesets (lssaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: lssaveset db-filename\n";
    exit(EXIT_FAILURE);
  }
  SpecTclDB::CDatabase db(argv[1]);
  auto savesets = db.getAllSaveSets();                 <co id='lssvset.getall' />
  std::cout &lt;&lt; " Save sets in " &lt;&lt; argv[1] &lt;&lt; std::endl; 
  for (int i =0; i &lt; savesets.size(); i++) {
    std::cout &lt;&lt; savesets[i]-&gt;getInfo().s_name &lt;&lt; std::endl; <co id='lssvset.name' />
    delete savesets[i];                                  <co id='lssaveset.del' />
  }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='lssvset.getall' >
                    <para>
                        The <methodname>getAllSaveSets</methodname> of
                        <classname>SpecTclDB::CDatabase</classname> returns
                        an indexable collection of pointers to the save set
                        objects that encapsulate all of the savesets in the
                        database.
                    </para>
                    <para>
                        A look at the header will tell you that <varname>savesets</varname>
                        is actually a
                        <classname>std::vector&lt;SpecTclDB::SaveSet*&gt;</classname>.
                        We could have used that type declaration.  There are
                        a couple of reasons we didn't. One sensible the other lazy.
                        By letting the compiler figure out the actual type
                        for <varname>savesets</varname>, the implementation of
                        <methodname>getAllSaveSets</methodname> could change and,
                        as long as the type returned suported
                        <methodname>size</methodname> and
                        <methodname>operator[]</methodname>, our code would
                        not need to change.  Second, this saved us a bunch of
                        typing in the code, at the cost of this paragraph
                        of explanation.
                    </para>
                </callout>
                <callout arearefs='lssvset.name' >
                    <para>
                        Saveset objects have a
                        <methodname>getInfo</methodname> method.  This method
                        returns a const reference to a struct that contains
                        information cached from the database about the saveset.
                        The <structfield>s_name</structfield> field of this
                        struct contains a printable name (actually a
                        <classname>std::string</classname>).
                    </para>
                </callout>
                <callout arearefs='lssaveset.del' >
                    <para>
                        Since <methodname>getAllSaveSets</methodname> dynamically
                        creates the save set objects it returns, these must be
                        <literal>delete</literal>-d as they are no longer needed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The SpecTclDB::SaveSet class.</title>
            <para>
                Save sets are where data are stored. Save sets are used to organize
                data into named containers.  Each container has a name,
                a creation timestamp and a unique integer identifier.   The
                identifier is used to link other objects back to the save set
                that owns them in the <literal>save_sets</literal> table of the
                database.  See the description of the database schema in the
                reference appendix for more information.
            </para>
            <para>
                In this section we'll show a few examples of the the
                <classname>SpecTclDB::SaveSet</classname> class in action.  We're
                only going to look at the object methods of the
                <classname>SpecTclDB::Saveset</classname> class.  There are
                some static methods, but they are intended for use by
                the <classname>SpecTclDB::CDatabase</classname> class not us.
            </para>
            <para>
                We're going to look at the Savesets through the lens of the following
                examples (installed in the <filename>share/dbexamples</filename>
                directory of the SpecTcl installation).
                These examples will:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                       Show how to define parameters and get
                       information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Show how to save spectrum definitions and
                      retrieve information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save the definition of
                      several broad categories of
                      gates, and retrieve information about
                      them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save information about which gates
                      are applied to conditionalize the
                      increments of which spectra.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to store information about
                      tree variables and retrieve it.
                   </para>
                </listitem>
                <listitem>
                    <para>
                        How to store and retrieve
                        decoded events,
                        and scaler readouts in a
                        saveset.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Defining parameters (pardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;      <co id='pardef.paramhdr' />

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if(argc != 2) {
    std::cerr &lt;&lt; "Usage:  pardef db-filename\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::SaveSet* pSave(nullptr);  <co id='pardef.psave' />
      
  try {
    SpecTclDB::CDatabase db(argv[1]);
    pSave = db.getSaveSet("a saveset"); <co id='pardef.getsvset' />
    delete pSave-&gt;createParameter("p1", 100); <co id='pardef.create' />
    delete pSave-&gt;createParameter("p2", 101, -10.0, 1.0, 100, "cm");

    auto params = pSave-&gt;listParameters(); <co id='pardef.listpars' />
    std::cout &lt;&lt; "The following parameters are defined:\n";
    for (int i =0; i &lt; params.size(); i++) {
      std::cout &lt;&lt; params[i]-&gt;getInfo().s_name &lt;&lt; std::endl;
      delete params[i];
    }
    SpecTclDB::DBParameter* p = pSave-&gt;findParameter("p2"); <co id='pardef.find' />
    std::cerr &lt;&lt; " I found parameter: " &lt;&lt; p-&gt;getInfo().s_name &lt;&lt; std::endl;
    delete p;

  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    delete pSave;
    exit(EXIT_FAILURE);
  }

  delete pSave;
  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pardef.paramhdr' >
                    <para>
                        Parameters are encapsulated in
                        <classname>SpecTclDB::DBParameter</classname>
                        objects.   This <literal>#include</literal>
                        bring the definition of that class into
                        the program.
                    </para>
                </callout>
                <callout arearefs='pardef.psave' >
                    <para>
                        This will be a pointer to the save set
                        we're manipulating. It's declared here
                        so that it will be in scope in the
                        <literal>catch</literal> block below.
                        That allows us to ensure that the
                        saveset gets freed if there's an
                        exception.
                    </para>
                </callout>
                <callout arearefs='pardef.getsvset' >
                    <para>
                        The <methodname>getSaveSet</methodname>
                        looks up a save set and caches its
                        database defintion into internal data
                        in a <classname>SpecTclDB::SaveSet</classname>.
                        A pointer to this dynamically allocated
                        object is then returned on success.
                        On failure an exception is thrown.
                    </para>
                </callout>
                <callout arearefs='pardef.create' >
                    <para>
                        This line and the next create two parameters.
                        SpecTcl has two raw parameters and
                        <classname>CTreeParameter</classname>
                        parameters.  The latter wrap raw parameters
                        and provide metadata that give hints about
                        how to best histogram the variable and
                        units of measure.
                    </para>
                    <para>
                        The first line stores a parameter
                        definition for a raw parameter. These
                        have a name and a slot number defining
                        how SpecTcl event processors should
                        supply data for this parameter.
                    </para>
                    <para>
                        The second line stores a parameter
                        with full metadata. In addition to the
                        name and number, metadata includes a
                        suggested low limite, a suggested high
                        limit, a suggested binning over that range,
                        and units of measure.  The second line
                        stores a parameter that runs in the range
                        of -10.0 to 10.0 with a suggested binning
                        of 100 bins.  The units of measure
                        are <literal>cm</literal>.
                    </para>
                    <para>
                        Noe that
                        <methodname>createParameter</methodname>
                        returns a pointer to the created parameter
                        object. This object is immediately
                        deleted.
                    </para>
                </callout>
                <callout arearefs='pardef.listpars' >
                    <para>
                        Produces a container with pointers to all
                        parameters.  The pointers are to
                        dynamically allocated objects which
                        must be deleted when no longer needed.
                    </para>
                    <para>
                        Subsequent code iterates over the
                        objects in the container, outputting
                        the names of each parameter and
                        deleting the objects.
                    </para>
                </callout>
                <callout arearefs='pardef.find' >
                    <para>
                        Retrieves a parameter definition by name.  This provides
                        us a container of pointers to <classname>DBParameter</classname>
                        objects.  We'll say more about <classname>DBParameter</classname>
                        later on.  For now you only need to know that this
                        class encapsulates cached information retrieved from
                        the database for a single parameter.
                    </para>
                    <para>
                        A readonly reference to this information can be gotten via
                        the <methodname>getInfo</methodname> method.  The pointers
                        in the container represent pointers to dynamically created
                        objects.  Therefore, once your code is done using one,
                        it should be deleted to avoid memory leaks.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at a toy program to create spectra in a save
                set and list information about the spectra a save set has.
                For this program:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Refer to the SpecTcl command reference or user's guide for
                      a list of the spectrum types and what they do.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you are going to test it, be sure you run it on a
                      database that has had the parameter test program run on it.
                      We will be using the saveset and
                      parameter definitions that we created
                      with that program.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                Note that in general, spectra need a name,
                a spectrum type, a vector of parameters and
                one or two axis definitions.  By default,
                spectra are defined with longword per channel
                storage, but this can be modified.
            </para>
            <example>
                <title>Defining Spectra (specdef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;
#include &lt;DBSpectrum.h&gt;     <co id='specdef.header' />

#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:  specdef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSvSet(nullptr);
    try {
        pSvSet = db.getSaveSet("a saveset");

        std::vector&lt;const char*&gt; s1Params = {"p1"};      <co id='specdef.pars' />
        std::vector&lt;const char*&gt; s2Params = {"p1", "p2"}; 
        SpecTclDB::SaveSet::SpectrumAxis x = {0, 1023, 1024};  <co id='specdef.axes' />
        SpecTclDB::SaveSet::SpectrumAxis y = {-10.0, 1.0, 100};

        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s1axes = {x};
        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s2axes = {x, y};

        delete pSvSet-&gt;createSpectrum("s1", "1", s1Params, s1axes); <co id='specdef.def' />
        delete pSvSet-&gt;createSpectrum("s2", "2", s2Params, s2axes);

        auto spectra = pSvSet-&gt;listSpectra();                 <co id='specdef.list' />
        std::cout &lt;&lt; "Names of spectra in saveset:\n";
        for (int i =0; i &lt; spectra.size(); i++) {
            auto&amp; info = spectra[i]-&gt;getInfo();
            std::cout &lt;&lt; info.s_base.s_name &lt;&lt; std::endl; <co id='specdef.info'/>
            delete spectra[i];
        }
    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        delete pSvSet;
        exit(EXIT_FAILURE);
    }

    delete pSvSet;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <para>
                We're not going to describe the elements of this example
                that are repeats of code fragments in prior examples.
            </para>
            <calloutlist>
                <callout arearefs='specdef.header' >
                    <para>
                        We will be calling methods of the
                        <classname>DBSpectrum</classname>
                        class, which encapsulates data from
                        a spectrum definition in the database.
                        We'll also be deleting dynamically allocated
                        <classname>DBSpectrum</classname> objects.
                        Both of these require knowledge of the shape of the
                        object given in the class definition.
                        The <filename>DBSpectrum.h</filename> header
                        is included to provide that information
                        to our program.
                    </para>
                </callout>
                <callout arearefs='specdef.pars' >
                    <para>
                        Spectrum are incremented on data from parameters
                        in events.  We defined two parameters in the
                        <filename>pardef.cpp</filename> example;
                        <literal>p1</literal> and <literal>p2</literal>.
                        We're going to be making a 1d and 2d spectrum.
                        These need one and two parameters respectively.
                        The spectrum generating method requires a
                        <classname>std::vector&lt;const char*&gt;</classname>
                        where each element is a pointer to a parameter
                        name that's already been defined. 
                    </para>
                    <para>
                        This line and the next line define the vectors
                        appropriate to the two spectra we'll be creating.
                    </para>
                </callout>
                <callout arearefs='specdef.axes' >
                    <para>
                        Spectra require one or two axes as well.
                        Axes are defined by low, and high limits and
                        binning.  This line and the next define a pair
                        of axes.  Note that the first one is arbitrary,
                        but the second one, uses the low/high binning
                        suggestions in the <literal>p2</literal>
                        parameter definition.  A real program
                        will query that parameter for its axis
                        recommendations.  That's beyond the scope of
                        this example however.
                    </para>
                    <para>
                        The two lines that follow the axis definitions
                        make a one element and two element vector of
                        axis specifications respectively.  Vectors of
                        axis specifications are what the spectrum
                        generating method expects.
                    </para>
                </callout>
                <callout arearefs='specdef.def' >
                    <para>
                        These two lines actually create the spectra.
                        As with parameters, a dynamically allocated
                        pointe to the spectrum object is returned, which
                        we immediately <literal>delete</literal>.
                        The parameters to <methodname>createSpectrum</methodname>
                        are respectively, the name of the spectrum,
                        the spectrum type (<literal>1</literal> is the
                        type of 1d spectra and <literal>2</literal>
                        is the type for 2d spectra).  The parameters needed
                        by the spectrum and the spectrum axes.
                    </para>
                    <para>
                        An optional additional parameter provides
                        a string specification of the data type used
                        for spectrum channels.  This defaults to
                        <literal>long</literal> if not supplied but
                        can also be <literal>word</literal> or
                        <literal>byte</literal>.
                    </para>
                </callout>
                <callout arearefs='specdef.list' >
                    <para>
                        Asks the saveset for a list of the spectra
                        that have been defined.  The return value is
                        an indexable container that holds pointers to
                        dynamically allocated <classname>DBSpectrum</classname>
                        objects.
                    </para>
                </callout>
                <callout arearefs='specdef.info' >
                    <para>
                        The spectrum information struct is complex enough
                        that it is divided into several pieces. The
                        piece selected by <structfield>s_base</structfield>
                        contains the base information about the spectrum,
                        including the type and spectrum name.
                    </para>
                    <para>
                        The loop outputs the name sof all spectra
                        defined in the saveset to standard output.
                    </para>
                </callout>
            </calloutlist>
                        <para>
                The gate definition API in <classname>SavSet</classname>
                is the most complex of the APIs. This is because SpecTcl supports
                a rich set of gate types.  There are are essentially
                three major classes of gate:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Gates that specify a region of interest in a subset
                      of the event's parameter space.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a logical operation
                      on other gates.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a bitwise operation and comparison
                      on a mask applied to a single parameter.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The point gates are, for convenience, further
                subdivided into
                <firstterm>1-d</firstterm> gates, which specify
                lower and upper bounds that define a slice of valuees,
                and <firstterm>2-d</firstterm> gates, which
                define a 2-d region of parameter space in pairs
                of parameters.
                Regardless of the gate type, all gates are
                encapsulated in a <classname>DBGate</classname>
                class which holds the database information
                describing the gate.
            </para>
            <para>
                The information cached for a gate is similarly
                more complex.  We'll look at that in detail
                in the reference man pages on the
                <classname>DBGate</classname> class.
            </para>
            <para>
                Let's look at a simple program that generates
                one of each type of these gates.  In past examples,
                we've made a token attempt at error handling by
                wrapping the body of the code in a try/catch
                block.  From now on we will not do any error
                handling, for the sake of brevity.
            </para>
            <para>
                This program assums a database that has had
                the <command>makesaveset</command> and
                <command>pardef</command>  example programs
                run on it.
            </para>
            <example>
                <title>Defining gates (gatedef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBGate.h&gt;         <co id='gatedef.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; 'Usage:: gatedef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet*  svset = db.getSaveSet("a saveset");

    std::vector&lt;const char*&gt; p1ds = {"p1"};  <co id='gatedef.1d' />

    delete svset-&gt;create1dGate("1d", "s", p1ds, 100, 200);

    std::vector&lt;const char*&gt; p2ds = {"p1", "p2"};  <co id='gatedef.2d' />
    std::vector&lt;std::pair&lt;double, double&gt;&gt; pts2d {
      {100, 0}, {200, 0}, {200, 200}, {100, 200}
    };
    delete svset-&gt;create2dGate("2d", "c", p2ds, pts2d);

    std::vector&lt;const char*&gt; gatenames={"1d", "2d"};   <co id='gatedef.compound' />
    delete svset-&gt;createCompoundGate("compound", "+", gatenames);

    delete svset-&gt;createMaskGate("mask", "em", "p1", 0x55555555); <co id='gatedef.mask' />

    auto gates = svset-&gt;listGates();   <co id='gatedef.list' />
    std::cout &lt;&lt; "Gates in the saveset:\n";
    for (int i = 0; i &lt; gates.size(); i++) {
        std::cout &lt;&lt; gates[i]-&gt;getInfo().s_info.s_name &lt;&lt; std::endl;
        delete gates[i];
    }

    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='gatedef.header' >
                    <para>
                        The <filename>DBGate.h</filename> header defines
                        the shape and method sof the
                        <classname>SpecTclDB::DBGate</classname> class.
                        We need these definitions because we are going
                        to all methods on class instances and
                        <literal>delete</literal> them.
                    </para>
                </callout>
                <callout arearefs='gatedef.1d' >
                    <para>
                        This section of code creates a 1-d gate.
                        1-d gates define a slice in parameter space.
                        Examples of 1-d gates are slices and gamma slices.
                        Since a gamma slice is defined on any number
                        of parameters, the method that creates 1-d
                        gates needs a vector of parameter names, rather
                        than a single parameter name.
                    </para>
                    <para>
                        Once the parameter name vector is created,
                        we can call
                        <methodname>create1dGate</methodname>
                        passing the name of the new gate, the
                        gate type code (slice in this case), the
                        vector of parameter names the gate needs and
                        the limits of the gate.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        The only difference between a 1d and
                        a 2d gate (e.g. band, contour, gamma contour) is that
                        the shape of the region of interest is defined
                        by a vector of x/y coordinate pairs.  These
                        coordinates are in parameter space (not spectrum space).
                    </para>
                    <para>
                        This section of code creates  a
                        contour gate that consists of a square
                        in the parameter space defined by
                        <literal>p1</literal>, <literal>p2</literal>.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        Compound gates define a logical combination
                        of existing gates; for example a gate that
                        is true if all component gates are true or a gate that is
                        true if any of the component gates is true.
                        The  not gate is also a compound gate that
                        depends on exactly one gate.  Similarly, True and False
                        gates are compound gates that depend on no
                        other gate.
                    </para>
                    <para>
                        This section of code creates a compound gate
                        that is true when either of the 1d or
                        2d gates we previously created is true.
                    </para>
                </callout>
                <callout arearefs='gatedef.mask' >
                    <para>
                        A mask gate performs specific bitwise operations
                        on parameters that are presumed to actually be
                        integers.  The result of those bitwise
                        operations determines the truth or falsity
                        of a gate.
                    </para>
                    <para>
                        This section of code creates an
                        <firstterm>equal mask gate</firstterm>.
                        The bitmask is bitwise anded with the
                        value of the parameter on each event and,
                        if the result is equal to that mask, the
                        gate is satisfied.
                    </para>
                </callout>
                <callout arearefs='gatedef.list' >
                    <para>
                        This section of code lists the gates
                        in the save set. The method
                        <methodname>listGates</methodname> returns a container
                        that has pointers to <classname>SpecTclDB::DBGate</classname>
                        that contain cached information about all gates defined
                        for the saveset in the database.
                        The <classname>SpecTclDB::DBGate</classname> objects
                        are dynamically created and, therefore,
                        must be deleted when you no longer need them.
                    </para>
                    <para>
                        As with all database objects, the
                        <methodname>getInfo</methodname> method
                        returns a const reference to a struct
                        that defines the information in the
                        database for the gate.  For gates, this
                        struct has quite a few sub-pieces. The
                        <structfield>m_info</structfield> sub
                        structure contains base information all
                        gates have.  The <structfield>s_name</structfield>
                        field in that struct is an
                        <classname>std::string</classname>
                        containing the gate's name.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Gates, by themselves are useless.  They only have meaning, and in
                SpecTcl are only evaluated, if they are applied
                to a spectrum or spectra. When a gate is applied
                to a spectrum, that spectrum can only be incremented
                for events that make that gate true.
            </para>
            <para>
                All SpecTcl spectra have exactly one gate applied
                to it at all times.  When initially created, a SpecTcl
                spectrum has a pre-defined True gate applied to it. By convention,
                there's no need to save either that true gate
                nor the application of true gates to spectra.
            </para>
            <para>
                Note that the database does not enforce the
                requirement that only one gate is applied at any
                time to any spectrum.  Restoring from a saveset
                that applies more than one gate to a spectrum
                will result in the application of one of those
                gates (unpredictably), to the spectrum.  The
                code used by SpecTcl to create savesets ensures this
                does not happen.
            </para>
            <para>
                The example below assumes that the databas it
                is run on has hasd
                <command>makesaveset</command>, <command>pardef</command>,
                <command>gatedef</command> and
                <command>specdef</command>previously
                run on it.
            </para>
            <example>
                <title>Applying gates to spectra (applydef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBApplications.h&gt;            <co id='applydef.header' />


#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: applydef database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;applyGate("1d", "s2");    <co id='applydef.apply' />
    delete svset-&gt;applyGate("compound", "s1");

    auto applications = svset-&gt;listApplications();
    std::cout &lt;&lt; "Gate applications\n";   <co id='applydef.list' />
    for (int i = 0; i &lt; applications.size(); i++) { 
        std::cout &lt;&lt; applications[i]-&gt;getGateName()
                  &lt;&lt; " is applied to "
                  &lt;&lt; applications[i]-&gt;getSpectrumName() &lt;&lt; std::endl;
        delete applications[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);

}                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='applydef.header' >
                    <para>
                        The <filename>Applictions.h</filename>
                        header defines the
                        <classname>SpecTclDB::DBApplication</classname>
                        class which encapsulates gate application
                        records in the database.
                        Including this file allows us to delete
                        instances of this class as well as call
                        methods on instances.
                    </para>
                </callout>
                <callout arearefs='applydef.apply' >
                    <para>
                        To save a gate application, we only need
                        provide the name of the gate and the
                        name of the spectrum it should be applied
                        to to the
                        <methodname>applyGate</methodname> method
                        of the saveset.
                    </para>
                </callout>
                <callout arearefs='applydef.list' >
                    <para>
                        This section of code lists the gate applications.
                        A good question is why we didn't just use
                        <methodname>getInfo</methodname> and list
                        out information cached there.  The answer
                        is that the information structure contains
                        information that's stored in the database for
                        the application.  In keeping with holding
                        the database in a normal form, the gate
                        and spectra are stored as foreign keys into
                        the gate and spectrum definitions tables.
                    </para>
                    <para>
                        <methodname>getGateName</methodname> and
                        <methodname>getSpectrumName</methodname>
                        use those values to look up the actual
                        gate and spectrum names.
                    </para>
                </callout>
            </calloutlist>
            
            <example>
                <title>Saving and recovering tree variables (vardef.cpp)</title>
                <programlisting>
                    
                </programlisting>
            </example>
            <example>
                <title>Storing event data (evtstore.cpp)</title>
                <programlisting>
                    
                </programlisting>
            </example>
            <example>
                <title>Recovering event data (evtget.cpp)</title>
                <programlisting>
                    
                </programlisting>
            </example>
            <example>
                <title>Storing scaler readouts (sclstore.cpp)</title>
                <programlisting>
                    
                </programlisting>
            </example>
            <example>
                <title>Recovering scaler readouts (sclget.cpp)</title>
                <programlisting>
                    
                </programlisting>
            </example>
        </section>
        
    </chapter>
    <appendix>
        <title>Reference material</title>
        <section>
            <title>Database schema.</title>
            <para>
                Database schema are divided into tables.  Each table
                usually has a field called its <firstterm>primary key</firstterm>.
                The value of the primary key is a unique identifier for
                records in the table.  It is normally very quick to look up
                a record by its primary key.
            </para>
            <para>
                In a relational databae, such as sqlite3, it is normal
                for records in one table to refer to records in another table.
                This reference is expressed by having fields that contain
                <firstterm>foreign keys</firstterm> to the other table.
                A foreign key is a field whose values are primary keys in
                another table.
            </para>
            <para>
                Foreign keys express a belonging/ownership relationship.
                The ownership, in turn may express a 'has many' or a
                 'has one' relationship depending on the multiplicity of the
                 relationship.   This multiplicity is defined by the
                 logic that populates the database.
            </para>
            <para>
                This appendix will describe the set of tables
                defined by a daq database and their relationships.
            </para>
            <para>
                The top level table is the <literal>save_sets</literal>
                table.  It contains one entry for each save set in the
                database. All other tables are owned either directly or indirectly
                by a row in the <literal>save_set</literal> table.
                The schema of this table is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS  save_sets 
            (id  INTEGER PRIMARY KEY,
             name TEXT UNIQUE,
             timestamp INTEGER)
                </programlisting>
            </informalexample>
            <para>
                The fields have the following meaning:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>id</structfield></term>
                    <listitem>
                        <para>
                            The primary key for the row.  Our convention is
                            that each table's primary key is an integer named
                            <literal>id</literal> and is the first field
                            declared in the table.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the save-set.  Sqlite3 does
                            not require us to declare lengths of text items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> timestamp</term>
                    <listitem>
                        <para>
                            The time at which the record was created.
                            This is a unix timestamp.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The primary purpose of save sets is to store the analysis
                configuration of SpecTcl.  This consists of parameter/treeparameter
                definitions, Spectrum definitions, gate definitions,
                gate applications and tree variables.  At present,
                pseudo parameter definitions are not stored. If there
                is a need for that, please contact us as these can be
                added.
            </para>
            <para>
                Parameter definitions require a single table:
                <literal>parameter_defs</literal>.  This table
                contains the base SpecTcl parameter definition as well
                as any optional metadata supplied by a treeparameter that
                might wrap it.  If a tree parameter is not wrapping
                the parameter, then the metadata values are NULL.
            </para>
            <para>
                Here's the table definition for the <literal>parameter_defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS parameter_defs
            (id      INTEGER PRIMARY KEY,                    
             save_id INTEGER NOT NULL,  -- foreign key to save_sets.id
             name    TEXT NOT NULL,
             number  INTEGER NOT NULL,
             low     REAL,
             high    REAL,
             bins    INTEGER,
             units   TEXT)
                </programlisting>
            </informalexample>
            <para>
                As with all tables, by convention, <structfield>id</structfield>
                is the primary key and is an integer.  Here are the
                definitions for the remaining fields of the table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>save_id</structfield></term>
                    <listitem>
                        <para>
                            This is a foreign key that contains the
                            <literal>id</literal> of the <literal>save_set</literal>
                            to which this parameter definition belongs.
                            We can say that a parameter definition belongs
                            to a save set and a save set has many
                            parameter definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            This field contains the name of the spectcl
                            parameter.  It is never null as all SpecTcl
                            parameter must have unique names.  The
                            field is not marked as unique because different
                            save sets may have parameter definitions with the
                            same name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> number</term>
                    <listitem>
                        <para>
                            This is the SpecTcl parameter number.
                            Each parameter in SpecTcl has a unique number
                            that defines it's slot in <classname>CEvent</classname>
                            objects containing unpacked event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>low</structfield></term>
                    <listitem>
                        <para>
                            This field is not null if there is a tree
                            parameter wrapping of the parameter.  In that
                            case, the field will contain the tree parameter's
                            suggested low limit for the parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>high</structfield></term>
                    <listitem>
                        <para>
                            As with <structfield>low</structfield>, is
                            not null if the parameter is wrapped by a tree
                            parameter.  In that case, this field contains
                            the suggested high limit for this parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> <structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped with  a tree parameter,
                            this contains the suggested binning for this
                            parameter.  Otherwise, this field is null.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>units</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped by a tree parameter,
                            this field contains the units of measure of that
                            parameter.  It can be an empty string as well as
                            NULL.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of tables hold information about spectrum definitions
                and spectrum contents.  These tables are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>spectrum_defs</literal></term>
                    <listitem>
                        <para>
                            The top level (or <firstterm>root</firstterm>) table
                            for spectrum definitions.  This table has
                            one entry per spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>axis_defs</literal></term>
                    <listitem>
                        <para>
                            Depending on the dimensionality of the spectrum,
                            each record in <literal>spectrum_defs</literal>
                            will have one or two records in this table.
                            Each entry describes a spectrum axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_params</literal></term>
                    <listitem>
                        <para>
                            Each spectrum depends one or more parameters.
                            Thus <literal>spectrum_defs</literal> has many
                            <literal>spectrum_params</literal> each
                            describing a parameter the spectrum depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_contents</literal></term>
                    <listitem>
                        <para>
                            If a spectrum has contents stored, this
                            table will contain the spectrum contents.
                            There will be a record in this table for
                            every non-zero channel in the spectrum.
                        </para>
                        <para>
                            Note in the special case were an empty spectrum
                            is being saved, there will be one record for
                            the spectrum with a channel value of 0.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's look at these tables in detail.
            </para>
            <para>
                <literal>spectrum_defs</literal> is the top level table
                for capturing spectrum definitions and contents.  All of
                the other tables involved in spectrum definitions have
                foreign keys linking them back to this table.  This
                table, in turn, has a foreign key that links it back
                to the save set it belongs to.
            </para>
            <para>
                The defintion of <literal>spectrum_defs</literal> is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS spectrum_defs
            (id      INTEGER PRIMARY KEY,
             save_id INTEGER NOT NULL,     -- Foreign key to save_sets.id
             name    TEXT NOT NULL,
             type    TEXT NOT NULL,
             datatype TEXT NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                Besides the <structfield>id</structfield> which is the
                usual primary keh and the <structfield>save_id</structfield>
                which is the foreign key pointing back to the
                <literal>save_sets</literal> table, the following fields
                are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl's name for the spectrum.  Each spectrum
                            in a save set has a unique name. Usually
                            humans refer to the spectrum using that name.
                            While SpecTcl assigns an integer number to that
                            spectrum, that number is actually not used
                            at all externally or internally and is, therefore,
                            not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>type</structfield></term>
                    <listitem>
                        <para>
                            Each spectrum has a type that determines how
                            it is incremented by the parameters it depends on.
                            In SpecTcl, these types are represented by short
                            textual type codes.  This field contains the
                            type code for the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>datatype</structfield></term>
                    <listitem>
                        <para>
                            Histograms storing a spectrum have a data type
                            that can be one of
                            byte (uint8_t), word (uint16_t) or
                            long (uint32_t).  This field captures that
                            datatype.  By default, given that memory is much
                            cheaper than when SpecTcl was originally written,
                            a spectrum's data type is long.  Regardless,
                            this field explicitly stores the spectrum's
                            datatype.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Each spectrum has one or two axes (SpecTcl does not support 3d
                spectra).  These axes are described in the
                <literal>axis_defs</literal> table.   When fetching from
                this table, it's important to order the results by the
                <structfield>id</structfield> field.  When this is done,
                the first (or only) axis for a spectrum is the X axis
                and the second, if it exists is the Y axis definition.
            </para>
            <para>
                Here is the definitino of the <literal>axis+defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS axis_defs
            (
                id           INTEGER PRIMARY KEY,
                spectrum_id  INTEGER NOT NULL,  -- FK to spectrum_defs.id
                low          REAL NOT NULL,
                high         REAL NOT NULL,
                bins         INTEGER NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                As usual, <structfield>id</structfield> is the primary
                key.  It also serves to order axis definitions for a spectrum.
                <structfield>spectrum_id</structfield> is a foreign key
                to the <structfield>id</structfield> field of the
                <literal>spectrum_defs</literal> table.  Its value
                indicates which spectrum in the <literal>spectrum_defs</literal>
                table, a record in this table belongs to.
            </para>
            <para>
                The remaining fields in this table are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>real</type><structfield>low</structfield></term>
                    <listitem>
                        <para>
                            The low limit of the axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type><structfield>high</structfield></term>
                    <listitem>
                        <para>
                            The high limit of the axis.  The axis is
                            considered to run over the interval
                            [low, high).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            Number of bins into which the axis is divided.
                            Note that in SpecTcl bins are all equal sized.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Spectra are defined on  parameters.  The values of parameters
                in an event can increment a spectrum depending on that
                spectrum's type and whether or not parameters needed are
                present.  The number of parameters a spectrum may have
                are dependent on may be anywhere from 1 to unbounded depending
                on the spectrum type (e.g. gamma spectra). 
            </para>
            <para>
                 Where parameter
                ordering is important, ordering the retrieval of parameters
                from the <literal>spectrum_params</literal> table
                recovers that ordering.  
            </para>
            <para>
                The contents of this table consist of the primary key
                <structfield>id</structfield>, and two foreign keys:
                <structfield>spectrum_id</structfield> which ties the
                record back to the spectrum it belongs to and
                <structfield>parameter_id</structfield> which ties the
                entry back to the parameter in the
                <literal>parameter_defs</literal> table that defines
                the parameter.
            </para>
            <para>
                In this way, it is not necessary to actually repeat
                the parameter definitions.  This point is an important
                concept in database design. This sort of table is also
                sometimes called a <firstterm>join table</firstterm>
                because you can use the SQL join operation to marry the
                <literal>spectrum_defs</literal> table to the
                <literal>parameter_defs</literal> table through this
                table.
            </para>
            <para>
                Finlly,
                If the contents of the spectrum have been saved in a
                save set there will be several entries in the
                <literal>spectrum_contents</literal> table to
                represent this.  With the exception of the special case
                of a spectrum with no counts, the table will contain one
                entry for each  non-zero channel.  If the spectrum is empty,
                it will contain a single entry for a valid channel in the
                spectrum containing a value of zero.
            </para>
            <para>
                The table contains the usual <structfield>id</structfield>
                primary key column.  It also has a
                <structfield>spectrum_id</structfield> foreign key into the
                <literal>spectrum_defs</literal> table that ties each
                record back to a spectrum definition which, in turn, ties the
                entry back to a save set.
            </para>
            <para>
                The remaining fields are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type><structfield>xbin</structfield></term>
                    <listitem>
                        <para>
                            This value is a bin number on the X axis
                            of the spectrum.  If the spectrum is one-dimensional,
                            this value is the only coordinate needed
                            to specify a spectrum bin.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>ybin</structfield></term>
                    <listitem>
                        <para>
                            If the spectrum is two dimensional (for this purpose,
                            summary spectra are two dimensional),
                            this value is the y bin coordinate of a channel
                            in the spectrum.   If the spectrum is
                            one dimensional, the value  of this field is NULL.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            This field is the value that was stored in the
                            channel designated by the
                            <structfield>xbin</structfield> and possibly
                            <structfield>ybin</structfield> fields.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                SpecTcl provides a very rich set of gate types.  For database
                definition purposes, these actually fall into three categories:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        <firstterm>Parameter/point</firstterm>; these gates
                        depend on parameters and points in parameter space.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Parameter/mask</firstterm>; these gates
                        depend on parameters and a bitmask.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Compound</firstterm>; these gates depend on
                        other gates.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                There are also the special cases of True and False gates
                that depend on nothing.
            </para>
            <para>
                This richness in gate types and dependecies leads to a root
                <literal>gate_defs</literal> table and quite a few
                subordinate tables some of which are used and other not used
                for any given gate type:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>gate_defs</literal></term>
                    <listitem>
                        <para>
                            This is the root table.  Every gate has an
                            entry in this table.  All subordinate tables
                            have foreign keys pointing back to this table.
                        </para>
                        <para>
                            Note that if you fetch gate definitions from this table
                            ordered by primary key, the API ensures that
                            you will not encounter a gate definition that
                            for a compound gate that depends on a gate you
                            have not already seen previously in the
                            retrieval.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>gate_points</term>
                    <listitem>
                        <para>
                            This table is used by Parameter/point gates to
                            store the points that define the region of
                            interest that makes up the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>component_gates</literal></term>
                    <listitem>
                        <para>
                            This table is used by Compound gates to store the
                            gates a compound gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_parameters</literal></term>
                    <listitem>
                        <para>
                            This table stores the parameters a Parameter/point
                            or Parameter/mask gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_masks</literal></term>
                    <listitem>
                        <para>
                            This table stores the mask values for
                            Parameter/mask gates.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's starg going over the contents of each of these
                tables one at a time.  The
                <literal>gate_defs</literal> table, as expected,
                has the <structfield>id</structfield> primary key
                and <structfield>saveset_id</structfield>  foreign key
                fields, uniquely defining the entry and which save set
                the gate definition belongs to.
            </para>
            <para>
                Additionally, each record of this table has the following
                fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Each gate has a unique name.  This
                            field contains that name. While SpecTcl
                            assigns gates numbers, these numbers are not
                            used internally or externally and, therefore,
                            are not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>type</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl uses short textual strings to
                            describe the gate type.  This field
                            stores that gate type.  The gate type
                            is going to determine which other tables
                            have data for this gate.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For Parameter/Points gates, the <literal>gate_points</literal>
                table defines a region of interest in parameter space in
                which the gate is true.  These gates will also have
                entries in the <literal>gate_parameters</literal> table.
                Where point ordering is important (e.g contours and bands),
                ordering the retrieval by <structfield>id</structfield>
                recovers that order.
            </para>
            <para>
                In addition to the <structfield>id</structfield> primary
                key, this table contains a
                <structfield>gate_id</structfield> field which is a
                foreign key into the <literal>gate_defs</literal> table
                identifying the gate each point belongs to.
            </para>
            <para>
                Real <structfield>x</structfield> and possibly
                null <structfield>y</structfield> fields identify the
                point coordinates.  One dimensional regions of interest
                (e.g. slices) have null y values.
            </para>
            <para>
                Compound gates require a list of dependent gates.
                These are stored in the join table
                <literal>component_gates</literal>.  In addition to the
                <structfield>id</structfield> primary key and
                <structfield>parent_gate</structfield> foreign key back to the
                <literal>gate_defs</literal> table indicating the gate
                each record belongs to, a <structfield>child_gate</structfield>
                foreign key back to the <literal>gate_defs</literal>
                table points to the dependent gate.
            </para>
            <para>
                Compound gates need not have ordering, however for some
                gate types (and, or gates), the ordering could be chosen
                to improve the efficiency of gate computation if the
                frequency with which a dependent gate is satisfied is known.
                This s because these gates do short-circuit evaluation,
                where possible to avoid checking all dependent gates.
                Once more retrieving from this table ordered by
                <structfield>id</structfield> will recover the original
                order of dependent gates.
            </para>
            <para>
                Parameter/point and parameter/mask gates require
                entrie(s) in the <literal>gate_params</literal> table.
                This is a join table with primary key
                <structfield>id</structfield> and
                <structfield>parent_gate</structfield> pointing to
                the owning gate in the <literal>gate_defs</literal> table
                and <structfield>parameter_id</structfield> pointing to the
                parameter in the <literal>parameter_defs</literal> table.
            </para>
            <para>
                As usual, retrieving the data from this table ordered by
                primary key will recover any required ordering of these parameters
                (for example band aand contour gates require the first
                parameter be the X parameter and second the Y).
            </para>
            <para>
                Finally, the <literal>gate_masks</literal> table stores the
                mask values for gates Parameter/Mask gate types.
                This table, in addition to the primary key
                <structfield>id</structfield>, and foreign key
                <structfield>parent_gate</structfield> that refers
                back to the <literal>gate_defs</literal> table
                has an integer <structfield>mask</structfield> parameter
                that contains the mask value.
            </para>
            <para>
                Defined gates can be applied to a spectrum in SpecTcl.
                When applied, that gate acts as a condition that is
                checked, event by event, and must be true for the
                spectrum to be incremented.  Actually all spectra
                have gates applied to them. When a spectrum is created
                it has a True gate applied to it so that it is always
                incremented.
            </para>
            <para>
                Gate applications are captured in a join table called,
                <literal>gate_applications</literal> in addition to the
                primary key <structfield>id</structfield>, this table
                has two foreign keys:
                <structfield>spectrum_id</structfield> that indicates which spectrum
                is being conditionalized by the gate that is
                indicated by <structfield>gate_id</structfield>.
            </para>
            <para>
                The final analysis cofiguration item we need to describe
                in the database are tree variables.  These map to Tcl
                variables and <classname>CTreeVariable</classname> objects
                that are used to steer computations performed by the
                user's event analysis pipeline.
            </para>
            <para>
                Tree variable definitions are captured in the
                <literal>treevariables</literal> table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS treevariables (
                id             INTEGER PRIMARY KEY,
                save_id        INTEGER NOT NULL,
                name           TEXT NOT NULL,
                value          DOUBLE NOT NULL,
                units          TEXT
            )
                </programlisting>
            </informalexample>
            <para>
                In addition to the <structfield>id</structfield> primary
                key and <structfield>save_id</structfield> foreign
                key into the <literal>save_sets</literal> table,
                the following fields are present in this table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the tree variable.  This
                            is also the name of the Tcl global variable
                            the tree variable maps to.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            Contains the value of the tree variable.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>units</structfield></term>
                    <listitem>
                        <para>
                            Contains the units of measure metadata for
                            this tree variable.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <section>
                <title>Storing event data</title>
                <para>
                    The event data for a single run can also be
                    stored in a save-set. At present, only
                    run state transitions, event data and scaler
                    readouts can be stored.
                </para>
                <para>
                    The SpecTcl code that
                    can write event data into the database creates
                    a new save set when the run begins, and saves
                    the analysis configuration.  It then puts data
                    into a set of additional tables.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>runs</literal></term>
                        <listitem>
                            <para>
                                Contains the root information for
                                event and scaler data. All event
                                like data for the run are linked back
                                to this table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>events</literal></term>
                        <listitem>
                            <para>
                                Stores the parameters for each event
                                that were produced by the user's event
                                analysis pipeline.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_readouts</literal></term>
                        <listitem>
                            <para>
                                Stores information about when a scaler
                                readout occured and on which source id
                                it occured.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_channels</literal></term>
                        <listitem>
                            <para>
                                Stores the data  from each channel
                                of a scaler ring item
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>runs</literal> table has the following definition
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS runs (    -- Runs that were saved.
                id         INTEGER PRIMARY KEY,
                config_id  INTEGER,              -- Configuration at begin of run.
                run_number INTEGER UNIQUE NOT NULL,
                title      TEXT NOT NULL,
                start_time INTEGER,
                stop_time  INTEGER              -- End of run time
            )
                    </programlisting>
                </informalexample>
                <para>
                    As expected, the <structfield>config_id</structfield>
                    is a foreign key into the <literal>save_sets</literal>
                    table indicating which save set this run was saved in.
                    <structfield>id</structfield> is a primary key which
                    provides a handle for dependent data to link back to.
                </para>
                <para>
                    In addition to these fields, we store:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>run_number</structfield></term>
                        <listitem>
                            <para>
                                The run number for the run captured
                                by this data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>text</type><structfield>title</structfield></term>
                        <listitem>
                            <para>
                                The title of the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which the
                                run begun. In Tcl this can be turned into
                                a human readable time with
                                <command>clock format</command>, in
                                C/C++ with <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which
                                the run was ended. Note that if the run
                                does not have a valid end run item,
                                this will be NULL
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>events</literal> table is a bit odd.
                    A normal database definition for it would look like
                    this:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
        id          INTEGER PRIMARY KEY,
        run_id      INTEGER NOT NULL,
        event_number INTEGER_NOT NULL,
        parameter_id INTEGER NOT NULL,
        parameter_value REAL NOT NULL
    )
                    </programlisting>
                </informalexample>
                <para>
                    Each parameter of each event would have an entry in the
                    table that would contain its parameter id
                    (foreign key to the <literal>parameter_defs</literal>
                    table), and its value.  In fact this was the first
                    try to implement this table.  What we found, however,
                    was that while this table would have made some interesting
                    queries to support data analysis possible, reconstructing
                    events from it was not time-efficient.
                </para>
                <para>
                    We therefore wound up settling on this compromise
                    definition:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
                id         INTEGER PRIMARY KEY,
                run_id     INTEGER NOT NULL,   -- fk to runs(id).
                event_number INTEGER NOT NULL, -- Event number in the run.
                parameter_count INTEGER NOT NULL, -- Hints at the event blob size.
                event_data  BLOB NOT NULL
            )
                    </programlisting>
                </informalexample>
                <para>
                    As in the first attempt, in addition to the
                    primary key <structfield>id</structfield>,
                    the <structfield>run_id</structfield>, a foreign key
                    tying the event back to the run it belongs to
                    and the <structfield>event_number</structfield>,
                    which represents the trigger number in the run;
                    we have:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>parameter_count</structfield></term>
                        <listitem>
                            <para>
                                Contains the number of parameters
                                that have values in this event.  SpecTcl
                                provides a <classname>CEvent</classname>
                                data type that is an array like object
                                whose values know if they've been assigned
                                values or not.  This
                                count represents the count of parameters
                                that have been assigned values.
                            </para>
                            <para>
                                Some event processing pipelines initialize
                                all parameters to some value.
                                While this avoids having to
                                check the validity of parameters, it also
                                throws away a major SpecTcl optimization
                                at histogramming time.  This is not
                                recommended practice.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>blob</type><structfield>event_data</structfield></term>
                        <listitem>
                            <para>
                                This contains the actual parameters that
                                were given values in the event.  So first,
                                what does <firstterm>blob</firstterm> mean?
                                <literal>blob</literal> is an acronym for
                                <literal>Binary Large Object</literal>.
                                Blobs allows arbitrary binary data to
                                occupy a field in the database.
                            </para>
                            <para>
                                In this case the blob stores a sequence
                                of <structfield>parameter_count</structfield>
                                <type>DBEvent::blobElement</type> structs. Where
                                this struct contains the following fields:
                            </para>
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <type>uint32_t</type>
                                        <structfield>s_parameterNumber</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The number/id of a parameter
                                            (foreign key into
                                            <literal>parameter_defs</literal>).
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <type>double</type>
                                        <structfield>s_parameterValue</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The value of that parameter for
                                            this event.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                
                            </variablelist>
                            <para>
                                The SpecTclHeader
                                <filename>CDBEvents.h</filename>
                                contains a definition of the
                                <type>DBEvent::blobElement</type>
                                data type.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Scaler data is captured in two tables.
                    The first, <literal>scaler_readouts</literal>
                    contains one record per
                    <literal>PERIODIC_SCALERS</literal>
                    ring item SpecTcl sees.  The second,
                    <literal>scaler_channels</literal> contains the
                    actual values of the scaler contained by that
                    ring item.
                </para>
                <para>
                    The <literal>scaler_readouts</literal> table looks like
                    this:
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS scaler_readouts (
                id            INTEGER PRIMARY KEY,
                run_id        INTEGER NOT NULL,      -- fk for runs.
                source_id     INTEGER NOT NULL,      -- Event builder source.
                start_offset  INTEGER NOT NULL,
                stop_offset   INTEGER NOT NULL,
                divisor       INTEGER NOT NULL,
                clock_time    INTEGER NOT NULL
            )                    
                    </programlisting>
                </informalexample>
                <para>
                    The <structfield>id</structfield>
                    field is the primary key
                    value and <structfield>run_id</structfield>
                    is a foreign key into the <literal>runs</literal>
                    table that indicates which run this readout belongs to.
                </para>
                <para>
                    The remainder of the fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>source_id</structfield></term>
                        <listitem>
                            <para>
                                This is the source id from the body header
                                of the ring item. In event built data
                                it indicates which event source produced
                                this scaler item.  If the scaler item
                                does not have a body header, this wil
                                contain the value <literal>0</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_offset</structfield></term>
                        <listitem>
                            <para>
                                Scaler data represents scaler counts over
                                some interval in the run.  This value
                                contains the time offset into the run
                                at which that interval began.  See, however
                                <structfield>divisor</structfield> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_offset</structfield></term>
                        <listitem>
                            <para>
                                Describes the time offset into the run
                                at which the counting intervale ended.
                                Again see the <structfield>divisor</structfield>
                                field below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>divisor</structfield></term>
                        <listitem>
                            <para>
                                In order to allow for sub-second timing in
                                scaler readout, either for higher precision,
                                or for cases when readouts must happen more
                                often than once per second, this field is
                                supplied.  This field represents the number
                                of seconds per <firstterm>tick</firstterm>
                                in the start and stop offset fields.
                                That is, dividing those fields by this value
                                (in floating point) results in seconds into
                                the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>clock_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type>
                                at which this scaler readout happened.
                                This can be converted to a humann readable
                                time in Tcl using
                                <command>clock format</command>
                                and in C/C++ using
                                <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Associated with each scaler channel in the ring item
                    that resulted in an entry in <literal>scaler_readouts</literal>
                    is a record in the <literal>scaler_channels</literal>
                    table.  This table has the usual
                    <structfield>id</structfield> primary key.
                    A foreign key pointing it back to an entry in the
                    <literal>scaler_readouts</literal> table named
                    <structfield>readout_id</structfield> and the following
                    additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>channel</structfield></term>
                        <listitem>
                            <para>
                                The channel number of this entry.
                                This is the index into the array of scalers
                                that was readout.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>value</structfield></term>
                        <listitem>
                            <para>
                                The number of counts in that scaler
                                channel for
                                the asssociated readout.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
    </appendix>
</book>