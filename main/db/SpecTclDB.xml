<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Sqlite3 interfaces</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>January 23, 2020</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This document describes a package distributed with SpecTcl that provides
            support for saving and restoring data from sqlite3 databases.
            For more information about Sqlite3 see
            <ulink url='http://sqlite.org' /> for information about that database and
            package.   If you want to extend the database access but don't know SQL,
            the query language used by Sqlite3, you can have a look at this
            SQL tutorial online.  <ulink url='www.w3schools.com/sql' />
        </para>
        <para>
            The remainder of this document describes
        </para>
        <itemizedlist>
            <listitem>
               <para>
                    What the SpecTcl Sqlite interface provides and how to
                    incorporate it into your SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    The low level, program neutral C++ API which allows database
                    object to be stored and recovered without the user
                    needing to know the database schema or the SQL query language
                    used to maintain and query the database contents.
                </para>
            </listitem>
            <listitem>
                <para>
                    The C++ classes SpecTcl uses to store event data into the
                    database and read it back out into SpecTcl.
                </para>
            </listitem>
            <listitem>
               <para>
                   A description of the Tcl bindings to the C++ API.
                   These bindings can be used in any environment,
                   not just SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    A description of a high level Tcl API that
                    is SpecTcl centric.  This includes command
                    and procs for saving and restoring objects
                    in the database as well as recording
                    and playing back decoded events.
                </para>
            </listitem>
            <listitem>
               <para>
                   SpecTcl database GUI. The GUI bolts on to SpecTcl providing
                   a user interface you can use to interact with SpecTcl databases.
               </para>
            </listitem>
            
            <listitem>
               <para>
                   Appendix A provides a detailed description of the SQL schema
                   (database organization) of the database files as well as
                   reference information about the APIs described in the
                   various chapters of this manual.
               </para>
            </listitem>
            
        </itemizedlist>
        <para>
            Why use Sqlite instead of some other database library?  Most, though not all, database
            libraries work in a client server environment.  In this environment, new databases
            must be created by requesting them from a database administrator.  Sqlite, however
            stores its database in an ordinary file.  This means no overhead is required to create
            dabases and you can hand out databases to your collaborators as simply as handing them
            the database file.
        </para>
        <para>
            All of this comes at one cost.  Sqlite, provides only a single writer and multiple
            reader model.  With a lot of fancy footwork in detecting and responding to database locked
            conditions, this can be overcome, however one writer and a single reader is not normally
            a hindrance in this application.
        </para>
    </chapter>
    <chapter>
       <title>What you can do with the SpecTcl Sqlite database package.</title>
       <para>
        Databases are useful when storing data that has some well defined format and
        capturing the relationships between those data.  SpecTcl data analysis
        configurations, spectra and even event data match that description.
        Below, let's look at glossary of terms that will be used throughout
        the rest of this manual.  The glossary will also give an idea
        of what the SpecTcl Sqlite data package can do in conjunction with SpecTcl.
       </para>
       <variablelist>
        <varlistentry>
           <term>Database</term>
           <listitem>
               <para>
                In this manual database means a relational database, specifically
                and sqlite3 database.  Sqlite3 databases live in a file. While
                there are mechanisms to join several files together int one
                database, these are not used by this package.
               </para>
               <para>
                Relational databases have a schema that describes a set of tables.
                Each table has several fields.  Fields in one table can link
                rows of that table to rows of a nother table.  These are the
                relations in relational databases.
               </para>
               <para>
                The SpecTcl database package provides schema definitions
                and code to manipulate an Sqlite3 database file to store
                several types of objects interesting to SpecTcl.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Save Set</term>
           <listitem>
               <para>
                A saved set is a named entity that stores objects.  Save sets
                are analgous to directories.  Each save set owns a set of objects
                that are stored and can be retrieved.  Save sets provide a
                mechanism for users to organize the data saved in the database
                and to tag related data with a user friendly name.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Configuration</term>
           <listitem>
               <para>
                One of the things that can be stored in a save set is a configuration.
                A configuration is the SpecTcl analysis configuration at some
                point in time.  This includes parameter and tree parameter
                definitions, Spectrum definitions, gate definitions, the application
                of gates to spectra and tree variables and their values.
               </para>
               <para>
                Configurations represent repeatable SpecTcl analysis conditions.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Spectra</term>
           <listitem>
               <para>
                SpecTcl's purpose in life is to produce histograms, which it
                calls spectra.  The contents of one or more spectra can be saved
                 in a save set.   This represents the products of an analysis
                 of a specific run.  It is normal, though not required, that
                 spectra be saved in the same saveset as the configuration
                 that produced them.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Event Data</term>
           <listitem>
               <para>
                When SpecTcl analyzes raw data, either from a data file or
                from an online data source, the first thing it does
                is pass each event through a user define event processing
                pipeline.  The purpose of that pipeline is to extract useful
                parameters from the raw data into raw parameters or tree parameters.
                SpecTcl then histograms these unpacked parameters.
               </para>
               <para>
                It is possible to save the parameters extraced from raw data
                for a run in a save set.  When this done, subsequent playback
                of the run from the save set is much faster than from the
                original raw data set.  This is because the entire user
                event processing pipline, which is normally where the majority
                of the time is spent, is completely bypasssed.  
               </para>
               <para>
                This capability provides a mechanism to quickly reply  runs over
                and over again, optimizing the analysis configuration in SpecTcl.
                It also provides an analysis neutral format from which, theoretically,
                any other analysis program can analyze the data.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
    </chapter>
    <chapter>
        <title>C++ Low level API</title>
        <para>
            This section provides an overview of the C++ classes that make up the
            database API.  Before we start, the API philosophy is that you
            will write once, never modify but restore several times.
            As such you'll see that there are no methods supporting
            either removing entities saved in the database or, with the exception
            of saved spectrum contents, modifying existing stored objects.
            This is a design choice and not an oversight.
        </para>
        <para>
            The API consists of several classes all living in the <literal>SpecTclDB</literal>
            namespace:
        </para>
        <variablelist>
            <varlistentry>
               <term><classname>CDatabase</classname></term>
               <listitem>
                   <para>
                    Represents database files.  Methods in this file allow you
                    to create a properly initialized database file, connect
                    to the file, create and get information about the save set
                    objects in the file.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>SaveSet</classname></term>
               <listitem>
                   <para>
                    This class represents save set objects.  Given a database
                    object, one can create savesets in that data base and
                    load them.  Given a save set object, one can create
                    and manipulate any of the objects in the save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBParameter</classname></term>
               <listitem>
                   <para>
                    These represent parameter definitions within a save set.
                    This class can create and lookup parameter definitions
                    give a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBSpectrum</classname></term>
               <listitem>
                   <para>
                    Represents spectrum objects within a save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBGate</classname></term>
               <listitem>
                   <para>
                    Represents a gate object in a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBApplication</classname></term>
               <listitem>
                   <para>
                    Represents the application of a gate to a spectrum.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>DBTreeVariable</term>
               <listitem>
                   <para>
                    Represents a tree variable saved in a save set.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Top level classes, <classname>CDatabase</classname> and
            <classname>SaveSet</classname> are written so that normally,
            you will not have to create or manually lookup the other
            individual objects.
        </para>
        <section>
            <title><classname>SpecTclDB::CDatabase</classname></title>
            <para>
                This section will introduce the <classname>CDatabase</classname>
                class through a set of simple examples.  These examples
                include code fragments that:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Create and attach a database. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Create and lookup a save set. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      List the savesets that are already known to a database.
                   </para>
                </listitem>
            </orderedlist>
             <para>
                These examples and a sample Makefile built along the lines
                described below are installed in the
                <filename>share/dbexamples</filename> directory of SpecTcl's installation
                directory tree.
             </para>
            <para>
                If you intend to do serious programming with this class library,
                you should study the reference material in the appendix.
            </para>
            <para>
                Before we can write any code, we need to be able to link
                compile and link our programs to this library. This requires
                a set of compilation and link flags.  In both cases below, in order
                to factor out the distribution directory for SpecTcl, we'll assume
                that the environment variable SPECTCLHOME is defined to be the
                top level directory of the SpecTcl installation  you are using.
                Note that environment variables are imported to Makefiles as
                Makefile variables (e.g. $(SPECTCLHOME) is the environment variable
                SPECTCLHOME).  SpecTcl depends on Root so we're also going to
                assume that ROOTSYS is defined and points to the directory
                from wich SpecTcl was linked with root.  As of version 5.3-007,
                the $SPECTCLHOME/VERSION file will tell you the value used for
                ROOTSYS.
            </para>
            <formalpara>
                <title>Compilation flags:</title>
                <para>
                    Compilation flags must ensure that the SpecTcl Headers
                    <variablelist>
                        <varlistentry>
                           <term><literal>-I$SPECTCLHOME/include</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's include file
                                directory searchable for <literal>#include</literal>
                                directives in your source code.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <formalpara>
                <title>Link flags</title>
                <para>
                    <variablelist>
                        <varlistentry>
                           <term><literal>-L$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's library directory
                                searchable for libraries on the link line.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Adds the SpecTcl library directory to the search
                                path used by the run time loader to locate shared
                                libraries needed by your program.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$ROOTSYS/lib</literal></term>
                           <listitem>
                               <para>
                                Adds root's library directory to the shared object
                                load search path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSpecTclDb</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl database API.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lTclGrammerApp</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl main library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSqlite3pp</literal></term>
                           <listitem>
                               <para>
                                Pulls in a C++ encapsulation of sqlite3.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lsqlite3</literal></term>
                           <listitem>
                               <para>
                                Pulls in the Sqlite3 API.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <para>
                A final note.  If root was not built with internal -rpath's
                turned on the sample program in this manual (and even
                SpecTcl itself) may fail with an error like
            </para>
            <para>
                <literal>
                    ./makedb: error while loading shared libraries: libvdt.so:
                cannot open shared object file: No such file or directory
            </literal>
                If that is the case then set up the full Root environment
                by $ROOTSYS/bin/thisroot.sh
            </para>
            <para>
                Let's look at the simplest example.  A complete program
                that creates an empty database. The program takes a
                databsae filename on the command line as a single argument.
            </para>
            <example>
                <title>Createing an empty database (makedb.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;               <co id='makedb.includes' />
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makedb db-filenme\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::CDatabase::create(argv[1]);          <co id='makedb.create' />

  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='makedb.includes' >
                    <para>
                        Including this header brings the class definition of
                        <classname>SpecTclDB::CDatabase</classname> into our
                        program.
                    </para>
                </callout>
                <callout arearefs='makedb.create' >
                    <para>
                        This line creates a new empty database. The
                        static method <methodname>create</methodname> in
                        <classname>SpecTclDB::CDatabase</classname> takes
                        a null terminated (C) string and creates a new database
                        in that file.
                    </para>
                    <para>
                        It is not harmful to call this on a database file that
                        has already been initialized with the SpecTcl database
                        schema as the SQL used is of the form
                        <literal>CREATE ... IF NOT EXISTS</literal>.
                    </para>
                    <para>
                        Using this method on an existing database file used for
                        another purpose will add the schema needed to
                        also use that file as a SpecTcl database; as long
                        as there are no collisions in table and index names.
                    </para>
                    <para>
                        Using this method on a file that is not an sqlite database
                        will result in an error message indicating the file is
                        not a database file.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at another simple full program.  This
                program will open an existing  database and create a saveset
                named <literal>a saveset</literal> in the database.
                The program will also demonstrate very simple error detection.
            </para>
            <example>
                <title>Creating savesets in a database (makesaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;                <co id='makesvset.savesetheader' />
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makesaveset database-name\n";
    exit(EXIT_FAILURE);
  }
  try {
    SpecTclDB::CDatabase db(argv[1]);     <co id='makesvset.opendb' />

    SpecTclDB::SaveSet* pSaveset = db.createSaveSet("a saveset"); <co id='makesvset.makeset' />
    delete pSaveset;
  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; <co id='makesvset.errors' />
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);

}

                </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='makesvset.savesetheader' >
                <para>
                    We'll be using a method from the
                    <classname>SpecTclDB::SaveSet</classname> class. This
                    <literal>#include</literal> pulls the definition of that
                    class and its methods into our program.
                </para>
               </callout>
               <callout arearefs='makesvset.opendb' >
                   <para>
                    In the previous example, we saw that the static
                    <methodname>create</methodname> method for the
                    <classname>SpecTclDB::CDatabase</classname> class
                    created and initialized a database file.  The
                    <classname>SpecTclDB::CDatabase</classname> class constructor
                    creates a database object that is connected to an already
                    created database file.
                </para>
               </callout>
               <callout arearefs='makesvset.makeset' >
                   <para>
                    This line asks the database object to create a new saveset.
                    On success, a pointer to the saveset object that encapsulates
                    the saveset in the database is created. Note that savesets
                    must have unique names.  Try running this program on
                    the same database twice.
                </para>
               </callout>
               <callout arearefs='makesvset.errors' >
                   <para>
                        The database API reports errors by throwing exceptions that
                        are derived from <classname>std::exception</classname>.
                        Errors, therefore are handled by this catch block. Any
                        meaningful message held by the exception object is
                        reported here.
                    </para>
                    <para>
                        If you do try the experiment of runing this program
                        on a saveset twice, this code will tell you the
                        saveset already exists.
                    </para>
               </callout>
            </calloutlist>
            <para>
                As an excersise, modify this program to accepts, as a second
                parameter, the name of the save set to create.  In the
                next, and last example in this section,
                we'll list the names of all of the savesets
                in a database.
            </para>
            <example>
                <title>Listing savesets (lssaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: lssaveset db-filename\n";
    exit(EXIT_FAILURE);
  }
  SpecTclDB::CDatabase db(argv[1]);
  auto savesets = db.getAllSaveSets();                 <co id='lssvset.getall' />
  std::cout &lt;&lt; " Save sets in " &lt;&lt; argv[1] &lt;&lt; std::endl; 
  for (int i =0; i &lt; savesets.size(); i++) {
    std::cout &lt;&lt; savesets[i]-&gt;getInfo().s_name &lt;&lt; std::endl; <co id='lssvset.name' />
    delete savesets[i];                                  <co id='lssaveset.del' />
  }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='lssvset.getall' >
                    <para>
                        The <methodname>getAllSaveSets</methodname> of
                        <classname>SpecTclDB::CDatabase</classname> returns
                        an indexable collection of pointers to the save set
                        objects that encapsulate all of the savesets in the
                        database.
                    </para>
                    <para>
                        A look at the header will tell you that <varname>savesets</varname>
                        is actually a
                        <classname>std::vector&lt;SpecTclDB::SaveSet*&gt;</classname>.
                        We could have used that type declaration.  There are
                        a couple of reasons we didn't. One sensible the other lazy.
                        By letting the compiler figure out the actual type
                        for <varname>savesets</varname>, the implementation of
                        <methodname>getAllSaveSets</methodname> could change and,
                        as long as the type returned suported
                        <methodname>size</methodname> and
                        <methodname>operator[]</methodname>, our code would
                        not need to change.  Second, this saved us a bunch of
                        typing in the code, at the cost of this paragraph
                        of explanation.
                    </para>
                </callout>
                <callout arearefs='lssvset.name' >
                    <para>
                        Saveset objects have a
                        <methodname>getInfo</methodname> method.  This method
                        returns a const reference to a struct that contains
                        information cached from the database about the saveset.
                        The <structfield>s_name</structfield> field of this
                        struct contains a printable name (actually a
                        <classname>std::string</classname>).
                    </para>
                </callout>
                <callout arearefs='lssaveset.del' >
                    <para>
                        Since <methodname>getAllSaveSets</methodname> dynamically
                        creates the save set objects it returns, these must be
                        <literal>delete</literal>-d as they are no longer needed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The SpecTclDB::SaveSet class.</title>
            <para>
                Save sets are where data are stored. Save sets are used to organize
                data into named containers.  Each container has a name,
                a creation timestamp and a unique integer identifier.   The
                identifier is used to link other objects back to the save set
                that owns them in the <literal>save_sets</literal> table of the
                database.  See the description of the database schema in the
                reference appendix for more information.
            </para>
            <para>
                In this section we'll show a few examples of the the
                <classname>SpecTclDB::SaveSet</classname> class in action.  We're
                only going to look at the object methods of the
                <classname>SpecTclDB::Saveset</classname> class.  There are
                some static methods, but they are intended for use by
                the <classname>SpecTclDB::CDatabase</classname> class not us.
            </para>
            <para>
                We're going to look at the Savesets through the lens of the following
                examples (installed in the <filename>share/dbexamples</filename>
                directory of the SpecTcl installation).
                These examples will:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                       Show how to define parameters and get
                       information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Show how to save spectrum definitions and
                      retrieve information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save the definition of
                      several broad categories of
                      gates, and retrieve information about
                      them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save information about which gates
                      are applied to conditionalize the
                      increments of which spectra.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to store information about
                      tree variables and retrieve it.
                   </para>
                </listitem>
                <listitem>
                    <para>
                        How to store and retrieve
                        decoded events,
                        and scaler readouts in a
                        saveset.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Defining parameters (pardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;      <co id='pardef.paramhdr' />

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if(argc != 2) {
    std::cerr &lt;&lt; "Usage:  pardef db-filename\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::SaveSet* pSave(nullptr);  <co id='pardef.psave' />
      
  try {
    SpecTclDB::CDatabase db(argv[1]);
    pSave = db.getSaveSet("a saveset"); <co id='pardef.getsvset' />
    delete pSave-&gt;createParameter("p1", 100); <co id='pardef.create' />
    delete pSave-&gt;createParameter("p2", 101, -10.0, 1.0, 100, "cm");

    auto params = pSave-&gt;listParameters(); <co id='pardef.listpars' />
    std::cout &lt;&lt; "The following parameters are defined:\n";
    for (int i =0; i &lt; params.size(); i++) {
      std::cout &lt;&lt; params[i]-&gt;getInfo().s_name &lt;&lt; std::endl;
      delete params[i];
    }
    SpecTclDB::DBParameter* p = pSave-&gt;findParameter("p2"); <co id='pardef.find' />
    std::cerr &lt;&lt; " I found parameter: " &lt;&lt; p-&gt;getInfo().s_name &lt;&lt; std::endl;
    delete p;

  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    delete pSave;
    exit(EXIT_FAILURE);
  }

  delete pSave;
  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pardef.paramhdr' >
                    <para>
                        Parameters are encapsulated in
                        <classname>SpecTclDB::DBParameter</classname>
                        objects.   This <literal>#include</literal>
                        bring the definition of that class into
                        the program.
                    </para>
                </callout>
                <callout arearefs='pardef.psave' >
                    <para>
                        This will be a pointer to the save set
                        we're manipulating. It's declared here
                        so that it will be in scope in the
                        <literal>catch</literal> block below.
                        That allows us to ensure that the
                        saveset gets freed if there's an
                        exception.
                    </para>
                </callout>
                <callout arearefs='pardef.getsvset' >
                    <para>
                        The <methodname>getSaveSet</methodname>
                        looks up a save set and caches its
                        database defintion into internal data
                        in a <classname>SpecTclDB::SaveSet</classname>.
                        A pointer to this dynamically allocated
                        object is then returned on success.
                        On failure an exception is thrown.
                    </para>
                </callout>
                <callout arearefs='pardef.create' >
                    <para>
                        This line and the next create two parameters.
                        SpecTcl has two raw parameters and
                        <classname>CTreeParameter</classname>
                        parameters.  The latter wrap raw parameters
                        and provide metadata that give hints about
                        how to best histogram the variable and
                        units of measure.
                    </para>
                    <para>
                        The first line stores a parameter
                        definition for a raw parameter. These
                        have a name and a slot number defining
                        how SpecTcl event processors should
                        supply data for this parameter.
                    </para>
                    <para>
                        The second line stores a parameter
                        with full metadata. In addition to the
                        name and number, metadata includes a
                        suggested low limite, a suggested high
                        limit, a suggested binning over that range,
                        and units of measure.  The second line
                        stores a parameter that runs in the range
                        of -10.0 to 10.0 with a suggested binning
                        of 100 bins.  The units of measure
                        are <literal>cm</literal>.
                    </para>
                    <para>
                        Noe that
                        <methodname>createParameter</methodname>
                        returns a pointer to the created parameter
                        object. This object is immediately
                        deleted.
                    </para>
                </callout>
                <callout arearefs='pardef.listpars' >
                    <para>
                        Produces a container with pointers to all
                        parameters.  The pointers are to
                        dynamically allocated objects which
                        must be deleted when no longer needed.
                    </para>
                    <para>
                        Subsequent code iterates over the
                        objects in the container, outputting
                        the names of each parameter and
                        deleting the objects.
                    </para>
                </callout>
                <callout arearefs='pardef.find' >
                    <para>
                        Retrieves a parameter definition by name.  This provides
                        us a container of pointers to <classname>DBParameter</classname>
                        objects.  We'll say more about <classname>DBParameter</classname>
                        later on.  For now you only need to know that this
                        class encapsulates cached information retrieved from
                        the database for a single parameter.
                    </para>
                    <para>
                        A readonly reference to this information can be gotten via
                        the <methodname>getInfo</methodname> method.  The pointers
                        in the container represent pointers to dynamically created
                        objects.  Therefore, once your code is done using one,
                        it should be deleted to avoid memory leaks.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at a toy program to create spectra in a save
                set and list information about the spectra a save set has.
                For this program:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Refer to the SpecTcl command reference or user's guide for
                      a list of the spectrum types and what they do.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you are going to test it, be sure you run it on a
                      database that has had the parameter test program run on it.
                      We will be using the saveset and
                      parameter definitions that we created
                      with that program.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                Note that in general, spectra need a name,
                a spectrum type, a vector of parameters and
                one or two axis definitions.  By default,
                spectra are defined with longword per channel
                storage, but this can be modified.
            </para>
            <example>
                <title>Defining Spectra (specdef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;
#include &lt;DBSpectrum.h&gt;     <co id='specdef.header' />

#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:  specdef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSvSet(nullptr);
    try {
        pSvSet = db.getSaveSet("a saveset");

        std::vector&lt;const char*&gt; s1Params = {"p1"};      <co id='specdef.pars' />
        std::vector&lt;const char*&gt; s2Params = {"p1", "p2"}; 
        SpecTclDB::SaveSet::SpectrumAxis x = {0, 1023, 1024};  <co id='specdef.axes' />
        SpecTclDB::SaveSet::SpectrumAxis y = {-10.0, 1.0, 100};

        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s1axes = {x};
        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s2axes = {x, y};

        delete pSvSet-&gt;createSpectrum("s1", "1", s1Params, s1axes); <co id='specdef.def' />
        delete pSvSet-&gt;createSpectrum("s2", "2", s2Params, s2axes);

        auto spectra = pSvSet-&gt;listSpectra();                 <co id='specdef.list' />
        std::cout &lt;&lt; "Names of spectra in saveset:\n";
        for (int i =0; i &lt; spectra.size(); i++) {
            auto&amp; info = spectra[i]-&gt;getInfo();
            std::cout &lt;&lt; info.s_base.s_name &lt;&lt; std::endl; <co id='specdef.info'/>
            delete spectra[i];
        }
    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        delete pSvSet;
        exit(EXIT_FAILURE);
    }

    delete pSvSet;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <para>
                We're not going to describe the elements of this example
                that are repeats of code fragments in prior examples.
            </para>
            <calloutlist>
                <callout arearefs='specdef.header' >
                    <para>
                        We will be calling methods of the
                        <classname>DBSpectrum</classname>
                        class, which encapsulates data from
                        a spectrum definition in the database.
                        We'll also be deleting dynamically allocated
                        <classname>DBSpectrum</classname> objects.
                        Both of these require knowledge of the shape of the
                        object given in the class definition.
                        The <filename>DBSpectrum.h</filename> header
                        is included to provide that information
                        to our program.
                    </para>
                </callout>
                <callout arearefs='specdef.pars' >
                    <para>
                        Spectrum are incremented on data from parameters
                        in events.  We defined two parameters in the
                        <filename>pardef.cpp</filename> example;
                        <literal>p1</literal> and <literal>p2</literal>.
                        We're going to be making a 1d and 2d spectrum.
                        These need one and two parameters respectively.
                        The spectrum generating method requires a
                        <classname>std::vector&lt;const char*&gt;</classname>
                        where each element is a pointer to a parameter
                        name that's already been defined. 
                    </para>
                    <para>
                        This line and the next line define the vectors
                        appropriate to the two spectra we'll be creating.
                    </para>
                </callout>
                <callout arearefs='specdef.axes' >
                    <para>
                        Spectra require one or two axes as well.
                        Axes are defined by low, and high limits and
                        binning.  This line and the next define a pair
                        of axes.  Note that the first one is arbitrary,
                        but the second one, uses the low/high binning
                        suggestions in the <literal>p2</literal>
                        parameter definition.  A real program
                        will query that parameter for its axis
                        recommendations.  That's beyond the scope of
                        this example however.
                    </para>
                    <para>
                        The two lines that follow the axis definitions
                        make a one element and two element vector of
                        axis specifications respectively.  Vectors of
                        axis specifications are what the spectrum
                        generating method expects.
                    </para>
                </callout>
                <callout arearefs='specdef.def' >
                    <para>
                        These two lines actually create the spectra.
                        As with parameters, a dynamically allocated
                        pointe to the spectrum object is returned, which
                        we immediately <literal>delete</literal>.
                        The parameters to <methodname>createSpectrum</methodname>
                        are respectively, the name of the spectrum,
                        the spectrum type (<literal>1</literal> is the
                        type of 1d spectra and <literal>2</literal>
                        is the type for 2d spectra).  The parameters needed
                        by the spectrum and the spectrum axes.
                    </para>
                    <para>
                        An optional additional parameter provides
                        a string specification of the data type used
                        for spectrum channels.  This defaults to
                        <literal>long</literal> if not supplied but
                        can also be <literal>word</literal> or
                        <literal>byte</literal>.
                    </para>
                </callout>
                <callout arearefs='specdef.list' >
                    <para>
                        Asks the saveset for a list of the spectra
                        that have been defined.  The return value is
                        an indexable container that holds pointers to
                        dynamically allocated <classname>DBSpectrum</classname>
                        objects.
                    </para>
                </callout>
                <callout arearefs='specdef.info' >
                    <para>
                        The spectrum information struct is complex enough
                        that it is divided into several pieces. The
                        piece selected by <structfield>s_base</structfield>
                        contains the base information about the spectrum,
                        including the type and spectrum name.
                    </para>
                    <para>
                        The loop outputs the name sof all spectra
                        defined in the saveset to standard output.
                    </para>
                </callout>
            </calloutlist>
                        <para>
                The gate definition API in <classname>SavSet</classname>
                is the most complex of the APIs. This is because SpecTcl supports
                a rich set of gate types.  There are are essentially
                three major classes of gate:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Gates that specify a region of interest in a subset
                      of the event's parameter space.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a logical operation
                      on other gates.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a bitwise operation and comparison
                      on a mask applied to a single parameter.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The point gates are, for convenience, further
                subdivided into
                <firstterm>1-d</firstterm> gates, which specify
                lower and upper bounds that define a slice of valuees,
                and <firstterm>2-d</firstterm> gates, which
                define a 2-d region of parameter space in pairs
                of parameters.
                Regardless of the gate type, all gates are
                encapsulated in a <classname>DBGate</classname>
                class which holds the database information
                describing the gate.
            </para>
            <para>
                The information cached for a gate is similarly
                more complex.  We'll look at that in detail
                in the reference man pages on the
                <classname>DBGate</classname> class.
            </para>
            <para>
                Let's look at a simple program that generates
                one of each type of these gates.  In past examples,
                we've made a token attempt at error handling by
                wrapping the body of the code in a try/catch
                block.  From now on we will not do any error
                handling, for the sake of brevity.
            </para>
            <para>
                This program assums a database that has had
                the <command>makesaveset</command> and
                <command>pardef</command>  example programs
                run on it.
            </para>
            <example>
                <title>Defining gates (gatedef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBGate.h&gt;         <co id='gatedef.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; 'Usage:: gatedef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet*  svset = db.getSaveSet("a saveset");

    std::vector&lt;const char*&gt; p1ds = {"p1"};  <co id='gatedef.1d' />

    delete svset-&gt;create1dGate("1d", "s", p1ds, 100, 200);

    std::vector&lt;const char*&gt; p2ds = {"p1", "p2"};  <co id='gatedef.2d' />
    std::vector&lt;std::pair&lt;double, double&gt;&gt; pts2d {
      {100, 0}, {200, 0}, {200, 200}, {100, 200}
    };
    delete svset-&gt;create2dGate("2d", "c", p2ds, pts2d);

    std::vector&lt;const char*&gt; gatenames={"1d", "2d"};   <co id='gatedef.compound' />
    delete svset-&gt;createCompoundGate("compound", "+", gatenames);

    delete svset-&gt;createMaskGate("mask", "em", "p1", 0x55555555); <co id='gatedef.mask' />

    auto gates = svset-&gt;listGates();   <co id='gatedef.list' />
    std::cout &lt;&lt; "Gates in the saveset:\n";
    for (int i = 0; i &lt; gates.size(); i++) {
        std::cout &lt;&lt; gates[i]-&gt;getInfo().s_info.s_name &lt;&lt; std::endl;
        delete gates[i];
    }

    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='gatedef.header' >
                    <para>
                        The <filename>DBGate.h</filename> header defines
                        the shape and method sof the
                        <classname>SpecTclDB::DBGate</classname> class.
                        We need these definitions because we are going
                        to all methods on class instances and
                        <literal>delete</literal> them.
                    </para>
                </callout>
                <callout arearefs='gatedef.1d' >
                    <para>
                        This section of code creates a 1-d gate.
                        1-d gates define a slice in parameter space.
                        Examples of 1-d gates are slices and gamma slices.
                        Since a gamma slice is defined on any number
                        of parameters, the method that creates 1-d
                        gates needs a vector of parameter names, rather
                        than a single parameter name.
                    </para>
                    <para>
                        Once the parameter name vector is created,
                        we can call
                        <methodname>create1dGate</methodname>
                        passing the name of the new gate, the
                        gate type code (slice in this case), the
                        vector of parameter names the gate needs and
                        the limits of the gate.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        The only difference between a 1d and
                        a 2d gate (e.g. band, contour, gamma contour) is that
                        the shape of the region of interest is defined
                        by a vector of x/y coordinate pairs.  These
                        coordinates are in parameter space (not spectrum space).
                    </para>
                    <para>
                        This section of code creates  a
                        contour gate that consists of a square
                        in the parameter space defined by
                        <literal>p1</literal>, <literal>p2</literal>.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        Compound gates define a logical combination
                        of existing gates; for example a gate that
                        is true if all component gates are true or a gate that is
                        true if any of the component gates is true.
                        The  not gate is also a compound gate that
                        depends on exactly one gate.  Similarly, True and False
                        gates are compound gates that depend on no
                        other gate.
                    </para>
                    <para>
                        This section of code creates a compound gate
                        that is true when either of the 1d or
                        2d gates we previously created is true.
                    </para>
                </callout>
                <callout arearefs='gatedef.mask' >
                    <para>
                        A mask gate performs specific bitwise operations
                        on parameters that are presumed to actually be
                        integers.  The result of those bitwise
                        operations determines the truth or falsity
                        of a gate.
                    </para>
                    <para>
                        This section of code creates an
                        <firstterm>equal mask gate</firstterm>.
                        The bitmask is bitwise anded with the
                        value of the parameter on each event and,
                        if the result is equal to that mask, the
                        gate is satisfied.
                    </para>
                </callout>
                <callout arearefs='gatedef.list' >
                    <para>
                        This section of code lists the gates
                        in the save set. The method
                        <methodname>listGates</methodname> returns a container
                        that has pointers to <classname>SpecTclDB::DBGate</classname>
                        that contain cached information about all gates defined
                        for the saveset in the database.
                        The <classname>SpecTclDB::DBGate</classname> objects
                        are dynamically created and, therefore,
                        must be deleted when you no longer need them.
                    </para>
                    <para>
                        As with all database objects, the
                        <methodname>getInfo</methodname> method
                        returns a const reference to a struct
                        that defines the information in the
                        database for the gate.  For gates, this
                        struct has quite a few sub-pieces. The
                        <structfield>m_info</structfield> sub
                        structure contains base information all
                        gates have.  The <structfield>s_name</structfield>
                        field in that struct is an
                        <classname>std::string</classname>
                        containing the gate's name.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Gates, by themselves are useless.  They only have meaning, and in
                SpecTcl are only evaluated, if they are applied
                to a spectrum or spectra. When a gate is applied
                to a spectrum, that spectrum can only be incremented
                for events that make that gate true.
            </para>
            <para>
                All SpecTcl spectra have exactly one gate applied
                to it at all times.  When initially created, a SpecTcl
                spectrum has a pre-defined True gate applied to it. By convention,
                there's no need to save either that true gate
                nor the application of true gates to spectra.
            </para>
            <para>
                Note that the database does not enforce the
                requirement that only one gate is applied at any
                time to any spectrum.  Restoring from a saveset
                that applies more than one gate to a spectrum
                will result in the application of one of those
                gates (unpredictably), to the spectrum.  The
                code used by SpecTcl to create savesets ensures this
                does not happen.
            </para>
            <para>
                The example below assumes that the databas it
                is run on has hasd
                <command>makesaveset</command>, <command>pardef</command>,
                <command>gatedef</command> and
                <command>specdef</command>previously
                run on it.
            </para>
            <example>
                <title>Applying gates to spectra (applydef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBApplications.h&gt;            <co id='applydef.header' />


#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: applydef database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;applyGate("1d", "s2");    <co id='applydef.apply' />
    delete svset-&gt;applyGate("compound", "s1");

    auto applications = svset-&gt;listApplications();
    std::cout &lt;&lt; "Gate applications\n";   <co id='applydef.list' />
    for (int i = 0; i &lt; applications.size(); i++) { 
        std::cout &lt;&lt; applications[i]-&gt;getGateName()
                  &lt;&lt; " is applied to "
                  &lt;&lt; applications[i]-&gt;getSpectrumName() &lt;&lt; std::endl;
        delete applications[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);

}                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='applydef.header' >
                    <para>
                        The <filename>Applictions.h</filename>
                        header defines the
                        <classname>SpecTclDB::DBApplication</classname>
                        class which encapsulates gate application
                        records in the database.
                        Including this file allows us to delete
                        instances of this class as well as call
                        methods on instances.
                    </para>
                </callout>
                <callout arearefs='applydef.apply' >
                    <para>
                        To save a gate application, we only need
                        provide the name of the gate and the
                        name of the spectrum it should be applied
                        to to the
                        <methodname>applyGate</methodname> method
                        of the saveset.
                    </para>
                </callout>
                <callout arearefs='applydef.list' >
                    <para>
                        This section of code lists the gate applications.
                        A good question is why we didn't just use
                        <methodname>getInfo</methodname> and list
                        out information cached there.  The answer
                        is that the information structure contains
                        information that's stored in the database for
                        the application.  In keeping with holding
                        the database in a normal form, the gate
                        and spectra are stored as foreign keys into
                        the gate and spectrum definitions tables.
                    </para>
                    <para>
                        <methodname>getGateName</methodname> and
                        <methodname>getSpectrumName</methodname>
                        use those values to look up the actual
                        gate and spectrum names.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Sometimes we want to write computations that can
                be steered at run-time.  For example, suppose we want to apply a
                linear energy calibration to a raw ADC parameter.  This
                calibration requires two values, a slope and offset.
                These values will not, in general, be known in advance
                but must be determined.
            </para>
            <para>
                Tree variables wrap Tcl variables in a way that makes them
                easy for the user to set and modify yet appear
                like ordinary double precision values to the C++
                code.  In addition tree variables have associated,
                with them units of measure to remind users how
                to properly set them (was that slope counts/KeV, counts/MeV?).
            </para>
            <para>
                Being able to save the analysis conditions so that
                they can be repeatably restored requires that
                tree variable definitions and values be saved
                in the database as well.
            </para>
            <para>
                The C++ API for tree variables is demonstrated
                in the example below.
            </para>
            <example>
                <title>Saving and recovering tree variables (vardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBTreeVariable.h&gt;  <co id='tv.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
    if (argc !=2) {
        std::cerr &lt;&lt; "Usage: vardb database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;createVariable("p1.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("p1.offset", 0.0, "KeV");   <co id='tv.create' />

    delete svset-&gt;createVariable("p2.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("ps.offset", 0.0, "KeV");

    auto vars = svset-&gt;listVariables();      <co id='tv.list' />
    std::cout &lt;&lt; " Tree variables: \n";
    for (int i = 0; i &lt; vars.size(); i++) {
        const auto&amp; info = vars[i]-&gt;getInfo();
        std::cout &lt;&lt; info.s_name &lt;&lt; " = " &lt;&lt; info.s_value
                  &lt;&lt; info.s_units &lt;&lt; std::endl;

        delete vars[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='tv.header' >
                    <para>
                        The <filename>DBTreeVariable.h</filename>
                        header defines the <classname>SpecTclDB::DBTreeVariable</classname>
                        class which is wraps a database definition
                        for a tree variable.
                    </para>
                </callout>
                <callout arearefs='tv.create' >
                    <para>
                        These lines create four tree variables.
                        These might be initial value for a linear
                        calibration.  Each call to
                        <methodname>createVariable</methodname>
                        needs a variable name, its current value
                        and units of measure.  It is customary
                        to use an empty string as the units
                        of measure for unit-less values.
                    </para>
                </callout>
                <callout arearefs='tv.list' >
                    <para>
                        This section of code lists the tree
                        variables that are defined in this save
                        set, their values and units of measure.
                        Note that since
                        <methodname>listVariables</methodname>
                        returns a container of pointers to dynamically
                        created objects, we <literal>delete</literal>
                        each pointer after we are done with it.
                    </para>
                </callout>
            </calloutlist>
            <para>
                One of the more powerful features of the SpecTcl
                database is its ability to store pre-decoded parameters
                and playing back runs from the databsae.
                This is analagous to loading Root Trees (which SpecTcl
                can also do).  
            </para>
            <para>
                This allows the user to rapidly try out different
                analysis conditions.   Rapidly because normally the
                user's data anlysis pipeline, the code that extracts parametes
                from raw data, is the most computationally expensive
                part of SpecTcl.  Reading events from the database allows
                the data analysis pipeline to be bypassed.
            </para>
            <para>
                The examples that show the API for storing and
                reading back event data are somewhat more complex.
                They will also need to rely on the existence of
                some source of data and some sink of data.
                These will be trivial sources, and not described
                in detail in the examples.
            </para>
            <example>
                <title>Storing event data (evtstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
                         <co id='evtstore.crevent' />
void createEvent(std::vector&lt;int&gt;&amp; params, std::vector&lt;double&gt;&amp; values)
{

    for (int i =0; i &lt; 100; i++) {
        if (drand48() &lt; 0.5) {
            params.push_back(i);
            values.push_back(drand48()*200.0 - 100.0);
        }
    }
}

int main(int argc, char** argv)
{
    if (argc != 3) {
        std::cerr &lt;&lt; "Usage:  evtstore db-filename nevents\n";
    }
    const char* dbFile = argv[1];
    int         nEvents = strtoul(argv[2], nullptr, 0);

    SpecTclDB::CDatabase db(dbFile);
    SpecTclDB::SaveSet* pSaveSet = db.getSaveSet("a saveset");

    int runId =                      <co id='evtstore.start' />
        pSaveSet-&gt;startRun(1, "Some junk Data", time(nullptr));

    std::vector&lt;int&gt; params;
    std::vector&lt;double&gt; values;
    srand48(time(nullptr));           <co id ='evtstore.init' />
    void* ctx = pSaveSet-&gt;startEvents(runId);  <co id='evtstore.trans' />
    for (int i =0; i &lt; nEvents; i++) {
        params.clear();
        values.clear();             // new event.
        createEvent(params, values);
        pSaveSet-&gt;saveEvent(                   <co id='evtstore.save' />
            runId, i, params.size(), params.data(), values.data()
        );

        if (i %100 == 0) {    // every 100 events commit the transaction.
            pSaveSet-&gt;endEvents(ctx);         <co id='evtstore.commit' />
            ctx  = pSaveSet-&gt;startEvents(runId);
        }

    }
    pSaveSet-&gt;endEvents(ctx);                <co id='evtstore.commit2' />

    pSaveSet-&gt;endRun(runId, time(nullptr));  <co id='evtstore.endrun' />
    delete pSaveSet;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtstore.crevent' >
                    <para>
                        This function creates an event. It
                        takes references to  a pair of vectors.
                        The integer vector is filled in with
                        numbers of parameters that are present
                        while the vector of doubles is filled in
                        whith parameter values for that parameter
                        in this event.
                    </para>
                    <para>
                        There are 100 parameters.  In any given
                        event, there's a 50% chance a parameter is present.
                        The parameter values are uniformly distributed
                        random numbers in the range [-100.0, 100.0)
                        because <function>drand48</function>
                        produces pseudo randoms in the range
                        [0, 1)
                    </para>
                </callout>
                <callout arearefs='evtstore.start' >
                    <para>
                        The <methodname>startRun</methodname>
                        indicates we are starting to store data for a run.
                        Normally this will be intermixed event
                        and scaler data.  For this example, we're
                        only storing events.  The run number must
                        be unique within the save set. The
                        return value is an integer that identifies
                        the run and must be used in most
                        of the methods we'll call in the future.
                    </para>
                    <para>
                        Only a run start time is provided.
                        The assumption is that we are reading data
                        from some serial data source and won't
                        know the end time for the run until
                        we reach data for the end of the run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Our event generator uses the pseudo random number generators.
                        This code ensures those generators are seeded with an
                        undeterministic value.  If you omit this
                        line, the program will still work but the
                        random number generators will be seeded
                        with a deterministic value and the
                        results of each run will be the same
                        from program run to program run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Individual database stores can be expensive.
                        Sqlite provides a mechanism for batching up
                        a bunch of stores into an atomic
                        <firstterm>transaction</firstterm>, these
                        transactions are called savesets.  
                    </para>
                    <para>
                        This line starts a transaction for storing
                        events and gets a <type>void*</type>
                        back which we call a context.
                        The context identifies the transaction
                        suc that it can be rolled back or committed
                        by the code at a later date.
                    </para>
                </callout>
                <callout arearefs='evtstore.save' >
                    <para>
                        This line saves an event. The
                        <methodname>data</methodname> method of
                        <classname>std::vector</classname> returns
                         a pointer to the contiguous storage used by the
                         event for he current transaction.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit' >
                    <para>
                        Every 100 events, we commit the
                        transaction we started with our call to
                        <methodname>startEvents</methodname>.
                    </para>
                    <para>
                        It is also possible to decide not to
                        store any events from a transaction
                        but doing that is beyond the scope of this
                        example.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit2' >
                    <para>
                        Performs the commit for any partial
                        block of events.
                    </para>
                </callout>
                <callout arearefs='evtstore.endrun' >
                    <para>
                        Closes off the run by providing the
                        end run time.
                    </para>
                </callout>
            </calloutlist>
            <para>
                The next program will read the event data
                we stored in the previous example and dump
                every 50 events to stdout. Note that the
                parameter numbers are intended to be the
                <parameter>number</parameter> parameter
                passed to the <methodname>createParameter</methodname>
                method in the database.  In SpecTcl these
                correspond to parameter ids, slots in the
                <classname>CEvent</classname> object passed
                between the members of the event processing
                pipeline.  
            </para>
            <para>
                In SpecTcl, using <classname>CTreeParameter</classname>
                and <classname>CTreeParameterArray</classname> objects
                hides but does not eliminate this parameter number.
                What this number is <emphasis>not</emphasis>
                is the value of the primary key of a parameter
                definition.
            </para>
            <example>
                <title>Recovering event data (evtget.cpp)</title>

                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


// accept data:
                    <co id='evtget.sink' />
void sink(const SpecTclDB::SaveSet::Event&amp; event)
{
    static int evt = 0;
    if ((evt % 50) == 0) {
      std::cout &lt;&lt; "Dumping event " &lt;&lt; evt &lt;&lt; ":\n";
        for (int i =0; i &lt; event.size(); i++)  {
            std::cout &lt;&lt; "   param# " &lt;&lt; event[i].s_number
                &lt;&lt; " = " &lt;&lt; event[i].s_value &lt;&lt; std::endl;
        }
    }
    evt++;
}


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: evtget db-filename\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSet = db.getSaveSet("a saveset");

    int runid = pSet-&gt;openRun(1);    <co id='evtget.open' />
    void* ctx = pSet-&gt;openEvents(runid); <co id='evtget.evts' />

    SpecTclDB::SaveSet::Event event;
    while(pSet-&gt;readEvent(ctx, event)) {  <co id='evtget.read' />
        sink(event);
    }

    pSet-&gt;closeEvents(ctx);     <co id='evtget.close' />
    delete pSet;

    exit(EXIT_SUCCESS);
}

                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtget.sink' >
                    <para>
                        This function is a stand in for whatever
                        processing you might do on events.
                        For our toy example, it just dumps the
                        data from every 50'th event.
                    </para>
                </callout>
                <callout arearefs='evtget.open' >
                    <para>
                        <methodname>openRun</methodname>
                        accepts a run number and returns the
                        id (primary key) identifying that run
                        in the database.  This can be used in other
                        calls to retrive information about
                        event data and scalers.
                    </para>
                </callout>
                <callout arearefs='evtget.evts' >
                    <para>
                        Getting events back from the database
                        requires iteration through the result set
                        from a query.  Doing this requires
                        that some context allowing the result set to be
                        identified must be held and saved.
                        <methodname>openEvents</methodname> performs
                        the query for the events that belong to the
                        run and returns a context that refers to the
                        result set.
                    </para>
                </callout>
                <callout arearefs='evtget.read' >
                    <para>
                        <methodname>readEvent</methodname>
                        takes the result set context gotten above
                        and fills in the <parameter>event</parameter>
                        parameter with the next event for that
                        run in the database.
                    </para>
                    <para>
                        As we've seen from the previous example
                        (<filename>evtstore.cpp</filename>),
                        parameters in an event can form a sparse set.
                        The data stored for an event only consists of the
                        parameters that have data for that event.
                        <methodname>readEvents</methodname> fills
                        in an indexable container (<classname>Event</classname>)
                        which contains the parameter numbers and
                        parameter values for parameters with data
                        for an event.
                    </para>
                    <para>
                        note that this can be trivially turned into
                        a <classname>CEvent</classname> object
                        by SpecTcl. With a bit of a table lookup
                        it can also be trivially marshalled into a root tree
                        leaf.
                    </para>
                </callout>
                <callout arearefs='evtget.close' >
                    <para>
                        <methodname>closeEvents</methodname>
                        releases all resources that were associated
                        with the result set gotten from
                        <methodname>openEvents</methodname>.
                    </para>
                </callout>
            </calloutlist>
            <para>
                In addition to storing decoded event data, the
                database schema supports storing and retrieving
                the results of scaler reads.  The next pair of
                examples exercise this capability.
            </para>
            <example>
                <title>Storing scaler readouts (sclstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;


std::vector&lt;uint32_t&gt; getScalers()  <co id='sclstore.produce' />
{
    static uint32_t       chan1 = 0;
    std::vector&lt;uint32_t&gt; result;
    for (int i = 0; i &lt; 32; i++) {
        result.push_back(chan1*i);
    }

    chan1++;
    return result;
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage: sclstore database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    time_t now =time(nullptr);
    int offset = 0;
    int runid = pS-&gt;startRun(2, "This is run 2", now);

    // simulate Read every 10 seconds 100 times:

    for (int i = 0; i &lt; 100; i++) {   <co id='sclstore.save' />
        now += 10;
        auto scalers = getScalers();
        pS-&gt;saveScalers(
            runid, 1, offset, offset+10, 1, now, 32, scalers.data()
        );
        offset += 10;
    }
    pS-&gt;endRun(runid, now);

    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <para>
                We've already seen show to record the start and
                end of run information, therefore, we won't
                repeat that discussion here.
            </para>
            <calloutlist>
                <callout arearefs='sclstore.produce' >
                    <para>
                        We need something to generate our scaler
                        data.  normally, these will come from ring items.
                        In SpecTcl event processors, the
                        <methodname>OnOther</methodname> method allows you to
                        catch and process scaler data.  SpecTcl's
                        code to write event data to the database h as an
                        implementation for this method that decodes
                        the scaler ring item and writes it to the
                        database.
                    </para>
                    <para>
                        In this case, since we are just writing a
                        sample program, we'll just generate 32
                        scaler values that change somewhat each time.
                    </para>
                </callout>
                <callout arearefs='sclstore.save' >
                    <para>
                        This loop simulates the scaler readouts
                        for a run that's 1000 seconds long with scaler
                        readouts every 10 seconds.
                        <methodname>saveScalers</methodname> takes
                        the run Id to associate the scalers with the
                        correct run.  It also takes two offset
                        values representing the start and end time into
                        the run over which the scalers counted.
                        The next parameters is a divisor. If you
                        divide the start and end times by the
                        divisor you should get the number of seconds
                        into the run for each of those values. This supports
                        offsets that have sub-second precision.
                        Following the divisor is a clock timestamp
                        indicating when this read took place.
                        The final pair of parameters is the
                        number of scalers and a pointer to them.
                    </para>
                </callout>
            </calloutlist>
            <example>
                <title>Recovering scaler readouts (sclget.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

                       <co id='sclget.process' />
void processScalers(const SpecTclDB::SaveSet::ScalerReadout&amp; readout)
{
    double start = readout.s_startOffset;
    start /= readout.s_divisor;
    double end   = readout.s_stopOffset;
    end   /= readout.s_divisor;
    std::cout &lt;&lt; "Scaler readout: Sid: " &lt;&lt; readout.s_sourceId
              &lt;&lt; " from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; " seconds into the run \n                  ";
    std::cout &lt;&lt; "Readout occured at: " &lt;&lt; ctime(&amp;readout.s_time) &lt;&lt; std::endl;

    for (int i =0; i &lt; readout.s_values.size(); i++) {
        std::cout &lt;&lt; "   channel " &lt;&lt; i &lt;&lt; " : " &lt;&lt; readout.s_values[i] &lt;&lt; std::                  endl;
    }
    std::cout &lt;&lt; "------------------------------\n";
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: sclget database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    int runid = pS-&gt;openRun(2);
    auto info = pS-&gt;getRunInfo(runid);   <co id='sclget.runinfo' />
    std::cout &lt;&lt; "Dumping scalers for run: " &lt;&lt; info.s_runNumber &lt;&lt; std::endl;
    std::cout &lt;&lt; "Title: " &lt;&lt; info.s_title &lt;&lt; std::endl;
    std::cout &lt;&lt; "Start time: " &lt;&lt; ctime(&amp;info.s_startTime) &lt;&lt; std::endl;
    std::cout &lt;&lt; "End time  : " &lt;&lt; ctime(&amp;info.s_stopTime) &lt;&lt; std::endl;

    void* ctx = pS-&gt;openScalers(runid);  <co id='sclget.open' />
    SpecTclDB::SaveSet::ScalerReadout scalers; <co id='sclget.read' />
    while(pS-&gt;readScaler(ctx, scalers)) { 
        processScalers(scalers);
    }

    pS-&gt;closeScalers(ctx);              <co id='sclget.close' />


    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='sclget.process' >
                    <para>
                        This function is a stand-in for any processing you
                        might want to do on a scaler readout.
                        In this case we just output information
                        about the scaler read and the channel
                        values to <literal>stdout</literal>.
                    </para>
                </callout>
                <callout arearefs='sclget.runinfo' >
                    <para>
                        The <methodname>getRunInfo</methodname>
                        method fetches top level information
                        about the run given its id
                        (gotten from <methodname>openRun</methodname>).
                        The run number, title, start and stop time
                        are elements of the
                        <type>SpecTclDB::SaveSet::RunInfo</type>
                        struct this method returns.
                    </para>
                </callout>
                <callout arearefs='sclget.open' >
                    <para>
                        As with getting events from the database,
                        scaler readout information is gotten by
                        iterating over the result set from a
                        query executed on the database.
                        <methodname>openScalers</methodname> executes
                        the query and returns a context that
                        can be used to iterate over the result set
                        from that query.
                    </para>
                </callout>
                <callout arearefs='sclget.read' >
                    <para>
                        The <methodname>readScaler</methodname>
                        gets the next result from the result set
                        indicated by the context parameter.
                        The information in that result are loaded
                        into the <type>SpecTclDB::SaveSet::ScalerReadout</type>
                        struct passed to it (by reference).
                    </para>
                    <para>
                        The return value of <methodname>readScaler</methodname>
                        is non zero if there was another result or
                        zero if there was no next result set
                        item.
                    </para>
                    <para>
                        All we do with the data gotten from
                        the database is call
                        <function>processScalers</function>.
                    </para>
                </callout>
                <callout arearefs='sclget.close' >
                    <para>
                        Once you are done iterating over the
                        result set, you must free the resources associated
                        with the context.   This is done by
                        calling <methodname>closeScalers</methodname>
                        passing the context.
                    </para>
                    <para>
                        It is not legal to use the context again, once
                        it has been closed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        
    </chapter>
    <chapter>
        <title>SpecTcl classes that record event data</title>
        <para>
            The database can hold event and scaler data associated
            with a run. These data are placed in a saveset. SpecTcl
            records at most one run per saveset and includes in that
            save set, the analysis conditions in effect at the time
            the run was analyzed.
        </para>
        <para>
            This also allows data from a run to be recorded more than
            once, using differing analysis configurations.
        </para>
        <para>
            This section describes the classes used by SpecTcl
            to record event data.  Note that in most cases, you don't
            need to use these classes.  They are instantiated
            by the SpecTcl database GUI and automatically
            placed in the analysis and data sink piplines as
            requested.
        </para>
        <para>
            These classes are organized into two layers.
            The lowest layer provides an interface between
            runs and the database API.  The upper layer provides
            an interface between SpecTcl's flow of control
            and the lower layer.
        </para>
        <para>
            The lower layer's header is <filename>CDBEvents.h</filename>.
            The upper layer's header is <filename>Events.h</filename>.
        </para>
        <section>
            <title>Lower layer of SpecTcl's event recording/playback code.</title>
            <para>
                The lower layer of SpecTcl's event recording
                and playback system consists of a pair of classes.
                <classname>CDBEventWriter</classname>, as the
                name implies, is used to record unpacked parameters and
                scalers to the database.
                <classname>CDBEventPlayer</classname>, as its name
                implies is used to read event data back from the
                database for a run in a save set.
                <classname>CDBEventPlayer</classname> only reads
                event data.  It does not read scaler data. The
                Tcl SpecTcl interface, however, has a mechanism
                to test for the existence of scaler data and recover
                it for a run in a saveset.
            </para>
            <para>
                <classname>CDBEventWriter</classname>
                the following methods of interest:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>beginRun</methodname>
                       <methodparam>
                           <type>const RingItem* </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method must be the first one called
                        to start recording a run. It provides
                        a ring item, which must be a
                        <literal>BEGIN_RUN</literal> item.
                        It records information about the run
                        and the start time of the run
                        using data in the ring item.
                       </para>
                       <para>
                        This method handles multiple begin runs
                        (as happens in event built data) by only
                        saving information from the first
                        call.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>endRun</methodname>
                       <methodparam>
                           <type>const RingItem*   </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method should be called when
                        end of run rinng items are available.
                        Note that the code is able to detect
                        multiple ends per run (as will be the
                        case in event built data) and, as with
                        the <methodname>beginRun</methodname>
                        call only saves information from the first one.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>scaler</methodname>
                       <methodparam>
                           <type>const RingItem*   </type><parameter>pScaler</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The <parameter>pScaler</parameter> parameter
                         must be a <literal>PERIODIC_SCALER</literal> ring item.
                         I is added to the scaler readouts for the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>event</methodname>
                       <methodparam>
                           <type>CEvent*      </type><parameter>pEvent</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds an event to the database. Note that
                        events are added in bunches for the sake of
                        efficiency.  The bunch size is set at
                        construction time and has a default value
                        that's believed to be reasonable.
                       </para>
                       <para>
                        The <parameter>pEvent</parameter> is a pointer
                        to the object that contains unpacked data from
                        SpecTcl.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>setAutoSaveSpectra</methodname>
                       <methodparam>
                           <type>const std::vector&lt;std::string&gt;&amp;</type>
                           <parameter>spectra</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The SpecTcl code that manages saving events to the database
                        provides the capability for automatically saving the contents
                        of a set of spectra at the end of the run.
                        THese spectra are referred to as
                        <firstterm>autosaved spectra</firstterm>.
                       </para>
                       <para>
                        This method sets the names of the spectra that will be
                        autosaved from <parameter>spectra</parameter>.
                        Any spectra previously deisgnated as autosaved
                        are no longer autosaved (unless they are in the
                        <parameter>spectra</parameter> parameter).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>addAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char*</type><parameter> name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds the spectrum named by <parameter>name</parameter>
                        to the list of autosaved spectra.  Existing autosaved
                        spectra are not removed from the list.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>removeAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char* </type><parameter>name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        If the spectrum named <parameter>name</parameter>
                        is in the auto saved list, it is removed from
                        that list.  All other spectra in that list
                        are not affected.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>std::vector&lt;RunInfo&gt; </type>
                       <methodname>listRuns</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns information about all runs saved in the
                        database. The run information includes the
                        name of the saveset it was recorded in.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>CDBEventPlayer*</type>
                       <methodname>playRun</methodname>
                       <methodparam>
                           <type>int</type><parameter>run</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Locates the first saveset that has the
                        requested <parameter>run</parameter> recorded in it
                        and creates a playback object for that
                        run.
                       </para>
                       <para>
                        See the description of <classname>CDBEventPlayer</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                To play back data the low level code supplies
                a <classname>CDBEventPlayer</classname>. This
                is constructed on a saveset and  the run number
                of a save set that's known to be stored in
                that saveset.
            </para>
            <para>
                The following methods are then available:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>const SpecTclDB::SaveSet::Event&amp; </type>
                       <methodname>next</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns a reference to the next event in the
                        run.  This will be an empty event if you attempt
                        to read past the last event. Note that
                        the writer class does not write empty events to the
                        database.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns the run's title string.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Upper layer of SpecTcl's event recording/playback code.</title>
            <para>
                The upper layer of SpecTcl event recording/playback code
                consists of a pair of objects that interface into
                SpecTcl's analysis system.  Specifically,
                <classname>CDBProcessor</classname> is used
                to write run starts stops and scalers to the
                database.  It is an <classname>CEventProcessor</classname>
                and will be added to the event processing pipeline
                <classname>CDBSink</classname>, on the other hand
                is a <classname>CEventSink</classname> and will be added
                to the event sink pipline.  By the time the event sink pipline
                is executed for an event, the event has been fully decoded and
                can be written to the database.
            </para>
        </section>
    </chapter>
    <chapter>
       <title>Tcl bindings to the C++ API</title>
       <para>
        The Tcl bindings to the C++ API closely mimic the C++
        API.  Tcl is a command based language. The C++ API is object
        oriented.  The standard way to do object oriented programming
        or present object oriented APIs is through
        <firstterm>command ensembles</firstterm>.
       </para>
       <para>
        A Tcl command ensemble is a command with subcommands.
        You can think of a command as a class or an object and
        the subcommand as methods (class or object level).
        You can imagine a Tcl command that represents a class.
        It might have construction subcommand that would dynamically
        generate a new command ensemble that represents an object.
        This is the approach taken by the Tcl bindings.
       </para>
       <para>
        The Tcl bindingsx are in a package called
        <literal>SpecTclDB</literal> which is stored in the
        SpecTcl Tcl package library.  There are two ways to bring that
        library directory tree into the Tcl package search path:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Via an environment variable.  For example, suppose
              the environment variable SPECTCLHOME is defined and is the
              top level directory in which the version of SpecTcl
              you are using is stored.
              <command>TCLLIBPATH=$SPECTCLHOME/TclLibs tclsh</command>
              will run a Tcl shell that includes the SpecTcl Tcl library tree
              in the search path.
           </para>
        </listitem>
        <listitem>
           <para>
              Extension of the the Tcl <varname>auto_path</varname>
              variable.  Suppose, as before SPECTCLHOME is defined
              to be the top level installation directory of your SpecTcl
              version, the following script fragment will bring the
              SpecTcl Tcl packages into your search path.
           </para>
           <informalexample>
            <programlisting>
lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
            </programlisting>
           </informalexample>
           <para>
            The global <varname>env</varname> array contains
            the values of environment variables indexed by variable
            name.  The <command>file join</command> command joins file
            system path elments and <command>lappend</command>
            appends items to a list, in this case the
            <varname>auto_path</varname> search list.
           </para>
        </listitem>
       </orderedlist>
       <para>
        Our examples will use the second form.  They will mirror
        closely the examples in the C++ API section.  The examples
        are deployed in the <filename>share/dbexamples</filename>
        directory.
       </para>
       <example>
        <title>Creating an empty database in Tcl (makedb.tcl)</title>
        <programlisting>
#!/bin/sh       <co id="makedb.tcl.boilerplate" />
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs] <co id='makedb.tcl.autopath' />
package require SpecTclDB                   <co id='makedb.tcl.require' />

if {[llength $argv] != 1} {                 <co id='makdeb.tcl.args' />
    puts stderr "Usage: makedb.tcl database-file"
    exit -1
}

DBTcl create [lindex $argv 0]           <co id='makedb.tcl.create' />

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='makedb.tcl.boilerplate' >
            <para>
                This bit of boilerplate is a recommended way to prefix
                executable Tcl scripts.  It starts the
                <command>/bin/sh</command> shell, which is almost always
                a legal shell and then some continuation line
                magic executes the Tcl interpreter passing the
                file back to itself as a parameter.  The
                <literal>\</literal> in the line before the
                <command>exec</command> command ensures that line
                is not seen by the Tcl intepreter as it continues the
                comment line.  The Tcl interpreter then continues
                to interpret the script in the remainder of the file.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.autopath' >
            <para>
                As described previously, this line appends the
                SpecTcl Tcl library directory tree to the
                <command>package require</command> search path.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.require' >
            <para>
                Brings the <literal>SpecTclDB</literal> package into the
                script. This defines the command ensemble that
                makes up the package.
            </para>
        </callout>
        <callout arearefs='makdeb.tcl.args' >
            <para>
                The <varname>argv</varname> list contains
                the command parameters that follow the command.
                Note that the command itself is not included. 
            </para>
        </callout>
        <callout arearefs='makedb.tcl.create' >
            <para>
                Creates the database file specified by the first
                command argument and initializes it to contain the
                SpecTcl database Schema.
            </para>
        </callout>
       </calloutlist>
       <para>
        The next example shows how to make a save set in an
        existing database file. We'll learn how to form a connection
        to a database and what that means. We'll then use that
        connection to create a new saveset.
       </para>
       <example>
        <title>Creating savesets in a database (makesaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {    <co id='mkset.catch' />
    set db [DBTcl connect [lindex $argv 0]]  <co id='mkset.connect' />
    set saveset [$db createSaveset "a saveset"] <co id='mkset.crset' />
    $saveset destroy                         <co id='mkset.destroy' />
    $db      destroy
} msg]

if {$status} {
    puts "Error: $msg"       <co id='mkset.errors' />
    exit -1
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='mkset.catch' >
            <para>
                This program demontsrates very simple error handling.
                The Tcl <command>catch</command> command
                performs the commands in the script passed as its
                first argument.  If there is an error, it returns
                1, if not, 0.  This value is captured in the
                <varname>status</varname> variable.
            </para>
            <para>
                The optional second argument to <command>catch</command>
                is the name of a variable.  If the command is successful,
                this will hold the result of the script.  If not,
                it will hold the error message associated with the
                failure.
            </para>
        </callout>
        <callout arearefs='mkset.connect' >
            <para>
                The <command>DBTcl connect</command> command
                creates a new command ensemble that can perform
                operations on the database file passed to the
                <command>DBTcl connect</command> command.
                This is analagous to constructing a new  object.
                The subcommands of the command captured in the
                <varname>db</varname> variable are analogous to
                object methods.
            </para>
            <para>
                This command ensemble is referred to as a
                <firstterm>data base instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.crset' >
            <para>
                Similarly the <command>createSaveset</command>
                subcommand of the databae instance command
                creates a new save set and returns another
                newly created command ensemble whose ensemble
                commands operate on the save set. As you might imagine,
                this command, captured in the <varname>saveset</varname>
                varible is called a <firstterm>saveset instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.destroy' >
            <para>
                All instance commands have a <command>destroy</command>
                ensemble command.  This destroys the command and
                releases any resources it might have.  This command
                is analogous to a destructor method
            </para>
        </callout>
        <callout arearefs='mkset.errors' >
            <para>
                This part of the script executes if any errors
                are detected by the <command>catch</command>
                command.  To see what it does, try running
                the script twice on the same database.  The secone
                time the attempt to make a saveset will fail
                because the save set already exists.
            </para>
        </callout>
       </calloutlist>
       <example>
        <title>Listing savesets in a database (lssaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]

    puts "Savesets in [lindex $argv 0]"

    foreach name [$db listSavesets] {  <co id='lssavesets.tcl.list' />
        puts $name
    }
    $db destroy
} msg]

if {$status} {
    puts "Error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='lssavesets.tcl.list' >
            <para>
                The <command>listSavesets</command> subcommand
                of the database instance command returns a
                properly formatte Tcl list of savesets contained
                by that database. This
                <command>foreach</command> loop outputs them
                to stdout.
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining parameters (pardef.tcl)</title>
            <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: pardef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]   <co id='pardef.tclgetsaveset' />
    
    $saveset createParameter p1 100            <co id='pardef.tclcreate' />
    $saveset createParameter p2 101 -10.0 10.0 100 "cm"
    
    puts "Parameters defined:"
    foreach param [$saveset listParameters] {  <co id='pardef.tcllist' />
        puts [dict get $param name]
    }
    
    $saveset destroy                            <co id='pardef.tcldestroy' />
    $db destroy
} msg]


if {$status} {
    puts stderr "error: $msg"
}                
            </programlisting>
       </example>
       <para>
        This example program creates two parameters named
        <literal>p1</literal> and <literal>p2</literal>.
        Parameter <literal>p2</literal> has full metadata.
        After creating the parameters the names of all parameters
        in the saveset are listed to stdout.
       </para>
       <calloutlist>
        <callout arearefs='pardef.tclgetsaveset' >
            <para>
                The <command>getSaveset</command> subcommand of
                a database instance command ensemble, looks up the
                named save set (in this case <literal>a saveset</literal>)
                and, if found creates a command ensemble that can
                manipulate that saveset.  If the saveset does not exist,
                an error is thrown.
            </para>
            <para>
                The command ensemble that
                <command>getSaveset</command> produces, is called a
                <firstterm>save set instance command</firstterm> and
                is captured in the <varname>saveset</varname>
                variable.
            </para>
        </callout>
        <callout arearefs='pardef.tclcreate' >
            <para>
                The <command>createParameter</command> subcommand
                of the saveset instance command ensemble creates
                new parameter definitions in the databsase.
                Mirroring SpecTcl, there are two types of parameters that
                can be created.  Raw parameters make a correspondence between
                parameter name and parameter number (in SpecTcl, parameter number
                is the index into a <classname>CEvent</classname>)
                object at which the parameter should be stored and retrieved.
                Tree parameters have additional metadata.
            </para>
            <para>
                The first command creates a raw parameter named
                <literal>p1</literal>.
                The second command creates  a tree parametr with
                metadata.  The metadata provides hints to both the
                user and SpecTcl GUI scripts about how to define axes
                of spectra that depend on this parameter.
                In this case a range of [-10.0..10.0) with 100 bins
                is recommended.  In addition, the units of measure
                of the parameter are documented as centimeters
                (<literal>cm</literal>).
            </para>
        </callout>
        <callout arearefs='pardef.tcllist' >
            <para>
                The <command>listSpectrum</command> subcommand
                of a save set instance command ensemble creates
                a Tcl list of dicts that describe the spectra
                that have been defined in the saveset.  The keys of the
                dict are:
                <variablelist>
                    <varlistentry>
                       <term><literal>id</literal></term>
                       <listitem>
                           <para>
                            Contains an integer that is the primary key of the
                            spectrum in the spectrum definition table.
                            This is useful in programs that may do ad-hoc
                            queries of the database for advanced
                            applications.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                            Text string that is the name of the parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>number</literal></term>
                       <listitem>
                           <para>
                            THe number of the parameter.  This differs from the
                            <literal>id</literal> key. It's a value that
                            the program supplies, rather than a value
                            assigned by the database engine.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>low</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree
                            parameters. It's the recommended low limit of spectrum
                            axes defined on this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>high</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.
                            It is the recommended high limit for axes defined
                            on this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>bins</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.  It is
                            the recommended number of bins on axes defined on
                            this parameter.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>units</literal> (optional)</term>
                       <listitem>
                           <para>
                            This key is only present for tree parameters.  It is
                            the units of measure defined for the parameter.
                            Note that an empty string is perectly allowed an usually
                            means the parameter is unit-less (e.g. raw ADC
                            values).
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </callout>
        <callout arearefs='pardef.tcldestroy' >
            <para>
                Because the saveset instance command is dynamically
                created by the database instance command, when you are done
                with it you should destroy it and the resources associated with it.
                The <command>destroy</command> subcommand does this
                just as it also destroys database instance commands and
                their associated resources.
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining Spectra (specdef.tcl)</title>
            <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: specdef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset createSpectrum s1 1 p1 [list [list 0 1023 1024]]  <co id='specdef.tcl.cr1d' />
    $saveset createSpectrum s2 2  \                            <co id='specdef.tcl.cr2d' />
        [list p1 p2] [list [list 0 1023 1024] [list -10.0 10.0 100]]
    
    puts "Spectra in saveset:"
    foreac spectrum [$saveset listSpectra] {   <co id='specdef.tcl.list' />
        puts [dict get $spectrum name]
    }
} msg]

$saveset destroy
$db destroy

if {$status} {
    puts stderr "error: $msg"
}                
            </programlisting>
       </example>
       <para>
        This example creates a 1d and a 2d spectrum named
        <literal>s1</literal> and <literal>s2</literal>
        respectively.
       </para>
       <calloutlist>
        <callout arearefs='specdef.tcl.cr1d' >
            <para>
                The <command>createSpectrum</command> saveset instance
                subcommand creates spectrum definitions in the database.
                This command takes several parameters;
                A spectrum name, the a type code for the spectrum type,
                a list of parameters needed by the spectrum,
                a list of axis definitions and an optional
                channel data type.
            </para>
            <para>
                In the sample command, the spectrum name is
                <literal>s1</literal>. The spectrum type code,
                <literal>1</literal> means that the spectrum is
                a 1-d spectrum.  <literal>p1</literal> is a single
                element Tcl list that says the spectrum increments
                the <literal>p1</literal> value for each event in which
                it is defined.  Note that had the spectrum type been
                <literal>s</literal> (summary spectrum), or
                <literal>g1</literal> (gamma 1-d) this parameter
                list would, in general contain additional parameter
                names.  After the parameter is a list of axis definitions.
                Each axis definition, in turn is a three element list containing
                the axis low limit, high limit and number of bins
                in that order.  Thus <literal>p1</literal> will have an
                axis that runs from 0 to 1023 and has 1024 channels.
            </para>
            <para>
                By default, SpecTcl spectra contain longword (32 bit)
                channel values.  The <command>createSpectrum</command>
                subcommand also uses this as the default channel datatype.
                You can explicitly provide a data type as an additional command
                parameter.  This additional parameter can have one
                of the following values:
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>byte</literal></term>
                   <listitem>
                       <para>
                        Channels will be 8 bit values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>word</literal></term>
                   <listitem>
                       <para>
                        Channels will be 16 bit values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>long</literal></term>
                   <listitem>
                       <para>
                         Channels will be 32 bit values
                    </para>
                 </listitem>
                </varlistentry>
            </variablelist>
        </callout>
        <callout arearefs='specdef.tcl.cr2d' >
            <para>
                This command creates a 2-d spectrum.  The principles are the
                same as the previous command, but two parameters
                (x and y axis in that order) are provided as are two
                axes (x and y axis in that order).
            </para>
        </callout>
        <callout arearefs='specdef.tcl.list' >
            <para>
                The <command>listSpectra</command> subcommand
                returns a Tcl list whose entries describe the spectra defined in the
                saveset.  Each list item is dict that describes
                a single spectrum.  The dicts have the following
                key/value pairs:
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        The primary key of the spectrum in the top level
                        spectrum definition table.  This is really not
                        useful to Tcl scripts that only use the API.
                        It can be useful to scripts that also do ad-hoc
                        queries of the database (e.g. via the sqlite3
                        package).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal></term>
                   <listitem>
                       <para>
                        Name of the spectrum.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>type</literal></term>
                   <listitem>
                       <para>
                        The spectrum type code.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>parameters</literal></term>
                   <listitem>
                       <para>
                        The list of parameters the spectrum depends on.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>axes</literal></term>
                   <listitem>
                       <para>
                        List of axis definitions for each of the
                        free defined axes of the spectrum. Note that
                        each axis definition is a three element list containing
                        in order, the axis low limit, high limit and
                        number of bins.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>datatype</literal></term>
                   <listitem>
                       <para>
                        The data type code as described above.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <para>
        As with the C++ API, there are a family of subcommands that
        create gates of different types.  The sample script below
        creates several types of gates.
       </para>
       <example>
        <title>Defining gates (gatedef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: gatedef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset create1dGate slice  s p1 100 200    <co id='gatedef.tcl.1d' />
    $saveset create2dGate contour c [list p1 p2] \ <co id='gatedef.tcl.2d' />
        [list {100 10} {200 100} {200 200} {100 200} ]
    $saveset createCompoundGate and * [list slice contour] <co id='gatedef.tcl.compound' />
    $saveset createMaskGate  mask em p1 0x55555555 <co id='gatedef.tcl.mask' />
    
    puts "Gates in saveset:"
    foreach gate [$saveset listGates] {    <co id='gatedef.tcl.list' />
        puts [dict get $gate name]
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='gatedef.tcl.1d' >
            <para>
                Creates a 1d gate.  1d Gates are gates that have a single
                low and high limit defining a slice in some 1-d space.
                The <command>create1dGate</command> subcommand takes 5
                additional parameters.  The name (<literal>slice</literal>),
                the gate type (<literal>s</literal>) the list of
                parameters the gate is checked against (<literal>p1</literal>),
                note that there are 1d gates that can have more than one
                parameter; gamma slices <literal>gs</literal> for example.
                The final two parameters are the low and high limits of the
                gate.
            </para>
            <para>
                Note that the gate limits for this and all gates with
                limits are in raw parameter coordinates.  There is often
                a temptation to believe that since gates are clicked on
                on spectra they are accepted in spectrum coordinates.
                This is not the case.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.2d' >
            <para>
                Creates a 2-d gate.  With the exception of the gate limits,
                this subcommand takes the same parameters as
                <command>create1dGate</command>.  However, instead of two limit parameters,
                the command takes on parameter that is a list of
                X/Y  pairs that define a figure in some 2-d space of
                parameters.  In the example, the gate is a contour,
                which is a closed figure.  The coordinates are that of a square.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.compound' >
            <para>
                Creates a compound gate.  A compound gate is one whose
                truth or falsity only depends on the truth or falsity of other
                gates.  The form of the <command>createCompoundGate</command>
                subcommand calls for a gate name, a gate type and a list
                of the gates the compound depends on.  
            </para>
            <para>
                In this example a new gate <literal>and</literal>
                is created that is an and gate (type <literal>*</literal>)
                that depends on the gates <literal>slice</literal>
                and <literal>contour</literal>.  This gate will only be true
                of both gates are true in an event.
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.mask' >
            <para>
                Creates a mask gate.  Mask gates assume their parameter
                is actually an integer and perfrom some bitwise
                operation and comparison on it.  The
                <command>createMaskGate</command> subcommand
                requires a gate name (<literal>mask</literal>),
                a gate type (<literal>em</literal> mask and compare for equality),
                and a bitmask (<literal>0x55555555</literal>).
            </para>
        </callout>
        <callout arearefs='gatedef.tcl.list' >
            <para>
                The <command>listGates</command> command returns
                a list of dicts that describe the gates saved in the saveset.
                Each gate is described by a dict.  Interpreting this
                dict requires knowing the type of gate as the
                set of keys provided dpends on the type of gate.
                The dict introduces the concept of a
                <firstterm>gate classification</firstterm> which
                defines the set of keys a gate will have.
            </para>
            <para>
                Here's list of the gates an when they are present.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>classification</literal> (all)</term>
                   <listitem>
                       <para>
                        Gives the gate classification. All gates
                        will be one of <literal>point</literal>,
                        <literal>compound</literal>, or
                        <literal>mask</literal> gates.
                        In the keys below, after the key term parenthesized
                        text will describe which keys are present in which
                        clasifications.  Note that
                        (all) as in above means that all classification
                        types have this key.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>id</literal> (all)</term>
                   <listitem>
                       <para>
                        The primary key in the top level table
                        used to define gates.  This is normally
                        not useful to programs that use only this
                        Tcl API. It can be useful if a script also
                        uses e.g. sqlite3 to perform arbitrary
                        queries of the database.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal> (all)</term>
                   <listitem>
                       <para>
                        The name of the gate.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>type</literal> (all)</term>
                   <listitem>
                       <para>
                        The gate type code string.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>parameters</literal> (point, mask)</term>
                   <listitem>
                       <para>
                        The parameters that are checked by the gate.
                        Note that mask gates only have one parameter.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>gates</literal> (compound)</term>
                   <listitem>
                       <para>
                        The names of the gates this gate depends on
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>points</literal> (point)</term>
                   <listitem>
                       <para>
                        A list of two element sub lists.  Each element
                        is a point in the gate.  For 1d gates, the
                        Y coordinate is meaningless and there will only be
                        two points. For 2-d gates, the X and Y coordinate are both
                        meaningful and there can be be an arbitrary number
                        of points.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>mask</literal> (mask)</term>
                   <listitem>
                       <para>
                        The bitmask for a mask gate.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Applying gates to spectra (applydef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: applydef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]
    
    $saveset applyGate slice s2  <co id='applydef.tcl.apply' />
    
    foreach app [$saveset listApplications] { <co id='applydef.tcl.list' />
        set gate [dict get $app gate]
        set spec [dict get $app spectrum]
        puts "$gate is applied to $spec"
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}            
        </programlisting>
       </example>
       <para>
        Gates are objects that are totally passive unless
        <firstterm>applied</firstterm> to a spectrum.  When applied to a spectrum,
        a gate conditionalizes the normal incrementation of that spectrum.
        If a gate is applied to a spectrum, the spectrum will only be
        incremented if the gate is true.
       </para>
       <calloutlist>
        <callout arearefs='applydef.tcl.apply' >
            <para>
                The <command>applyGate</command> subcommand
                takes a gate name and a spectrum name in that order.
                The gate is entered in the database as being applied to the
                spectrum.
            </para>
        </callout>
        <callout arearefs='applydef.tcl.list' >
            <para>
                The <command>listApplications</command> subcommand returns a list
                whose elements are dicts. Each dict describes a
                gate application and has the following keys.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        Contains the primary key of the application in the
                        gate applications table.  This is only useful for
                        ad-hoc queries of the database performed by
                        by e.g. the sqlite3 package.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>gate</literal></term>
                   <listitem>
                       <para>
                        The name of the gate
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>spectrum</literal></term>
                   <listitem>
                       <para>
                        The spectrum to which that gate is being applied
                        in this entry.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Saving and recovering tree variables (vardef.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: vardef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]

    $saveset createVariable slope 1.23 KeV/lsb <co id='vardef.tcl.make' />
    $saveset createVariable offset 10  KeV
    $saveset createVariable gainmatch 1.23    <co id='vardef.tcl.unitless' />
    
    puts "Tree variables: "
    foreach var [$saveset listVariables] {    <co id='vardef.tcl.list' />
        set name [dict get $var name]
        set val  [dict get $var value]
        set units [dict get $var units]
        
        puts "$name : $val$units"
    }
    
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}            
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='vardef.tcl.make' >
            <para>
                The <command>createVariable</command> subcommand creates a new
                tree variable definition.  The command requires
                a name, a value and optionally units of measure.
            </para>
            <para>
                This and the next line of code create a pair of variables that might
                be used to do an energy calibration of a parameter.  The units
                of measure clearly show what the units of the calibrated parameter
                will be; KeV.
            </para>
        </callout>
        <callout arearefs='vardef.tcl.unitless' >
            <para>
                If the variable has no units of measure, you can leave the units
                parameter out.  In that case the actual value of the
                units of measure for the variable will look like an
                empty string.
            </para>
        </callout>
        <callout arearefs='vardef.tcl.list' >
            <para>
                The <command>listVariables</command> subcommand
                returns a list of dicts that describe the tree variables saved in
                this saveset.  Each list element is a dict that
                contains the following key/value pairs.
            </para>
            <variablelist>
                <varlistentry>
                   <term><literal>id</literal></term>
                   <listitem>
                       <para>
                        Primary key of the variable in the tree variable
                        table.  This is useless for Tcl scripts that only
                        use the published API.  It can be useful if a script does
                        ad-hoc database queries (e.g. using the sqlite3 package).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>name</literal></term>
                   <listitem>
                       <para>
                        Name of the treevariable.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>value</literal></term>
                   <listitem>
                       <para>
                        Value of the tree variable (double).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>units</literal></term>
                   <listitem>
                       <para>
                        Units of measure text string.  If no units were supplied,
                        this will be an empty string.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </callout>
       </calloutlist>
       <example>
        <title>Storing spectrum contents (specstore.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: specstore.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]

    $saveset storeChannels s1 \    <co id='specstore.tcl.store' />
        [list {100 123} {101 2000} {102 400} {103 60}]
    
    set channels [$saveset getChannels s1] <co id='specstore.tcl.get' />
    puts "Channels in s1: "
    foreach chan $channels {
        set x [lindex $chan 0]
        set v [lindex $chan 2]             <co id='specstore.tcl.list' />
        puts "Channel $x:   $v"
    }
    $saveset destroy
    $db destroy
} msg]



if {$status} {
    puts stderr "error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='specstore.tcl.store' >
            <para>
                The <command>storeChannels</command> command stores
                channel values in a spectrum whose definition is already stored in
                the saveset.  Two additional parameters are expected;
                the name of the spectrum and the values.  Values are a list
                containing either two or three element sublists.  For
                1-d spectra, two elements are expected and they are the
                channel coordinate and channel value.  For 2d spectra,
                the three elements are x channel, y channel and value.
            </para>
        </callout>
        <callout arearefs='specstore.tcl.get' >
            <para>
                The <command>getChannels</command> subcommand returns a list of
                channel values stored for the spectrum. Each channel is given
                as a three element list.  The first element is an x channel number.
                The second element, is the y channel number if the spectrum is 2
                dimensional or 0 if not. The third element is the
                channel value.
            </para>
        </callout>
        <callout arearefs='specstore.tcl.list' >
            <para>
                Since we stored a 1-d spectrum we need to pull out
                the first and last elements of each channel list
                and output them.
            </para>
        </callout>
       </calloutlist>
       <para>
        The Tcl interface supports some queries of the event
        data stored in a save set but does not support storing events
        or scaler readouts.  See the reference section for more
        information about this.
       </para>
    </chapter>
    <chapter>
       <title>SpecTcl API to the database.</title>
       <para>
        The SpecTcl API to the database knows about the SpecTcl commands that
        can list objects get their properties and uses them to simplify
        interactions with the database.  It is a pure Tcl package
        that is written to live on top of the <literal>SpecTclDB</literal>
        package that serves as a Tcl binding to the database C++ API.
       </para>
       <para>
        The package, named <literal>dbconfig</literal> is available in the TclLibs directory tree of
        the SpecTcl installation.  Therefore, adding that directory
        to the package search path, as described in the previous chapter is
        sufficient to be able to do a
        <literal>package require dbconfig</literal> to bring the package
        code into the script.
       </para>
       <para>
        For the most part, the <literal>dbconfig</literal> package
        is intended to be used as a basis for implementing  SpecTcl GUI's
        that manipulate the database.  Note that one has already been written,
        give it a try first to see if it's sufficient.  Naturally if you have
        suggestions for improvement, send them off to us and we'll consider
        them for future releases.
       </para>
       <para>
        The reference material in the appendix will describe each
        proc of the package fully.  Here we'll just take a quick tour
        of the package. Note that all procs in the package are in the
        <literal>dbconfig</literal> database.
       </para>
    <para>
        Two procs, <literal>dbconfig::makeSchema</literal> and
        <literal>dbconifg::connect</literal> support the
        creation of and connection to databases.  Here's a script
        fragment that shows how to create and connect to a new
        database:
    </para>
    <example>
        <title>dbconfig - creating and connecting to a database</title>
        <programlisting>
proc newdb {fname} {
dbconfig::makeSchema $fname
return [dbconfig::connect $fname]
}
        </programlisting>
    </example>
    <para>
        The return value from <function>newdb</function> is a handle
        that must be used for other call to database related operations.
        In fact this is a database instance command from the
        Tcl bindings to the C++ API. When you are done using it you should
        distroy by invoking it's <command>destroy</command>
        subcommand.
    </para>
    <para>
        The <literal>dbconfig</literal> package things in terms of
        configurations. A configuration is the set of parameters,
        spectra, gates, gate applications and tree variables
        currently defined in SpecTcl.  It provides several
        procs that deal with configurations:
    </para>
    <variablelist>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::openSaveSet {dbcmd name}</code></term>
           <listitem>
               <para>
                This proc opens an existing save set and returns its
                save set instance command.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::saveConfig {db name {spectra 0}}</code>
           </term>
           <listitem>
               <para>
                Saves the analysis configuration into the database
                whoese handle is <parameter>db</parameter>. The saveset used
                will be <parameter>name</parameter> and must
                not yet exist.  If <parameter>spectra</parameter>
                is provided and is non-zero, spectrum contents for all spectra
                will get saved into the database.
               </para>
               <para>
                The proc returns a handle to the saveset
                (actually the saveset instance command). This
                value must be passed to save set related operations.
                When you are done with that handle, invoke it's
                <command>destroy</command> subcommand to destroy the
                command and relase resources associated with it.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig:listConfigs cmd</code>
           </term>
           <listitem>
               <para>
                Returns a Tcl list describing all of the savesets in the
                database.  THe list contains dicts that have
                the keys <literal>id</literal> primary key
                of the saveset, <literal>name</literal> saveset name,
                <literal>timestamp</literal> the time the saveset
                was created.  This can be turned into a readable value
                via <command>clock format</command>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::restoreConfig {cmd savename {restoreSpectra 0}}</code>
           </term>
           <listitem>
               <para>
                Restores the parameter, spectrum, gate, gate applications and
                tree variable s associated with a saveset.
                <parameter>cmd</parameter> is the database instance command
                gotten from <command>dbconfig::connect</command>.
                The <parameter>savename</parameter> parameter is the name of an
                existing save set in to which the processing parameters of SpecTcl
                are stored.   Finally, <parameter>retstoreSpectra</parameter>,
                if supplied and nonzero restores any saved specrum contents.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl" >proc dbconfig::saveSpectrum {sname specname}</code>
           </term>
           <listitem>
               <para>
                Saves a single spectrum to the save set designated by the saveset
                handle (instance command) <parameter>sname</parameter>
                The spectrum <parameter>specname</parameter> is saved.
                The save set must already exist and the spectrum definition
                must be saved in that save set.  
               </para>
               <para>
                Normally this is used when a configuration has been
                saved and only <emphasis>then</emphasis> are data analyzed.
                After data analysis is complete an appropriate set of spectra
                can then be saved into the same saveset to document the
                results of the analysis.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::restoreSpectrum {sname specname}</code>
           </term>
           <listitem>
               <para>
                Restores a single spectrum; <parameter>specname</parameter>
                from the saveset associated with the handle/instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::saveAllSpectrumContents {sname}</code>
           </term>
           <listitem>
               <para>
                Saves the contents of all spectra into the saveset
                given by the handle/instance command
                <parameter>sname</parameter>. The saveset must
                already have the spectra definitions stored.
                This is normally used at some point after a call to
                <function>dbconfig::saveConfig</function>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::restoreAllSpectrumContents {sname}</code>
           </term>
           <listitem>
               <para>
                Restores all spectra with saved contents stored in the savest
                designated by the handle/saveset instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::listSavedSpectra {sname}</code>
           </term>
           <listitem>
               <para>
                Returns a list of the names of spectra that have
                channels stored in the save set designated by the
                handle/save set instance command
                <parameter>sname</parameter>.
               </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The <literal>pkgconfig</literal> does not provide the ability
        to store or playback event data directly, several procs
        <emphasis>do</emphasis> provide the ability to get information
        about the runs stored in a save set and the ability to
        get scaler data <emphasis>is</emphasis> provided.
    </para>
    <para>
        Let's take a quick tour through those procs.
    </para>
    <variablelist>
        <varlistentry>
           <term>
            <code language='Tcl'>proc dbconfig::listRuns {cmd}</code>
           </term>
           <listitem>
               <para>
                Returns a list of dicts that describe all of the
                runs in the database whose connection is indicated
                by <parameter>cmd</parameter>.  Note:
                Database, not saveset, handle/instance command, not
                name.
               </para>
               <para>
                Each dict in the, possibly empty, result list is
                a dict with the following key/value pairs:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>config</literal></term>
                   <listitem>
                       <para>
                        Contains the name of the configuration
                        (save set) that contains this run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>number</literal></term>
                   <listitem>
                       <para>
                        The run number of the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>title</literal></term>
                   <listitem>
                       <para>
                        The title string associated with the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>start_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run started. This is a timestamp
                        that can be can be turned into a human readable
                        string via <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>stop_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run stopped as a
                        timestamp suitable to be used with
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::hasRun {saveset}</code>
           </term>
           <listitem>
               <para>
                Returns a boolean that is true if the
                saveset indicated by the <parameter>saveset</parameter>
                handle/instance command has associated event data.
                If not, returns false.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::getRunInfo {saveset}</code>
           </term>
           <listitem>
               <para>
                If the saveset indicated by the handle/instance command
                <parameter>saveset</parameter> has saved event data,
                this will return a list of dicts, just like
                <function>dbconfig::hasRun</function> does, but confined
                only for the runs in the save set.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>
            <code language="Tcl">proc dbconfig::getScalers {saveset run}</code>
           </term>
           <listitem>
               <para>
                Returns the scaler data associated with the
                run number <parameter>run</parameter> in the saveset
                indicated by the handle/instance command
                <parameter>saveset</parameter>.  The result is a list
                of dicts.  Each dict corresponds to a scaler readout.
               </para>
               <para>
                The dicts have the following key/values:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>start</literal></term>
                   <listitem>
                       <para>
                        Time into the run at which the scalers
                        started counting for this readout.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>stop</literal></term>
                   <listitem>
                       <para>
                        Time into the run at which the scaler counting
                        for this readout ended.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>divisor</literal></term>
                   <listitem>
                       <para>
                        The value to divide <literal>start</literal>
                        and <literal>stop</literal> by to get seconds
                        into the run.  This allows for subsecond
                        accuracy in those values.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>timestamp</literal></term>
                   <listitem>
                       <para>
                        The timestamp associated with the
                        scaler readout.  This is suitable for input
                        to <command>clock format</command>.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>sourceid</literal></term>
                   <listitem>
                       <para>
                        The id of the data source that contributed these data.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>channels</literal></term>
                   <listitem>
                       <para>
                        A list of the channel values that have been
                        readout.
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        In addition to the <literal>dbconfig</literal> package,
        a command ensemble in the <literal>SpecTclDB</literal> package is used by
        the SpecTcl to manage event recording to the database and event playback
        from a database. 
    </para>
    <para>
        The base command for this command ensemble is
        <command>daqdb</command>.  This command ensemble is not
        separable from SpecTcl.  It is intended to support the needs
        of graphical user interfaces that control the recording of
        and playback of data within SpecTcl.  Again, have a look
        at the SpecTcl user interface that is available before
        you start writing your own.
    </para>
    <para>
        The remainder of this chapter is a brief guided tour of the
        the subcommands of this command ensemble.
    </para>
    <variablelist>
        <varlistentry>
           <term><command>open</command><replaceable>file-name</replaceable></term>
           <listitem>
               <para>
                Access the database <parameter>file-name</parameter>.
                If the event processor and event sink needed to record
                data are not yet set up, they are set up.  Note that
                they are setup in the disabled state. It is necessary
                to enable event recording before that can take
                place.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>enable</command></term>
           <listitem>
               <para>
                Enables event recording beginning with the next run.  The
                next run is defined as SpecTcl receiving a begin run item
                on its data source, that is the event recording
                event processor's <methodname>OnBegin</methodname>
                method is called.
               </para>
               <para>
                Note that when event recording starts:
               </para>
                <itemizedlist>
                    <listitem>
                       <para>
                          A new saveset is created with a name derived from
                          the run number.
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          The analysis state is saved to the new saveset. 
                       </para>
                    </listitem>
                    <listitem>
                       <para>
                          Events and scaler readouts will be stored in this
                          new save set.
                       </para>
                    </listitem>
                </itemizedlist>
                <para>
                    When <methodname>OnEnd</methodname> is called,
                    the run description is given its end time.
                    At that time, the contents of any
                    spectra in the auto save are written to the saveset.
                    See below.
                    This
                    does not disable event recording. Each run
                    will repeat this sequence.
                </para>
                <para>
                 This implies that SpecTcl, using this package will not
                 let you save more than one run per saveset, and that an single run
                 can only be saved once per database.
                </para>
                
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>disable</command></term>
           <listitem>
               <para>
                Disbables evfent recording instantly.  If data are
                actively being recorded, any active run will not have an
                end time.  This does not prevent the data from
                being played back.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>close</command></term>
           <listitem>
               <para>
                Closes the database and tears down the recording
                event processor and event sink.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>autosave</command> <replaceable>spectrum-list</replaceable></term>
           <listitem>
               <para>
                The event recording subsystem allows you to provide a list of
                spectrum names whose contents will be saved when an
                end run is encountered while writing event data.
                This list is called the <firstterm>autosave list</firstterm>.
               </para>
               <para>
                The <parameter>spectrum-list</parameter> parameter to this
                command is a list of the names of spectra.  The autossave list
                is set to this list.  Any spectra on this autosave list prior to
                to this command are no longer on the autosave list.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>listruns</command></term>
           <listitem>
               <para>
                Returns a list of dicts.  Each dict describes a
                run that is recorded in the event file.  The dicts
                 have the following key/value pairs:
               </para>
               <variablelist>
                <varlistentry>
                   <term><literal>number</literal></term>
                   <listitem>
                       <para>
                        The number of the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>config</literal></term>
                   <listitem>
                       <para>
                        The name of the save set containing that run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>title</literal></term>
                   <listitem>
                       <para>
                        The title string associated with the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>start_time</literal></term>
                   <listitem>
                       <para>
                        The time at which the run started.  This
                        value can be formatted for humans via
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><literal>end_time</literal></term>
                   <listitem>
                       <para>
                        The time at wich the run ended.  This value
                        can be formatted with
                        <command>clock format</command>
                       </para>
                    </listitem>
                </varlistentry>
               </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>play</command> <replaceable>run-number</replaceable></term>
           <listitem>
               <para>
                Begins playback of the run <parameter>run-number</parameter>.
                While playback is in progress, the event loop is
                periodically flushed, which keeps the user interface alive.
                Note that playback and recording cannot be done simultaneously due
                to the way in which recording data locks the database.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term><command>stop</command></term>
           <listitem>
               <para>
                Stops any ongoing playback.
               </para>
            </listitem>
        </varlistentry>
    </variablelist>
    </chapter>
    <chapter>
       <title>The SpecTcl database GUI.</title>
       <para>
        The SpecTcl database GUI provides a simple graphical user interface
        to the database.  It allows you to
       </para>
       <itemizedlist>
        <listitem>
           <para>
              Create empty databases and access existing ones. 
           </para>
        </listitem>
        <listitem>
           <para>
              View the contents of a database in a tree-like graphical
              form.
           </para>
        </listitem>
        <listitem>
           <para>
              Save configurations to and restore them from savesets. 
           </para>
        </listitem>
        <listitem>
           <para>
              Save and store the contents of spectra to a save set. 
           </para>
        </listitem>
        <listitem>
           <para>
               Initiate and end event recording.
           </para>
        </listitem>
        <listitem>
           <para>
              Specify auto save spectrum lists for event recording. 
           </para>
        </listitem>
        <listitem>
           <para>
              Initiate and stop event playback from runs saved in a
              saveset.
           </para>
        </listitem>
       </itemizedlist>
       <para>
        You can use the GUI by adding the following lines to your
        <filename>SpecTclRC.tcl</filename>:
       </para>
       <example>
        <title>Incorporating the database GUI in your SpecTcl</title>
        <programlisting>
lappend auto_path [file join $SpecTclHome TclLibs]
...
package require dbgui
        </programlisting>
       </example>
       <para>
        With a database file open, the GUI might look like this:
       </para>
       <figure>
        <title>The SpecTcl database GUi window</title>
        <graphic format='PNG' fileref='GUI.png' scalefit='1'/>
       </figure>
       <para>
        Each saveset is shown as a folder.  Within open folders, the entities
        stored in the saveset are identified by various icons.
        These are describe in the figure.  Note that an item in the
        user interface may be selected by clicking it.  If an item
        is selected it is highlighted as shown.  The status line
        at the bottom of the window includes the database name,
        the name of the current configuration, the currently selected item and,
        not shown, a digital clock.
       </para>
       <para>
        You interact with the graphical user interface via commands
        on its menubar and pop-up <firstterm>context menus</firstterm>
        accessed by right clicking on selected items in the
        main window of the GUI.
       </para>
       <para>
        First we'll look at the menubar menus and their contents.
        Then we'll look at the context menus that are available.
       </para>
       <section>
        <title>The GUI Menubar</title>
        <formalpara>
            <title>File Menu</title>
            <para>
                The File menu has the following commands:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>New...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a new file.
                            The file will be initialized with the
                            schema needed to serve as a database file.
                            The resulting, presumably empty database will then be opened and
                            used as the current database.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Open...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a file. The
                            selected file must be a previously initialized database
                            file.  The selected file is opened and
                            becomes the new database file.
                           </para>
                           <para>
                            The view of the current database is updated to reflect
                            all of the savesets in the file.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>The Save Menu</title>
            <para>
                This menu allows you to save various things into
                the database:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Configuration...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the name of a new save set
                            and saves the current SpecTcl analysis configuration
                            into that saveset. 
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for spectra to save. The
                            contents of the selected spectra are saved to the
                            current save set.  If there is no current savset,
                            An error dialog tells you that.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Recording</title>
            <para>
                This menu supports various aspects of event recording
                into the database.
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Enable Recording</guimenuitem></term>
                       <listitem>
                           <para>
                            This checkbutton turns on or off event recording.
                            While event recording is active the main window
                            actions are disabled because event recording
                            locks the entire database.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Autosve spectra...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for the spectra whose contents are automatically
                            saved at the end of a recorded run.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Help</title>
            <para>
                The <guimenu>Help</guimenu> menu only contains
                the <guimenuitem>About...</guimenuitem>
                entry.  That entry pops up a message box that
                provides information about the GUI and its
                version.
            </para>
        </formalpara>

       </section>
       <section>
        <title>Pop Up context menus</title>
        <para>
            Each of the object types in the GUI has a context menu that can
            be popped up by right clicking that object. This
            section describes those menuse and what their commands do.
        </para>
        <formalpara>
            <title>Configurtion context menu</title>
            <para>
                This context menu is activated by right clicking
                on a saveset or the configuration saved in that saveset.
                It makes the following commands available:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Save...</guimenuitem></term>
                       <listitem>
                           <para>
                            Requests a new save set name, creates that save set
                            and saves the current analysis
                            configuration in that saveset.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Save Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Requests a spectrum name and saves that
                            spectrum's contents in the currently selected save set.
                            Note that activating the context menu
                            makes the configuration the mouse is over
                            the current configuration.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Load</guimenuitem></term>
                       <listitem>
                           <para>
                            Loads the configuration into SpecTcl.
                            This restores the parameter, tree parameter,
                            spectrum and gate definitions as well as the
                            gate applications and tree variable definitions and
                            values into SpecTcl.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                If you post this menu by mistake, the escape keyboard key
                will unpost it.
            </para>
        </formalpara>
        <formalpara>
            <title>Spectrum context menu</title>
            <para>
                This context menu is activated when you right click
                a spectrum object in a save set.  It has the following commands:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Resave</guimenuitem></term>
                       <listitem>
                           <para>
                            The current contents of the spectrum indicated are
                            saved into the current save set.  Prior contents are
                            cleared first.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Save Spectrum...</guimenuitem></term>
                       <listitem>
                           <para>
                            Prompts for a spectrum whose contents will be
                            saved in the currently selected save set.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Load</guimenuitem></term>
                       <listitem>
                           <para>
                            Loads the contents of the selected spectrum
                            into the same spectrum in SpecTcl.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
        <formalpara>
            <title>Run context menu</title>
            <para>
                This menu supports event playback:
                <variablelist>
                    <varlistentry>
                       <term><guimenuitem>Play...</guimenuitem></term>
                       <listitem>
                           <para>
                            After prompting for confirmation warning of the
                            consequences of playing back data:
                            Turn off any active recording. Prompts to
                            ask if the user wants to restore the
                            analysis configuration prior to playback,
                            Asks as well if you want to clear all spectra
                            prior to playback.
                           </para>
                           <para>
                            On confirmation, initiates playback.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><guimenuitem>Stop</guimenuitem></term>
                       <listitem>
                           <para>
                            Disables any playback in progress.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </formalpara>
       </section>
    </chapter>
    <appendix>
        <title>Reference material</title>
        <section>
            <title>Database schema.</title>
            <para>
                Database schema are divided into tables.  Each table
                usually has a field called its <firstterm>primary key</firstterm>.
                The value of the primary key is a unique identifier for
                records in the table.  It is normally very quick to look up
                a record by its primary key.
            </para>
            <para>
                In a relational databae, such as sqlite3, it is normal
                for records in one table to refer to records in another table.
                This reference is expressed by having fields that contain
                <firstterm>foreign keys</firstterm> to the other table.
                A foreign key is a field whose values are primary keys in
                another table.
            </para>
            <para>
                Foreign keys express a belonging/ownership relationship.
                The ownership, in turn may express a 'has many' or a
                 'has one' relationship depending on the multiplicity of the
                 relationship.   This multiplicity is defined by the
                 logic that populates the database.
            </para>
            <para>
                This appendix will describe the set of tables
                defined by a daq database and their relationships.
            </para>
            <para>
                The top level table is the <literal>save_sets</literal>
                table.  It contains one entry for each save set in the
                database. All other tables are owned either directly or indirectly
                by a row in the <literal>save_set</literal> table.
                The schema of this table is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS  save_sets 
            (id  INTEGER PRIMARY KEY,
             name TEXT UNIQUE,
             timestamp INTEGER)
                </programlisting>
            </informalexample>
            <para>
                The fields have the following meaning:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>id</structfield></term>
                    <listitem>
                        <para>
                            The primary key for the row.  Our convention is
                            that each table's primary key is an integer named
                            <literal>id</literal> and is the first field
                            declared in the table.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the save-set.  Sqlite3 does
                            not require us to declare lengths of text items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> timestamp</term>
                    <listitem>
                        <para>
                            The time at which the record was created.
                            This is a unix timestamp.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The primary purpose of save sets is to store the analysis
                configuration of SpecTcl.  This consists of parameter/treeparameter
                definitions, Spectrum definitions, gate definitions,
                gate applications and tree variables.  At present,
                pseudo parameter definitions are not stored. If there
                is a need for that, please contact us as these can be
                added.
            </para>
            <para>
                Parameter definitions require a single table:
                <literal>parameter_defs</literal>.  This table
                contains the base SpecTcl parameter definition as well
                as any optional metadata supplied by a treeparameter that
                might wrap it.  If a tree parameter is not wrapping
                the parameter, then the metadata values are NULL.
            </para>
            <para>
                Here's the table definition for the <literal>parameter_defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS parameter_defs
            (id      INTEGER PRIMARY KEY,                    
             save_id INTEGER NOT NULL,  -- foreign key to save_sets.id
             name    TEXT NOT NULL,
             number  INTEGER NOT NULL,
             low     REAL,
             high    REAL,
             bins    INTEGER,
             units   TEXT)
                </programlisting>
            </informalexample>
            <para>
                As with all tables, by convention, <structfield>id</structfield>
                is the primary key and is an integer.  Here are the
                definitions for the remaining fields of the table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>save_id</structfield></term>
                    <listitem>
                        <para>
                            This is a foreign key that contains the
                            <literal>id</literal> of the <literal>save_set</literal>
                            to which this parameter definition belongs.
                            We can say that a parameter definition belongs
                            to a save set and a save set has many
                            parameter definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            This field contains the name of the spectcl
                            parameter.  It is never null as all SpecTcl
                            parameter must have unique names.  The
                            field is not marked as unique because different
                            save sets may have parameter definitions with the
                            same name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> number</term>
                    <listitem>
                        <para>
                            This is the SpecTcl parameter number.
                            Each parameter in SpecTcl has a unique number
                            that defines it's slot in <classname>CEvent</classname>
                            objects containing unpacked event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>low</structfield></term>
                    <listitem>
                        <para>
                            This field is not null if there is a tree
                            parameter wrapping of the parameter.  In that
                            case, the field will contain the tree parameter's
                            suggested low limit for the parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>high</structfield></term>
                    <listitem>
                        <para>
                            As with <structfield>low</structfield>, is
                            not null if the parameter is wrapped by a tree
                            parameter.  In that case, this field contains
                            the suggested high limit for this parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> <structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped with  a tree parameter,
                            this contains the suggested binning for this
                            parameter.  Otherwise, this field is null.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>units</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped by a tree parameter,
                            this field contains the units of measure of that
                            parameter.  It can be an empty string as well as
                            NULL.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of tables hold information about spectrum definitions
                and spectrum contents.  These tables are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>spectrum_defs</literal></term>
                    <listitem>
                        <para>
                            The top level (or <firstterm>root</firstterm>) table
                            for spectrum definitions.  This table has
                            one entry per spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>axis_defs</literal></term>
                    <listitem>
                        <para>
                            Depending on the dimensionality of the spectrum,
                            each record in <literal>spectrum_defs</literal>
                            will have one or two records in this table.
                            Each entry describes a spectrum axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_params</literal></term>
                    <listitem>
                        <para>
                            Each spectrum depends one or more parameters.
                            Thus <literal>spectrum_defs</literal> has many
                            <literal>spectrum_params</literal> each
                            describing a parameter the spectrum depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_contents</literal></term>
                    <listitem>
                        <para>
                            If a spectrum has contents stored, this
                            table will contain the spectrum contents.
                            There will be a record in this table for
                            every non-zero channel in the spectrum.
                        </para>
                        <para>
                            Note in the special case were an empty spectrum
                            is being saved, there will be one record for
                            the spectrum with a channel value of 0.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's look at these tables in detail.
            </para>
            <para>
                <literal>spectrum_defs</literal> is the top level table
                for capturing spectrum definitions and contents.  All of
                the other tables involved in spectrum definitions have
                foreign keys linking them back to this table.  This
                table, in turn, has a foreign key that links it back
                to the save set it belongs to.
            </para>
            <para>
                The defintion of <literal>spectrum_defs</literal> is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS spectrum_defs
            (id      INTEGER PRIMARY KEY,
             save_id INTEGER NOT NULL,     -- Foreign key to save_sets.id
             name    TEXT NOT NULL,
             type    TEXT NOT NULL,
             datatype TEXT NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                Besides the <structfield>id</structfield> which is the
                usual primary keh and the <structfield>save_id</structfield>
                which is the foreign key pointing back to the
                <literal>save_sets</literal> table, the following fields
                are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl's name for the spectrum.  Each spectrum
                            in a save set has a unique name. Usually
                            humans refer to the spectrum using that name.
                            While SpecTcl assigns an integer number to that
                            spectrum, that number is actually not used
                            at all externally or internally and is, therefore,
                            not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>type</structfield></term>
                    <listitem>
                        <para>
                            Each spectrum has a type that determines how
                            it is incremented by the parameters it depends on.
                            In SpecTcl, these types are represented by short
                            textual type codes.  This field contains the
                            type code for the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>datatype</structfield></term>
                    <listitem>
                        <para>
                            Histograms storing a spectrum have a data type
                            that can be one of
                            byte (uint8_t), word (uint16_t) or
                            long (uint32_t).  This field captures that
                            datatype.  By default, given that memory is much
                            cheaper than when SpecTcl was originally written,
                            a spectrum's data type is long.  Regardless,
                            this field explicitly stores the spectrum's
                            datatype.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Each spectrum has one or two axes (SpecTcl does not support 3d
                spectra).  These axes are described in the
                <literal>axis_defs</literal> table.   When fetching from
                this table, it's important to order the results by the
                <structfield>id</structfield> field.  When this is done,
                the first (or only) axis for a spectrum is the X axis
                and the second, if it exists is the Y axis definition.
            </para>
            <para>
                Here is the definitino of the <literal>axis+defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS axis_defs
            (
                id           INTEGER PRIMARY KEY,
                spectrum_id  INTEGER NOT NULL,  -- FK to spectrum_defs.id
                low          REAL NOT NULL,
                high         REAL NOT NULL,
                bins         INTEGER NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                As usual, <structfield>id</structfield> is the primary
                key.  It also serves to order axis definitions for a spectrum.
                <structfield>spectrum_id</structfield> is a foreign key
                to the <structfield>id</structfield> field of the
                <literal>spectrum_defs</literal> table.  Its value
                indicates which spectrum in the <literal>spectrum_defs</literal>
                table, a record in this table belongs to.
            </para>
            <para>
                The remaining fields in this table are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>real</type><structfield>low</structfield></term>
                    <listitem>
                        <para>
                            The low limit of the axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type><structfield>high</structfield></term>
                    <listitem>
                        <para>
                            The high limit of the axis.  The axis is
                            considered to run over the interval
                            [low, high).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            Number of bins into which the axis is divided.
                            Note that in SpecTcl bins are all equal sized.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Spectra are defined on  parameters.  The values of parameters
                in an event can increment a spectrum depending on that
                spectrum's type and whether or not parameters needed are
                present.  The number of parameters a spectrum may have
                are dependent on may be anywhere from 1 to unbounded depending
                on the spectrum type (e.g. gamma spectra). 
            </para>
            <para>
                 Where parameter
                ordering is important, ordering the retrieval of parameters
                from the <literal>spectrum_params</literal> table
                recovers that ordering.  
            </para>
            <para>
                The contents of this table consist of the primary key
                <structfield>id</structfield>, and two foreign keys:
                <structfield>spectrum_id</structfield> which ties the
                record back to the spectrum it belongs to and
                <structfield>parameter_id</structfield> which ties the
                entry back to the parameter in the
                <literal>parameter_defs</literal> table that defines
                the parameter.
            </para>
            <para>
                In this way, it is not necessary to actually repeat
                the parameter definitions.  This point is an important
                concept in database design. This sort of table is also
                sometimes called a <firstterm>join table</firstterm>
                because you can use the SQL join operation to marry the
                <literal>spectrum_defs</literal> table to the
                <literal>parameter_defs</literal> table through this
                table.
            </para>
            <para>
                Finlly,
                If the contents of the spectrum have been saved in a
                save set there will be several entries in the
                <literal>spectrum_contents</literal> table to
                represent this.  With the exception of the special case
                of a spectrum with no counts, the table will contain one
                entry for each  non-zero channel.  If the spectrum is empty,
                it will contain a single entry for a valid channel in the
                spectrum containing a value of zero.
            </para>
            <para>
                The table contains the usual <structfield>id</structfield>
                primary key column.  It also has a
                <structfield>spectrum_id</structfield> foreign key into the
                <literal>spectrum_defs</literal> table that ties each
                record back to a spectrum definition which, in turn, ties the
                entry back to a save set.
            </para>
            <para>
                The remaining fields are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type><structfield>xbin</structfield></term>
                    <listitem>
                        <para>
                            This value is a bin number on the X axis
                            of the spectrum.  If the spectrum is one-dimensional,
                            this value is the only coordinate needed
                            to specify a spectrum bin.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>ybin</structfield></term>
                    <listitem>
                        <para>
                            If the spectrum is two dimensional (for this purpose,
                            summary spectra are two dimensional),
                            this value is the y bin coordinate of a channel
                            in the spectrum.   If the spectrum is
                            one dimensional, the value  of this field is NULL.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            This field is the value that was stored in the
                            channel designated by the
                            <structfield>xbin</structfield> and possibly
                            <structfield>ybin</structfield> fields.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                SpecTcl provides a very rich set of gate types.  For database
                definition purposes, these actually fall into three categories:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        <firstterm>Parameter/point</firstterm>; these gates
                        depend on parameters and points in parameter space.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Parameter/mask</firstterm>; these gates
                        depend on parameters and a bitmask.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Compound</firstterm>; these gates depend on
                        other gates.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                There are also the special cases of True and False gates
                that depend on nothing.
            </para>
            <para>
                This richness in gate types and dependecies leads to a root
                <literal>gate_defs</literal> table and quite a few
                subordinate tables some of which are used and other not used
                for any given gate type:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>gate_defs</literal></term>
                    <listitem>
                        <para>
                            This is the root table.  Every gate has an
                            entry in this table.  All subordinate tables
                            have foreign keys pointing back to this table.
                        </para>
                        <para>
                            Note that if you fetch gate definitions from this table
                            ordered by primary key, the API ensures that
                            you will not encounter a gate definition that
                            for a compound gate that depends on a gate you
                            have not already seen previously in the
                            retrieval.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>gate_points</term>
                    <listitem>
                        <para>
                            This table is used by Parameter/point gates to
                            store the points that define the region of
                            interest that makes up the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>component_gates</literal></term>
                    <listitem>
                        <para>
                            This table is used by Compound gates to store the
                            gates a compound gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_parameters</literal></term>
                    <listitem>
                        <para>
                            This table stores the parameters a Parameter/point
                            or Parameter/mask gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_masks</literal></term>
                    <listitem>
                        <para>
                            This table stores the mask values for
                            Parameter/mask gates.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's starg going over the contents of each of these
                tables one at a time.  The
                <literal>gate_defs</literal> table, as expected,
                has the <structfield>id</structfield> primary key
                and <structfield>saveset_id</structfield>  foreign key
                fields, uniquely defining the entry and which save set
                the gate definition belongs to.
            </para>
            <para>
                Additionally, each record of this table has the following
                fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Each gate has a unique name.  This
                            field contains that name. While SpecTcl
                            assigns gates numbers, these numbers are not
                            used internally or externally and, therefore,
                            are not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>type</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl uses short textual strings to
                            describe the gate type.  This field
                            stores that gate type.  The gate type
                            is going to determine which other tables
                            have data for this gate.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For Parameter/Points gates, the <literal>gate_points</literal>
                table defines a region of interest in parameter space in
                which the gate is true.  These gates will also have
                entries in the <literal>gate_parameters</literal> table.
                Where point ordering is important (e.g contours and bands),
                ordering the retrieval by <structfield>id</structfield>
                recovers that order.
            </para>
            <para>
                In addition to the <structfield>id</structfield> primary
                key, this table contains a
                <structfield>gate_id</structfield> field which is a
                foreign key into the <literal>gate_defs</literal> table
                identifying the gate each point belongs to.
            </para>
            <para>
                Real <structfield>x</structfield> and possibly
                null <structfield>y</structfield> fields identify the
                point coordinates.  One dimensional regions of interest
                (e.g. slices) have null y values.
            </para>
            <para>
                Compound gates require a list of dependent gates.
                These are stored in the join table
                <literal>component_gates</literal>.  In addition to the
                <structfield>id</structfield> primary key and
                <structfield>parent_gate</structfield> foreign key back to the
                <literal>gate_defs</literal> table indicating the gate
                each record belongs to, a <structfield>child_gate</structfield>
                foreign key back to the <literal>gate_defs</literal>
                table points to the dependent gate.
            </para>
            <para>
                Compound gates need not have ordering, however for some
                gate types (and, or gates), the ordering could be chosen
                to improve the efficiency of gate computation if the
                frequency with which a dependent gate is satisfied is known.
                This s because these gates do short-circuit evaluation,
                where possible to avoid checking all dependent gates.
                Once more retrieving from this table ordered by
                <structfield>id</structfield> will recover the original
                order of dependent gates.
            </para>
            <para>
                Parameter/point and parameter/mask gates require
                entrie(s) in the <literal>gate_params</literal> table.
                This is a join table with primary key
                <structfield>id</structfield> and
                <structfield>parent_gate</structfield> pointing to
                the owning gate in the <literal>gate_defs</literal> table
                and <structfield>parameter_id</structfield> pointing to the
                parameter in the <literal>parameter_defs</literal> table.
            </para>
            <para>
                As usual, retrieving the data from this table ordered by
                primary key will recover any required ordering of these parameters
                (for example band aand contour gates require the first
                parameter be the X parameter and second the Y).
            </para>
            <para>
                Finally, the <literal>gate_masks</literal> table stores the
                mask values for gates Parameter/Mask gate types.
                This table, in addition to the primary key
                <structfield>id</structfield>, and foreign key
                <structfield>parent_gate</structfield> that refers
                back to the <literal>gate_defs</literal> table
                has an integer <structfield>mask</structfield> parameter
                that contains the mask value.
            </para>
            <para>
                Defined gates can be applied to a spectrum in SpecTcl.
                When applied, that gate acts as a condition that is
                checked, event by event, and must be true for the
                spectrum to be incremented.  Actually all spectra
                have gates applied to them. When a spectrum is created
                it has a True gate applied to it so that it is always
                incremented.
            </para>
            <para>
                Gate applications are captured in a join table called,
                <literal>gate_applications</literal> in addition to the
                primary key <structfield>id</structfield>, this table
                has two foreign keys:
                <structfield>spectrum_id</structfield> that indicates which spectrum
                is being conditionalized by the gate that is
                indicated by <structfield>gate_id</structfield>.
            </para>
            <para>
                The final analysis cofiguration item we need to describe
                in the database are tree variables.  These map to Tcl
                variables and <classname>CTreeVariable</classname> objects
                that are used to steer computations performed by the
                user's event analysis pipeline.
            </para>
            <para>
                Tree variable definitions are captured in the
                <literal>treevariables</literal> table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS treevariables (
                id             INTEGER PRIMARY KEY,
                save_id        INTEGER NOT NULL,
                name           TEXT NOT NULL,
                value          DOUBLE NOT NULL,
                units          TEXT
            )
                </programlisting>
            </informalexample>
            <para>
                In addition to the <structfield>id</structfield> primary
                key and <structfield>save_id</structfield> foreign
                key into the <literal>save_sets</literal> table,
                the following fields are present in this table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the tree variable.  This
                            is also the name of the Tcl global variable
                            the tree variable maps to.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            Contains the value of the tree variable.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>units</structfield></term>
                    <listitem>
                        <para>
                            Contains the units of measure metadata for
                            this tree variable.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <section>
                <title>Storing event data</title>
                <para>
                    The event data for a single run can also be
                    stored in a save-set. At present, only
                    run state transitions, event data and scaler
                    readouts can be stored.
                </para>
                <para>
                    The SpecTcl code that
                    can write event data into the database creates
                    a new save set when the run begins, and saves
                    the analysis configuration.  It then puts data
                    into a set of additional tables.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>runs</literal></term>
                        <listitem>
                            <para>
                                Contains the root information for
                                event and scaler data. All event
                                like data for the run are linked back
                                to this table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>events</literal></term>
                        <listitem>
                            <para>
                                Stores the parameters for each event
                                that were produced by the user's event
                                analysis pipeline.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_readouts</literal></term>
                        <listitem>
                            <para>
                                Stores information about when a scaler
                                readout occured and on which source id
                                it occured.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_channels</literal></term>
                        <listitem>
                            <para>
                                Stores the data  from each channel
                                of a scaler ring item
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>runs</literal> table has the following definition
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS runs (    -- Runs that were saved.
                id         INTEGER PRIMARY KEY,
                config_id  INTEGER,              -- Configuration at begin of run.
                run_number INTEGER UNIQUE NOT NULL,
                title      TEXT NOT NULL,
                start_time INTEGER,
                stop_time  INTEGER              -- End of run time
            )
                    </programlisting>
                </informalexample>
                <para>
                    As expected, the <structfield>config_id</structfield>
                    is a foreign key into the <literal>save_sets</literal>
                    table indicating which save set this run was saved in.
                    <structfield>id</structfield> is a primary key which
                    provides a handle for dependent data to link back to.
                </para>
                <para>
                    In addition to these fields, we store:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>run_number</structfield></term>
                        <listitem>
                            <para>
                                The run number for the run captured
                                by this data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>text</type><structfield>title</structfield></term>
                        <listitem>
                            <para>
                                The title of the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which the
                                run begun. In Tcl this can be turned into
                                a human readable time with
                                <command>clock format</command>, in
                                C/C++ with <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which
                                the run was ended. Note that if the run
                                does not have a valid end run item,
                                this will be NULL
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>events</literal> table is a bit odd.
                    A normal database definition for it would look like
                    this:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
        id          INTEGER PRIMARY KEY,
        run_id      INTEGER NOT NULL,
        event_number INTEGER_NOT NULL,
        parameter_id INTEGER NOT NULL,
        parameter_value REAL NOT NULL
    )
                    </programlisting>
                </informalexample>
                <para>
                    Each parameter of each event would have an entry in the
                    table that would contain its parameter id
                    (foreign key to the <literal>parameter_defs</literal>
                    table), and its value.  In fact this was the first
                    try to implement this table.  What we found, however,
                    was that while this table would have made some interesting
                    queries to support data analysis possible, reconstructing
                    events from it was not time-efficient.
                </para>
                <para>
                    We therefore wound up settling on this compromise
                    definition:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
                id         INTEGER PRIMARY KEY,
                run_id     INTEGER NOT NULL,   -- fk to runs(id).
                event_number INTEGER NOT NULL, -- Event number in the run.
                parameter_count INTEGER NOT NULL, -- Hints at the event blob size.
                event_data  BLOB NOT NULL
            )
                    </programlisting>
                </informalexample>
                <para>
                    As in the first attempt, in addition to the
                    primary key <structfield>id</structfield>,
                    the <structfield>run_id</structfield>, a foreign key
                    tying the event back to the run it belongs to
                    and the <structfield>event_number</structfield>,
                    which represents the trigger number in the run;
                    we have:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>parameter_count</structfield></term>
                        <listitem>
                            <para>
                                Contains the number of parameters
                                that have values in this event.  SpecTcl
                                provides a <classname>CEvent</classname>
                                data type that is an array like object
                                whose values know if they've been assigned
                                values or not.  This
                                count represents the count of parameters
                                that have been assigned values.
                            </para>
                            <para>
                                Some event processing pipelines initialize
                                all parameters to some value.
                                While this avoids having to
                                check the validity of parameters, it also
                                throws away a major SpecTcl optimization
                                at histogramming time.  This is not
                                recommended practice.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>blob</type><structfield>event_data</structfield></term>
                        <listitem>
                            <para>
                                This contains the actual parameters that
                                were given values in the event.  So first,
                                what does <firstterm>blob</firstterm> mean?
                                <literal>blob</literal> is an acronym for
                                <literal>Binary Large Object</literal>.
                                Blobs allows arbitrary binary data to
                                occupy a field in the database.
                            </para>
                            <para>
                                In this case the blob stores a sequence
                                of <structfield>parameter_count</structfield>
                                <type>DBEvent::blobElement</type> structs. Where
                                this struct contains the following fields:
                            </para>
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <type>uint32_t</type>
                                        <structfield>s_parameterNumber</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The number/id of a parameter
                                            (foreign key into
                                            <literal>parameter_defs</literal>).
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <type>double</type>
                                        <structfield>s_parameterValue</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The value of that parameter for
                                            this event.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                
                            </variablelist>
                            <para>
                                The SpecTclHeader
                                <filename>CDBEvents.h</filename>
                                contains a definition of the
                                <type>DBEvent::blobElement</type>
                                data type.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Scaler data is captured in two tables.
                    The first, <literal>scaler_readouts</literal>
                    contains one record per
                    <literal>PERIODIC_SCALERS</literal>
                    ring item SpecTcl sees.  The second,
                    <literal>scaler_channels</literal> contains the
                    actual values of the scaler contained by that
                    ring item.
                </para>
                <para>
                    The <literal>scaler_readouts</literal> table looks like
                    this:
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS scaler_readouts (
                id            INTEGER PRIMARY KEY,
                run_id        INTEGER NOT NULL,      -- fk for runs.
                source_id     INTEGER NOT NULL,      -- Event builder source.
                start_offset  INTEGER NOT NULL,
                stop_offset   INTEGER NOT NULL,
                divisor       INTEGER NOT NULL,
                clock_time    INTEGER NOT NULL
            )                    
                    </programlisting>
                </informalexample>
                <para>
                    The <structfield>id</structfield>
                    field is the primary key
                    value and <structfield>run_id</structfield>
                    is a foreign key into the <literal>runs</literal>
                    table that indicates which run this readout belongs to.
                </para>
                <para>
                    The remainder of the fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>source_id</structfield></term>
                        <listitem>
                            <para>
                                This is the source id from the body header
                                of the ring item. In event built data
                                it indicates which event source produced
                                this scaler item.  If the scaler item
                                does not have a body header, this wil
                                contain the value <literal>0</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_offset</structfield></term>
                        <listitem>
                            <para>
                                Scaler data represents scaler counts over
                                some interval in the run.  This value
                                contains the time offset into the run
                                at which that interval began.  See, however
                                <structfield>divisor</structfield> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_offset</structfield></term>
                        <listitem>
                            <para>
                                Describes the time offset into the run
                                at which the counting intervale ended.
                                Again see the <structfield>divisor</structfield>
                                field below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>divisor</structfield></term>
                        <listitem>
                            <para>
                                In order to allow for sub-second timing in
                                scaler readout, either for higher precision,
                                or for cases when readouts must happen more
                                often than once per second, this field is
                                supplied.  This field represents the number
                                of seconds per <firstterm>tick</firstterm>
                                in the start and stop offset fields.
                                That is, dividing those fields by this value
                                (in floating point) results in seconds into
                                the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>clock_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type>
                                at which this scaler readout happened.
                                This can be converted to a humann readable
                                time in Tcl using
                                <command>clock format</command>
                                and in C/C++ using
                                <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Associated with each scaler channel in the ring item
                    that resulted in an entry in <literal>scaler_readouts</literal>
                    is a record in the <literal>scaler_channels</literal>
                    table.  This table has the usual
                    <structfield>id</structfield> primary key.
                    A foreign key pointing it back to an entry in the
                    <literal>scaler_readouts</literal> table named
                    <structfield>readout_id</structfield> and the following
                    additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>channel</structfield></term>
                        <listitem>
                            <para>
                                The channel number of this entry.
                                This is the index into the array of scalers
                                that was readout.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>value</structfield></term>
                        <listitem>
                            <para>
                                The number of counts in that scaler
                                channel for
                                the asssociated readout.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
    </appendix>
</book>