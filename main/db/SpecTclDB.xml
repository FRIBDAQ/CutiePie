<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
                      "file:///usr/share/xml/docbook/schema/dtd/4.5/docbookx.dtd
"
>
<book>
    <bookinfo>
      <title>SpecTcl Sqlite3 interfaces</title>
      <author><firstname>Ron</firstname><surname>Fox</surname></author>
      <revhistory>
          <revision>
             <revnumber>1.0</revnumber>
             <date>January 23, 2020</date>
             <authorinitials>RF</authorinitials>
             <revremark>Original Release</revremark>
          </revision>
      </revhistory>
    </bookinfo>
    <chapter>
        <title>Introduction</title>
        <para>
            This document describes a package distributed with SpecTcl that provides
            support for saving and restoring data from sqlite3 databases.
            For more information about Sqlite3 see
            <ulink url='http://sqlite.org' /> for information about that database and
            package.   If you want to extend the database access but don't know SQL,
            the query language used by Sqlite3, you can have a look at this
            SQL tutorial online.  <ulink url='www.w3schools.com/sql' />
        </para>
        <para>
            The remainder of this document describes
        </para>
        <itemizedlist>
            <listitem>
               <para>
                    What the SpecTcl Sqlite interface provides and how to
                    incorporate it into your SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    The low level, program neutral C++ API which allows database
                    object to be stored and recovered without the user
                    needing to know the database schema or the SQL query language
                    used to maintain and query the database contents.
                </para>
            </listitem>
            <listitem>
                <para>
                    The C++ classes SpecTcl uses to store event data into the
                    database and read it back out into SpecTcl.
                </para>
            </listitem>
            <listitem>
               <para>
                   A description of the Tcl bindings to the C++ API.
                   These bindings can be used in any environment,
                   not just SpecTcl.
               </para>
            </listitem>
            <listitem>
                <para>
                    A description of a high level Tcl API that
                    is SpecTcl centric.  This includes command
                    and procs for saving and restoring objects
                    in the database as well as recording
                    and playing back decoded events.
                </para>
            </listitem>
            <listitem>
               <para>
                   SpecTcl database GUI. The GUI bolts on to SpecTcl providing
                   a user interface you can use to interact with SpecTcl databases.
               </para>
            </listitem>
            
            <listitem>
               <para>
                   Appendix A provides a detailed description of the SQL schema
                   (database organization) of the database files as well as
                   reference information about the APIs described in the
                   various chapters of this manual.
               </para>
            </listitem>
            
        </itemizedlist>
        <para>
            Why use Sqlite instead of some other database library?  Most, though not all, database
            libraries work in a client server environment.  In this environment, new databases
            must be created by requesting them from a database administrator.  Sqlite, however
            stores its database in an ordinary file.  This means no overhead is required to create
            dabases and you can hand out databases to your collaborators as simply as handing them
            the database file.
        </para>
        <para>
            All of this comes at one cost.  Sqlite, provides only a single writer and multiple
            reader model.  With a lot of fancy footwork in detecting and responding to database locked
            conditions, this can be overcome, however one writer and a single reader is not normally
            a hindrance in this application.
        </para>
    </chapter>
    <chapter>
       <title>What you can do with the SpecTcl Sqlite database package.</title>
       <para>
        Databases are useful when storing data that has some well defined format and
        capturing the relationships between those data.  SpecTcl data analysis
        configurations, spectra and even event data match that description.
        Below, let's look at glossary of terms that will be used throughout
        the rest of this manual.  The glossary will also give an idea
        of what the SpecTcl Sqlite data package can do in conjunction with SpecTcl.
       </para>
       <variablelist>
        <varlistentry>
           <term>Database</term>
           <listitem>
               <para>
                In this manual database means a relational database, specifically
                and sqlite3 database.  Sqlite3 databases live in a file. While
                there are mechanisms to join several files together int one
                database, these are not used by this package.
               </para>
               <para>
                Relational databases have a schema that describes a set of tables.
                Each table has several fields.  Fields in one table can link
                rows of that table to rows of a nother table.  These are the
                relations in relational databases.
               </para>
               <para>
                The SpecTcl database package provides schema definitions
                and code to manipulate an Sqlite3 database file to store
                several types of objects interesting to SpecTcl.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Save Set</term>
           <listitem>
               <para>
                A saved set is a named entity that stores objects.  Save sets
                are analgous to directories.  Each save set owns a set of objects
                that are stored and can be retrieved.  Save sets provide a
                mechanism for users to organize the data saved in the database
                and to tag related data with a user friendly name.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Configuration</term>
           <listitem>
               <para>
                One of the things that can be stored in a save set is a configuration.
                A configuration is the SpecTcl analysis configuration at some
                point in time.  This includes parameter and tree parameter
                definitions, Spectrum definitions, gate definitions, the application
                of gates to spectra and tree variables and their values.
               </para>
               <para>
                Configurations represent repeatable SpecTcl analysis conditions.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Spectra</term>
           <listitem>
               <para>
                SpecTcl's purpose in life is to produce histograms, which it
                calls spectra.  The contents of one or more spectra can be saved
                 in a save set.   This represents the products of an analysis
                 of a specific run.  It is normal, though not required, that
                 spectra be saved in the same saveset as the configuration
                 that produced them.
               </para>
            </listitem>
        </varlistentry>
        <varlistentry>
           <term>Event Data</term>
           <listitem>
               <para>
                When SpecTcl analyzes raw data, either from a data file or
                from an online data source, the first thing it does
                is pass each event through a user define event processing
                pipeline.  The purpose of that pipeline is to extract useful
                parameters from the raw data into raw parameters or tree parameters.
                SpecTcl then histograms these unpacked parameters.
               </para>
               <para>
                It is possible to save the parameters extraced from raw data
                for a run in a save set.  When this done, subsequent playback
                of the run from the save set is much faster than from the
                original raw data set.  This is because the entire user
                event processing pipline, which is normally where the majority
                of the time is spent, is completely bypasssed.  
               </para>
               <para>
                This capability provides a mechanism to quickly reply  runs over
                and over again, optimizing the analysis configuration in SpecTcl.
                It also provides an analysis neutral format from which, theoretically,
                any other analysis program can analyze the data.
               </para>
            </listitem>
        </varlistentry>
       </variablelist>
    </chapter>
    <chapter>
        <title>C++ Low level API</title>
        <para>
            This section provides an overview of the C++ classes that make up the
            database API.  Before we start, the API philosophy is that you
            will write once, never modify but restore several times.
            As such you'll see that there are no methods supporting
            either removing entities saved in the database or, with the exception
            of saved spectrum contents, modifying existing stored objects.
            This is a design choice and not an oversight.
        </para>
        <para>
            The API consists of several classes all living in the <literal>SpecTclDB</literal>
            namespace:
        </para>
        <variablelist>
            <varlistentry>
               <term><classname>CDatabase</classname></term>
               <listitem>
                   <para>
                    Represents database files.  Methods in this file allow you
                    to create a properly initialized database file, connect
                    to the file, create and get information about the save set
                    objects in the file.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>SaveSet</classname></term>
               <listitem>
                   <para>
                    This class represents save set objects.  Given a database
                    object, one can create savesets in that data base and
                    load them.  Given a save set object, one can create
                    and manipulate any of the objects in the save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBParameter</classname></term>
               <listitem>
                   <para>
                    These represent parameter definitions within a save set.
                    This class can create and lookup parameter definitions
                    give a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBSpectrum</classname></term>
               <listitem>
                   <para>
                    Represents spectrum objects within a save set.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBGate</classname></term>
               <listitem>
                   <para>
                    Represents a gate object in a saveset.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><classname>DBApplication</classname></term>
               <listitem>
                   <para>
                    Represents the application of a gate to a spectrum.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term>DBTreeVariable</term>
               <listitem>
                   <para>
                    Represents a tree variable saved in a save set.
                   </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The Top level classes, <classname>CDatabase</classname> and
            <classname>SaveSet</classname> are written so that normally,
            you will not have to create or manually lookup the other
            individual objects.
        </para>
        <section>
            <title><classname>SpecTclDB::CDatabase</classname></title>
            <para>
                This section will introduce the <classname>CDatabase</classname>
                class through a set of simple examples.  These examples
                include code fragments that:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Create and attach a database. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Create and lookup a save set. 
                   </para>
                </listitem>
                <listitem>
                   <para>
                      List the savesets that are already known to a database.
                   </para>
                </listitem>
            </orderedlist>
             <para>
                These examples and a sample Makefile built along the lines
                described below are installed in the
                <filename>share/dbexamples</filename> directory of SpecTcl's installation
                directory tree.
             </para>
            <para>
                If you intend to do serious programming with this class library,
                you should study the reference material in the appendix.
            </para>
            <para>
                Before we can write any code, we need to be able to link
                compile and link our programs to this library. This requires
                a set of compilation and link flags.  In both cases below, in order
                to factor out the distribution directory for SpecTcl, we'll assume
                that the environment variable SPECTCLHOME is defined to be the
                top level directory of the SpecTcl installation  you are using.
                Note that environment variables are imported to Makefiles as
                Makefile variables (e.g. $(SPECTCLHOME) is the environment variable
                SPECTCLHOME).  SpecTcl depends on Root so we're also going to
                assume that ROOTSYS is defined and points to the directory
                from wich SpecTcl was linked with root.  As of version 5.3-007,
                the $SPECTCLHOME/VERSION file will tell you the value used for
                ROOTSYS.
            </para>
            <formalpara>
                <title>Compilation flags:</title>
                <para>
                    Compilation flags must ensure that the SpecTcl Headers
                    <variablelist>
                        <varlistentry>
                           <term><literal>-I$SPECTCLHOME/include</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's include file
                                directory searchable for <literal>#include</literal>
                                directives in your source code.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <formalpara>
                <title>Link flags</title>
                <para>
                    <variablelist>
                        <varlistentry>
                           <term><literal>-L$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Makes the SpecTcl installation's library directory
                                searchable for libraries on the link line.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$SPECTCLHOME/lib</literal></term>
                           <listitem>
                               <para>
                                Adds the SpecTcl library directory to the search
                                path used by the run time loader to locate shared
                                libraries needed by your program.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-Wl,-rpath=$ROOTSYS/lib</literal></term>
                           <listitem>
                               <para>
                                Adds root's library directory to the shared object
                                load search path.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSpecTclDb</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl database API.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lTclGrammerApp</literal></term>
                           <listitem>
                               <para>
                                Pulls in the SpecTcl main library.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lSqlite3pp</literal></term>
                           <listitem>
                               <para>
                                Pulls in a C++ encapsulation of sqlite3.
                               </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>-lsqlite3</literal></term>
                           <listitem>
                               <para>
                                Pulls in the Sqlite3 API.
                               </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </formalpara>
            <para>
                A final note.  If root was not built with internal -rpath's
                turned on the sample program in this manual (and even
                SpecTcl itself) may fail with an error like
            </para>
            <para>
                <literal>
                    ./makedb: error while loading shared libraries: libvdt.so:
                cannot open shared object file: No such file or directory
            </literal>
                If that is the case then set up the full Root environment
                by $ROOTSYS/bin/thisroot.sh
            </para>
            <para>
                Let's look at the simplest example.  A complete program
                that creates an empty database. The program takes a
                databsae filename on the command line as a single argument.
            </para>
            <example>
                <title>Createing an empty database (makedb.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;               <co id='makedb.includes' />
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makedb db-filenme\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::CDatabase::create(argv[1]);          <co id='makedb.create' />

  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='makedb.includes' >
                    <para>
                        Including this header brings the class definition of
                        <classname>SpecTclDB::CDatabase</classname> into our
                        program.
                    </para>
                </callout>
                <callout arearefs='makedb.create' >
                    <para>
                        This line creates a new empty database. The
                        static method <methodname>create</methodname> in
                        <classname>SpecTclDB::CDatabase</classname> takes
                        a null terminated (C) string and creates a new database
                        in that file.
                    </para>
                    <para>
                        It is not harmful to call this on a database file that
                        has already been initialized with the SpecTcl database
                        schema as the SQL used is of the form
                        <literal>CREATE ... IF NOT EXISTS</literal>.
                    </para>
                    <para>
                        Using this method on an existing database file used for
                        another purpose will add the schema needed to
                        also use that file as a SpecTcl database; as long
                        as there are no collisions in table and index names.
                    </para>
                    <para>
                        Using this method on a file that is not an sqlite database
                        will result in an error message indicating the file is
                        not a database file.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at another simple full program.  This
                program will open an existing  database and create a saveset
                named <literal>a saveset</literal> in the database.
                The program will also demonstrate very simple error detection.
            </para>
            <example>
                <title>Creating savesets in a database (makesaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;                <co id='makesvset.savesetheader' />
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: makesaveset database-name\n";
    exit(EXIT_FAILURE);
  }
  try {
    SpecTclDB::CDatabase db(argv[1]);     <co id='makesvset.opendb' />

    SpecTclDB::SaveSet* pSaveset = db.createSaveSet("a saveset"); <co id='makesvset.makeset' />
    delete pSaveset;
  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl; <co id='makesvset.errors' />
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);

}

                </programlisting>
            </example>
            <calloutlist>
               <callout arearefs='makesvset.savesetheader' >
                <para>
                    We'll be using a method from the
                    <classname>SpecTclDB::SaveSet</classname> class. This
                    <literal>#include</literal> pulls the definition of that
                    class and its methods into our program.
                </para>
               </callout>
               <callout arearefs='makesvset.opendb' >
                   <para>
                    In the previous example, we saw that the static
                    <methodname>create</methodname> method for the
                    <classname>SpecTclDB::CDatabase</classname> class
                    created and initialized a database file.  The
                    <classname>SpecTclDB::CDatabase</classname> class constructor
                    creates a database object that is connected to an already
                    created database file.
                </para>
               </callout>
               <callout arearefs='makesvset.makeset' >
                   <para>
                    This line asks the database object to create a new saveset.
                    On success, a pointer to the saveset object that encapsulates
                    the saveset in the database is created. Note that savesets
                    must have unique names.  Try running this program on
                    the same database twice.
                </para>
               </callout>
               <callout arearefs='makesvset.errors' >
                   <para>
                        The database API reports errors by throwing exceptions that
                        are derived from <classname>std::exception</classname>.
                        Errors, therefore are handled by this catch block. Any
                        meaningful message held by the exception object is
                        reported here.
                    </para>
                    <para>
                        If you do try the experiment of runing this program
                        on a saveset twice, this code will tell you the
                        saveset already exists.
                    </para>
               </callout>
            </calloutlist>
            <para>
                As an excersise, modify this program to accepts, as a second
                parameter, the name of the save set to create.  In the
                next, and last example in this section,
                we'll list the names of all of the savesets
                in a database.
            </para>
            <example>
                <title>Listing savesets (lssaveset.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cerr &lt;&lt; "Usage: lssaveset db-filename\n";
    exit(EXIT_FAILURE);
  }
  SpecTclDB::CDatabase db(argv[1]);
  auto savesets = db.getAllSaveSets();                 <co id='lssvset.getall' />
  std::cout &lt;&lt; " Save sets in " &lt;&lt; argv[1] &lt;&lt; std::endl; 
  for (int i =0; i &lt; savesets.size(); i++) {
    std::cout &lt;&lt; savesets[i]-&gt;getInfo().s_name &lt;&lt; std::endl; <co id='lssvset.name' />
    delete savesets[i];                                  <co id='lssaveset.del' />
  }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='lssvset.getall' >
                    <para>
                        The <methodname>getAllSaveSets</methodname> of
                        <classname>SpecTclDB::CDatabase</classname> returns
                        an indexable collection of pointers to the save set
                        objects that encapsulate all of the savesets in the
                        database.
                    </para>
                    <para>
                        A look at the header will tell you that <varname>savesets</varname>
                        is actually a
                        <classname>std::vector&lt;SpecTclDB::SaveSet*&gt;</classname>.
                        We could have used that type declaration.  There are
                        a couple of reasons we didn't. One sensible the other lazy.
                        By letting the compiler figure out the actual type
                        for <varname>savesets</varname>, the implementation of
                        <methodname>getAllSaveSets</methodname> could change and,
                        as long as the type returned suported
                        <methodname>size</methodname> and
                        <methodname>operator[]</methodname>, our code would
                        not need to change.  Second, this saved us a bunch of
                        typing in the code, at the cost of this paragraph
                        of explanation.
                    </para>
                </callout>
                <callout arearefs='lssvset.name' >
                    <para>
                        Saveset objects have a
                        <methodname>getInfo</methodname> method.  This method
                        returns a const reference to a struct that contains
                        information cached from the database about the saveset.
                        The <structfield>s_name</structfield> field of this
                        struct contains a printable name (actually a
                        <classname>std::string</classname>).
                    </para>
                </callout>
                <callout arearefs='lssaveset.del' >
                    <para>
                        Since <methodname>getAllSaveSets</methodname> dynamically
                        creates the save set objects it returns, these must be
                        <literal>delete</literal>-d as they are no longer needed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The SpecTclDB::SaveSet class.</title>
            <para>
                Save sets are where data are stored. Save sets are used to organize
                data into named containers.  Each container has a name,
                a creation timestamp and a unique integer identifier.   The
                identifier is used to link other objects back to the save set
                that owns them in the <literal>save_sets</literal> table of the
                database.  See the description of the database schema in the
                reference appendix for more information.
            </para>
            <para>
                In this section we'll show a few examples of the the
                <classname>SpecTclDB::SaveSet</classname> class in action.  We're
                only going to look at the object methods of the
                <classname>SpecTclDB::Saveset</classname> class.  There are
                some static methods, but they are intended for use by
                the <classname>SpecTclDB::CDatabase</classname> class not us.
            </para>
            <para>
                We're going to look at the Savesets through the lens of the following
                examples (installed in the <filename>share/dbexamples</filename>
                directory of the SpecTcl installation).
                These examples will:
            </para>
            <itemizedlist>
                <listitem>
                   <para>
                       Show how to define parameters and get
                       information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Show how to save spectrum definitions and
                      retrieve information about them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save the definition of
                      several broad categories of
                      gates, and retrieve information about
                      them.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to save information about which gates
                      are applied to conditionalize the
                      increments of which spectra.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      How to store information about
                      tree variables and retrieve it.
                   </para>
                </listitem>
                <listitem>
                    <para>
                        How to store and retrieve
                        decoded events,
                        and scaler readouts in a
                        saveset.
                    </para>
                </listitem>
            </itemizedlist>
            <example>
                <title>Defining parameters (pardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;      <co id='pardef.paramhdr' />

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
  if(argc != 2) {
    std::cerr &lt;&lt; "Usage:  pardef db-filename\n";
    exit(EXIT_FAILURE);
  }

  SpecTclDB::SaveSet* pSave(nullptr);  <co id='pardef.psave' />
      
  try {
    SpecTclDB::CDatabase db(argv[1]);
    pSave = db.getSaveSet("a saveset"); <co id='pardef.getsvset' />
    delete pSave-&gt;createParameter("p1", 100); <co id='pardef.create' />
    delete pSave-&gt;createParameter("p2", 101, -10.0, 1.0, 100, "cm");

    auto params = pSave-&gt;listParameters(); <co id='pardef.listpars' />
    std::cout &lt;&lt; "The following parameters are defined:\n";
    for (int i =0; i &lt; params.size(); i++) {
      std::cout &lt;&lt; params[i]-&gt;getInfo().s_name &lt;&lt; std::endl;
      delete params[i];
    }
    SpecTclDB::DBParameter* p = pSave-&gt;findParameter("p2"); <co id='pardef.find' />
    std::cerr &lt;&lt; " I found parameter: " &lt;&lt; p-&gt;getInfo().s_name &lt;&lt; std::endl;
    delete p;

  }
  catch (std::exception&amp; e) {
    std::cerr &lt;&lt; "Error: " &lt;&lt; e.what() &lt;&lt; std::endl;
    delete pSave;
    exit(EXIT_FAILURE);
  }

  delete pSave;
  exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='pardef.paramhdr' >
                    <para>
                        Parameters are encapsulated in
                        <classname>SpecTclDB::DBParameter</classname>
                        objects.   This <literal>#include</literal>
                        bring the definition of that class into
                        the program.
                    </para>
                </callout>
                <callout arearefs='pardef.psave' >
                    <para>
                        This will be a pointer to the save set
                        we're manipulating. It's declared here
                        so that it will be in scope in the
                        <literal>catch</literal> block below.
                        That allows us to ensure that the
                        saveset gets freed if there's an
                        exception.
                    </para>
                </callout>
                <callout arearefs='pardef.getsvset' >
                    <para>
                        The <methodname>getSaveSet</methodname>
                        looks up a save set and caches its
                        database defintion into internal data
                        in a <classname>SpecTclDB::SaveSet</classname>.
                        A pointer to this dynamically allocated
                        object is then returned on success.
                        On failure an exception is thrown.
                    </para>
                </callout>
                <callout arearefs='pardef.create' >
                    <para>
                        This line and the next create two parameters.
                        SpecTcl has two raw parameters and
                        <classname>CTreeParameter</classname>
                        parameters.  The latter wrap raw parameters
                        and provide metadata that give hints about
                        how to best histogram the variable and
                        units of measure.
                    </para>
                    <para>
                        The first line stores a parameter
                        definition for a raw parameter. These
                        have a name and a slot number defining
                        how SpecTcl event processors should
                        supply data for this parameter.
                    </para>
                    <para>
                        The second line stores a parameter
                        with full metadata. In addition to the
                        name and number, metadata includes a
                        suggested low limite, a suggested high
                        limit, a suggested binning over that range,
                        and units of measure.  The second line
                        stores a parameter that runs in the range
                        of -10.0 to 10.0 with a suggested binning
                        of 100 bins.  The units of measure
                        are <literal>cm</literal>.
                    </para>
                    <para>
                        Noe that
                        <methodname>createParameter</methodname>
                        returns a pointer to the created parameter
                        object. This object is immediately
                        deleted.
                    </para>
                </callout>
                <callout arearefs='pardef.listpars' >
                    <para>
                        Produces a container with pointers to all
                        parameters.  The pointers are to
                        dynamically allocated objects which
                        must be deleted when no longer needed.
                    </para>
                    <para>
                        Subsequent code iterates over the
                        objects in the container, outputting
                        the names of each parameter and
                        deleting the objects.
                    </para>
                </callout>
                <callout arearefs='pardef.find' >
                    <para>
                        Retrieves a parameter definition by name.  This provides
                        us a container of pointers to <classname>DBParameter</classname>
                        objects.  We'll say more about <classname>DBParameter</classname>
                        later on.  For now you only need to know that this
                        class encapsulates cached information retrieved from
                        the database for a single parameter.
                    </para>
                    <para>
                        A readonly reference to this information can be gotten via
                        the <methodname>getInfo</methodname> method.  The pointers
                        in the container represent pointers to dynamically created
                        objects.  Therefore, once your code is done using one,
                        it should be deleted to avoid memory leaks.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Let's look at a toy program to create spectra in a save
                set and list information about the spectra a save set has.
                For this program:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Refer to the SpecTcl command reference or user's guide for
                      a list of the spectrum types and what they do.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      If you are going to test it, be sure you run it on a
                      database that has had the parameter test program run on it.
                      We will be using the saveset and
                      parameter definitions that we created
                      with that program.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                Note that in general, spectra need a name,
                a spectrum type, a vector of parameters and
                one or two axis definitions.  By default,
                spectra are defined with longword per channel
                storage, but this can be modified.
            </para>
            <example>
                <title>Defining Spectra (specdef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBParameter.h&gt;
#include &lt;DBSpectrum.h&gt;     <co id='specdef.header' />

#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:  specdef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSvSet(nullptr);
    try {
        pSvSet = db.getSaveSet("a saveset");

        std::vector&lt;const char*&gt; s1Params = {"p1"};      <co id='specdef.pars' />
        std::vector&lt;const char*&gt; s2Params = {"p1", "p2"}; 
        SpecTclDB::SaveSet::SpectrumAxis x = {0, 1023, 1024};  <co id='specdef.axes' />
        SpecTclDB::SaveSet::SpectrumAxis y = {-10.0, 1.0, 100};

        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s1axes = {x};
        std::vector&lt;SpecTclDB::SaveSet::SpectrumAxis&gt;
            s2axes = {x, y};

        delete pSvSet-&gt;createSpectrum("s1", "1", s1Params, s1axes); <co id='specdef.def' />
        delete pSvSet-&gt;createSpectrum("s2", "2", s2Params, s2axes);

        auto spectra = pSvSet-&gt;listSpectra();                 <co id='specdef.list' />
        std::cout &lt;&lt; "Names of spectra in saveset:\n";
        for (int i =0; i &lt; spectra.size(); i++) {
            auto&amp; info = spectra[i]-&gt;getInfo();
            std::cout &lt;&lt; info.s_base.s_name &lt;&lt; std::endl; <co id='specdef.info'/>
            delete spectra[i];
        }
    }
    catch (std::exception&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        delete pSvSet;
        exit(EXIT_FAILURE);
    }

    delete pSvSet;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <para>
                We're not going to describe the elements of this example
                that are repeats of code fragments in prior examples.
            </para>
            <calloutlist>
                <callout arearefs='specdef.header' >
                    <para>
                        We will be calling methods of the
                        <classname>DBSpectrum</classname>
                        class, which encapsulates data from
                        a spectrum definition in the database.
                        We'll also be deleting dynamically allocated
                        <classname>DBSpectrum</classname> objects.
                        Both of these require knowledge of the shape of the
                        object given in the class definition.
                        The <filename>DBSpectrum.h</filename> header
                        is included to provide that information
                        to our program.
                    </para>
                </callout>
                <callout arearefs='specdef.pars' >
                    <para>
                        Spectrum are incremented on data from parameters
                        in events.  We defined two parameters in the
                        <filename>pardef.cpp</filename> example;
                        <literal>p1</literal> and <literal>p2</literal>.
                        We're going to be making a 1d and 2d spectrum.
                        These need one and two parameters respectively.
                        The spectrum generating method requires a
                        <classname>std::vector&lt;const char*&gt;</classname>
                        where each element is a pointer to a parameter
                        name that's already been defined. 
                    </para>
                    <para>
                        This line and the next line define the vectors
                        appropriate to the two spectra we'll be creating.
                    </para>
                </callout>
                <callout arearefs='specdef.axes' >
                    <para>
                        Spectra require one or two axes as well.
                        Axes are defined by low, and high limits and
                        binning.  This line and the next define a pair
                        of axes.  Note that the first one is arbitrary,
                        but the second one, uses the low/high binning
                        suggestions in the <literal>p2</literal>
                        parameter definition.  A real program
                        will query that parameter for its axis
                        recommendations.  That's beyond the scope of
                        this example however.
                    </para>
                    <para>
                        The two lines that follow the axis definitions
                        make a one element and two element vector of
                        axis specifications respectively.  Vectors of
                        axis specifications are what the spectrum
                        generating method expects.
                    </para>
                </callout>
                <callout arearefs='specdef.def' >
                    <para>
                        These two lines actually create the spectra.
                        As with parameters, a dynamically allocated
                        pointe to the spectrum object is returned, which
                        we immediately <literal>delete</literal>.
                        The parameters to <methodname>createSpectrum</methodname>
                        are respectively, the name of the spectrum,
                        the spectrum type (<literal>1</literal> is the
                        type of 1d spectra and <literal>2</literal>
                        is the type for 2d spectra).  The parameters needed
                        by the spectrum and the spectrum axes.
                    </para>
                    <para>
                        An optional additional parameter provides
                        a string specification of the data type used
                        for spectrum channels.  This defaults to
                        <literal>long</literal> if not supplied but
                        can also be <literal>word</literal> or
                        <literal>byte</literal>.
                    </para>
                </callout>
                <callout arearefs='specdef.list' >
                    <para>
                        Asks the saveset for a list of the spectra
                        that have been defined.  The return value is
                        an indexable container that holds pointers to
                        dynamically allocated <classname>DBSpectrum</classname>
                        objects.
                    </para>
                </callout>
                <callout arearefs='specdef.info' >
                    <para>
                        The spectrum information struct is complex enough
                        that it is divided into several pieces. The
                        piece selected by <structfield>s_base</structfield>
                        contains the base information about the spectrum,
                        including the type and spectrum name.
                    </para>
                    <para>
                        The loop outputs the name sof all spectra
                        defined in the saveset to standard output.
                    </para>
                </callout>
            </calloutlist>
                        <para>
                The gate definition API in <classname>SavSet</classname>
                is the most complex of the APIs. This is because SpecTcl supports
                a rich set of gate types.  There are are essentially
                three major classes of gate:
            </para>
            <orderedlist>
                <listitem>
                   <para>
                      Gates that specify a region of interest in a subset
                      of the event's parameter space.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a logical operation
                      on other gates.
                   </para>
                </listitem>
                <listitem>
                   <para>
                      Gates that specify a bitwise operation and comparison
                      on a mask applied to a single parameter.
                   </para>
                </listitem>
            </orderedlist>
            <para>
                The point gates are, for convenience, further
                subdivided into
                <firstterm>1-d</firstterm> gates, which specify
                lower and upper bounds that define a slice of valuees,
                and <firstterm>2-d</firstterm> gates, which
                define a 2-d region of parameter space in pairs
                of parameters.
                Regardless of the gate type, all gates are
                encapsulated in a <classname>DBGate</classname>
                class which holds the database information
                describing the gate.
            </para>
            <para>
                The information cached for a gate is similarly
                more complex.  We'll look at that in detail
                in the reference man pages on the
                <classname>DBGate</classname> class.
            </para>
            <para>
                Let's look at a simple program that generates
                one of each type of these gates.  In past examples,
                we've made a token attempt at error handling by
                wrapping the body of the code in a try/catch
                block.  From now on we will not do any error
                handling, for the sake of brevity.
            </para>
            <para>
                This program assums a database that has had
                the <command>makesaveset</command> and
                <command>pardef</command>  example programs
                run on it.
            </para>
            <example>
                <title>Defining gates (gatedef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBGate.h&gt;         <co id='gatedef.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; 'Usage:: gatedef database-name\n";
        exit(EXIT_FAILURE);
    }

    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet*  svset = db.getSaveSet("a saveset");

    std::vector&lt;const char*&gt; p1ds = {"p1"};  <co id='gatedef.1d' />

    delete svset-&gt;create1dGate("1d", "s", p1ds, 100, 200);

    std::vector&lt;const char*&gt; p2ds = {"p1", "p2"};  <co id='gatedef.2d' />
    std::vector&lt;std::pair&lt;double, double&gt;&gt; pts2d {
      {100, 0}, {200, 0}, {200, 200}, {100, 200}
    };
    delete svset-&gt;create2dGate("2d", "c", p2ds, pts2d);

    std::vector&lt;const char*&gt; gatenames={"1d", "2d"};   <co id='gatedef.compound' />
    delete svset-&gt;createCompoundGate("compound", "+", gatenames);

    delete svset-&gt;createMaskGate("mask", "em", "p1", 0x55555555); <co id='gatedef.mask' />

    auto gates = svset-&gt;listGates();   <co id='gatedef.list' />
    std::cout &lt;&lt; "Gates in the saveset:\n";
    for (int i = 0; i &lt; gates.size(); i++) {
        std::cout &lt;&lt; gates[i]-&gt;getInfo().s_info.s_name &lt;&lt; std::endl;
        delete gates[i];
    }

    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='gatedef.header' >
                    <para>
                        The <filename>DBGate.h</filename> header defines
                        the shape and method sof the
                        <classname>SpecTclDB::DBGate</classname> class.
                        We need these definitions because we are going
                        to all methods on class instances and
                        <literal>delete</literal> them.
                    </para>
                </callout>
                <callout arearefs='gatedef.1d' >
                    <para>
                        This section of code creates a 1-d gate.
                        1-d gates define a slice in parameter space.
                        Examples of 1-d gates are slices and gamma slices.
                        Since a gamma slice is defined on any number
                        of parameters, the method that creates 1-d
                        gates needs a vector of parameter names, rather
                        than a single parameter name.
                    </para>
                    <para>
                        Once the parameter name vector is created,
                        we can call
                        <methodname>create1dGate</methodname>
                        passing the name of the new gate, the
                        gate type code (slice in this case), the
                        vector of parameter names the gate needs and
                        the limits of the gate.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        The only difference between a 1d and
                        a 2d gate (e.g. band, contour, gamma contour) is that
                        the shape of the region of interest is defined
                        by a vector of x/y coordinate pairs.  These
                        coordinates are in parameter space (not spectrum space).
                    </para>
                    <para>
                        This section of code creates  a
                        contour gate that consists of a square
                        in the parameter space defined by
                        <literal>p1</literal>, <literal>p2</literal>.
                    </para>
                </callout>
                <callout arearefs='gatedef.compound' >
                    <para>
                        Compound gates define a logical combination
                        of existing gates; for example a gate that
                        is true if all component gates are true or a gate that is
                        true if any of the component gates is true.
                        The  not gate is also a compound gate that
                        depends on exactly one gate.  Similarly, True and False
                        gates are compound gates that depend on no
                        other gate.
                    </para>
                    <para>
                        This section of code creates a compound gate
                        that is true when either of the 1d or
                        2d gates we previously created is true.
                    </para>
                </callout>
                <callout arearefs='gatedef.mask' >
                    <para>
                        A mask gate performs specific bitwise operations
                        on parameters that are presumed to actually be
                        integers.  The result of those bitwise
                        operations determines the truth or falsity
                        of a gate.
                    </para>
                    <para>
                        This section of code creates an
                        <firstterm>equal mask gate</firstterm>.
                        The bitmask is bitwise anded with the
                        value of the parameter on each event and,
                        if the result is equal to that mask, the
                        gate is satisfied.
                    </para>
                </callout>
                <callout arearefs='gatedef.list' >
                    <para>
                        This section of code lists the gates
                        in the save set. The method
                        <methodname>listGates</methodname> returns a container
                        that has pointers to <classname>SpecTclDB::DBGate</classname>
                        that contain cached information about all gates defined
                        for the saveset in the database.
                        The <classname>SpecTclDB::DBGate</classname> objects
                        are dynamically created and, therefore,
                        must be deleted when you no longer need them.
                    </para>
                    <para>
                        As with all database objects, the
                        <methodname>getInfo</methodname> method
                        returns a const reference to a struct
                        that defines the information in the
                        database for the gate.  For gates, this
                        struct has quite a few sub-pieces. The
                        <structfield>m_info</structfield> sub
                        structure contains base information all
                        gates have.  The <structfield>s_name</structfield>
                        field in that struct is an
                        <classname>std::string</classname>
                        containing the gate's name.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Gates, by themselves are useless.  They only have meaning, and in
                SpecTcl are only evaluated, if they are applied
                to a spectrum or spectra. When a gate is applied
                to a spectrum, that spectrum can only be incremented
                for events that make that gate true.
            </para>
            <para>
                All SpecTcl spectra have exactly one gate applied
                to it at all times.  When initially created, a SpecTcl
                spectrum has a pre-defined True gate applied to it. By convention,
                there's no need to save either that true gate
                nor the application of true gates to spectra.
            </para>
            <para>
                Note that the database does not enforce the
                requirement that only one gate is applied at any
                time to any spectrum.  Restoring from a saveset
                that applies more than one gate to a spectrum
                will result in the application of one of those
                gates (unpredictably), to the spectrum.  The
                code used by SpecTcl to create savesets ensures this
                does not happen.
            </para>
            <para>
                The example below assumes that the databas it
                is run on has hasd
                <command>makesaveset</command>, <command>pardef</command>,
                <command>gatedef</command> and
                <command>specdef</command>previously
                run on it.
            </para>
            <example>
                <title>Applying gates to spectra (applydef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBApplications.h&gt;            <co id='applydef.header' />


#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: applydef database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;applyGate("1d", "s2");    <co id='applydef.apply' />
    delete svset-&gt;applyGate("compound", "s1");

    auto applications = svset-&gt;listApplications();
    std::cout &lt;&lt; "Gate applications\n";   <co id='applydef.list' />
    for (int i = 0; i &lt; applications.size(); i++) { 
        std::cout &lt;&lt; applications[i]-&gt;getGateName()
                  &lt;&lt; " is applied to "
                  &lt;&lt; applications[i]-&gt;getSpectrumName() &lt;&lt; std::endl;
        delete applications[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);

}                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='applydef.header' >
                    <para>
                        The <filename>Applictions.h</filename>
                        header defines the
                        <classname>SpecTclDB::DBApplication</classname>
                        class which encapsulates gate application
                        records in the database.
                        Including this file allows us to delete
                        instances of this class as well as call
                        methods on instances.
                    </para>
                </callout>
                <callout arearefs='applydef.apply' >
                    <para>
                        To save a gate application, we only need
                        provide the name of the gate and the
                        name of the spectrum it should be applied
                        to to the
                        <methodname>applyGate</methodname> method
                        of the saveset.
                    </para>
                </callout>
                <callout arearefs='applydef.list' >
                    <para>
                        This section of code lists the gate applications.
                        A good question is why we didn't just use
                        <methodname>getInfo</methodname> and list
                        out information cached there.  The answer
                        is that the information structure contains
                        information that's stored in the database for
                        the application.  In keeping with holding
                        the database in a normal form, the gate
                        and spectra are stored as foreign keys into
                        the gate and spectrum definitions tables.
                    </para>
                    <para>
                        <methodname>getGateName</methodname> and
                        <methodname>getSpectrumName</methodname>
                        use those values to look up the actual
                        gate and spectrum names.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Sometimes we want to write computations that can
                be steered at run-time.  For example, suppose we want to apply a
                linear energy calibration to a raw ADC parameter.  This
                calibration requires two values, a slope and offset.
                These values will not, in general, be known in advance
                but must be determined.
            </para>
            <para>
                Tree variables wrap Tcl variables in a way that makes them
                easy for the user to set and modify yet appear
                like ordinary double precision values to the C++
                code.  In addition tree variables have associated,
                with them units of measure to remind users how
                to properly set them (was that slope counts/KeV, counts/MeV?).
            </para>
            <para>
                Being able to save the analysis conditions so that
                they can be repeatably restored requires that
                tree variable definitions and values be saved
                in the database as well.
            </para>
            <para>
                The C++ API for tree variables is demonstrated
                in the example below.
            </para>
            <example>
                <title>Saving and recovering tree variables (vardef.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;DBTreeVariable.h&gt;  <co id='tv.header' />

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char** argv)
{
    if (argc !=2) {
        std::cerr &lt;&lt; "Usage: vardb database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* svset = db.getSaveSet("a saveset");

    delete svset-&gt;createVariable("p1.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("p1.offset", 0.0, "KeV");   <co id='tv.create' />

    delete svset-&gt;createVariable("p2.slope", 1.0, "KeV/Counts");
    delete svset-&gt;createVariable("ps.offset", 0.0, "KeV");

    auto vars = svset-&gt;listVariables();      <co id='tv.list' />
    std::cout &lt;&lt; " Tree variables: \n";
    for (int i = 0; i &lt; vars.size(); i++) {
        const auto&amp; info = vars[i]-&gt;getInfo();
        std::cout &lt;&lt; info.s_name &lt;&lt; " = " &lt;&lt; info.s_value
                  &lt;&lt; info.s_units &lt;&lt; std::endl;

        delete vars[i];
    }
    delete svset;
    exit(EXIT_SUCCESS);
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='tv.header' >
                    <para>
                        The <filename>DBTreeVariable.h</filename>
                        header defines the <classname>SpecTclDB::DBTreeVariable</classname>
                        class which is wraps a database definition
                        for a tree variable.
                    </para>
                </callout>
                <callout arearefs='tv.create' >
                    <para>
                        These lines create four tree variables.
                        These might be initial value for a linear
                        calibration.  Each call to
                        <methodname>createVariable</methodname>
                        needs a variable name, its current value
                        and units of measure.  It is customary
                        to use an empty string as the units
                        of measure for unit-less values.
                    </para>
                </callout>
                <callout arearefs='tv.list' >
                    <para>
                        This section of code lists the tree
                        variables that are defined in this save
                        set, their values and units of measure.
                        Note that since
                        <methodname>listVariables</methodname>
                        returns a container of pointers to dynamically
                        created objects, we <literal>delete</literal>
                        each pointer after we are done with it.
                    </para>
                </callout>
            </calloutlist>
            <para>
                One of the more powerful features of the SpecTcl
                database is its ability to store pre-decoded parameters
                and playing back runs from the databsae.
                This is analagous to loading Root Trees (which SpecTcl
                can also do).  
            </para>
            <para>
                This allows the user to rapidly try out different
                analysis conditions.   Rapidly because normally the
                user's data anlysis pipeline, the code that extracts parametes
                from raw data, is the most computationally expensive
                part of SpecTcl.  Reading events from the database allows
                the data analysis pipeline to be bypassed.
            </para>
            <para>
                The examples that show the API for storing and
                reading back event data are somewhat more complex.
                They will also need to rely on the existence of
                some source of data and some sink of data.
                These will be trivial sources, and not described
                in detail in the examples.
            </para>
            <example>
                <title>Storing event data (evtstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
                         <co id='evtstore.crevent' />
void createEvent(std::vector&lt;int&gt;&amp; params, std::vector&lt;double&gt;&amp; values)
{

    for (int i =0; i &lt; 100; i++) {
        if (drand48() &lt; 0.5) {
            params.push_back(i);
            values.push_back(drand48()*200.0 - 100.0);
        }
    }
}

int main(int argc, char** argv)
{
    if (argc != 3) {
        std::cerr &lt;&lt; "Usage:  evtstore db-filename nevents\n";
    }
    const char* dbFile = argv[1];
    int         nEvents = strtoul(argv[2], nullptr, 0);

    SpecTclDB::CDatabase db(dbFile);
    SpecTclDB::SaveSet* pSaveSet = db.getSaveSet("a saveset");

    int runId =                      <co id='evtstore.start' />
        pSaveSet-&gt;startRun(1, "Some junk Data", time(nullptr));

    std::vector&lt;int&gt; params;
    std::vector&lt;double&gt; values;
    srand48(time(nullptr));           <co id ='evtstore.init' />
    void* ctx = pSaveSet-&gt;startEvents(runId);  <co id='evtstore.trans' />
    for (int i =0; i &lt; nEvents; i++) {
        params.clear();
        values.clear();             // new event.
        createEvent(params, values);
        pSaveSet-&gt;saveEvent(                   <co id='evtstore.save' />
            runId, i, params.size(), params.data(), values.data()
        );

        if (i %100 == 0) {    // every 100 events commit the transaction.
            pSaveSet-&gt;endEvents(ctx);         <co id='evtstore.commit' />
            ctx  = pSaveSet-&gt;startEvents(runId);
        }

    }
    pSaveSet-&gt;endEvents(ctx);                <co id='evtstore.commit2' />

    pSaveSet-&gt;endRun(runId, time(nullptr));  <co id='evtstore.endrun' />
    delete pSaveSet;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtstore.crevent' >
                    <para>
                        This function creates an event. It
                        takes references to  a pair of vectors.
                        The integer vector is filled in with
                        numbers of parameters that are present
                        while the vector of doubles is filled in
                        whith parameter values for that parameter
                        in this event.
                    </para>
                    <para>
                        There are 100 parameters.  In any given
                        event, there's a 50% chance a parameter is present.
                        The parameter values are uniformly distributed
                        random numbers in the range [-100.0, 100.0)
                        because <function>drand48</function>
                        produces pseudo randoms in the range
                        [0, 1)
                    </para>
                </callout>
                <callout arearefs='evtstore.start' >
                    <para>
                        The <methodname>startRun</methodname>
                        indicates we are starting to store data for a run.
                        Normally this will be intermixed event
                        and scaler data.  For this example, we're
                        only storing events.  The run number must
                        be unique within the save set. The
                        return value is an integer that identifies
                        the run and must be used in most
                        of the methods we'll call in the future.
                    </para>
                    <para>
                        Only a run start time is provided.
                        The assumption is that we are reading data
                        from some serial data source and won't
                        know the end time for the run until
                        we reach data for the end of the run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Our event generator uses the pseudo random number generators.
                        This code ensures those generators are seeded with an
                        undeterministic value.  If you omit this
                        line, the program will still work but the
                        random number generators will be seeded
                        with a deterministic value and the
                        results of each run will be the same
                        from program run to program run.
                    </para>
                </callout>
                <callout arearefs='evtstore.init' >
                    <para>
                        Individual database stores can be expensive.
                        Sqlite provides a mechanism for batching up
                        a bunch of stores into an atomic
                        <firstterm>transaction</firstterm>, these
                        transactions are called savesets.  
                    </para>
                    <para>
                        This line starts a transaction for storing
                        events and gets a <type>void*</type>
                        back which we call a context.
                        The context identifies the transaction
                        suc that it can be rolled back or committed
                        by the code at a later date.
                    </para>
                </callout>
                <callout arearefs='evtstore.save' >
                    <para>
                        This line saves an event. The
                        <methodname>data</methodname> method of
                        <classname>std::vector</classname> returns
                         a pointer to the contiguous storage used by the
                         event for he current transaction.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit' >
                    <para>
                        Every 100 events, we commit the
                        transaction we started with our call to
                        <methodname>startEvents</methodname>.
                    </para>
                    <para>
                        It is also possible to decide not to
                        store any events from a transaction
                        but doing that is beyond the scope of this
                        example.
                    </para>
                </callout>
                <callout arearefs='evtstore.commit2' >
                    <para>
                        Performs the commit for any partial
                        block of events.
                    </para>
                </callout>
                <callout arearefs='evtstore.endrun' >
                    <para>
                        Closes off the run by providing the
                        end run time.
                    </para>
                </callout>
            </calloutlist>
            <para>
                The next program will read the event data
                we stored in the previous example and dump
                every 50 events to stdout. Note that the
                parameter numbers are intended to be the
                <parameter>number</parameter> parameter
                passed to the <methodname>createParameter</methodname>
                method in the database.  In SpecTcl these
                correspond to parameter ids, slots in the
                <classname>CEvent</classname> object passed
                between the members of the event processing
                pipeline.  
            </para>
            <para>
                In SpecTcl, using <classname>CTreeParameter</classname>
                and <classname>CTreeParameterArray</classname> objects
                hides but does not eliminate this parameter number.
                What this number is <emphasis>not</emphasis>
                is the value of the primary key of a parameter
                definition.
            </para>
            <example>
                <title>Recovering event data (evtget.cpp)</title>

                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;

#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;


// accept data:
                    <co id='evtget.sink' />
void sink(const SpecTclDB::SaveSet::Event&amp; event)
{
    static int evt = 0;
    if ((evt % 50) == 0) {
      std::cout &lt;&lt; "Dumping event " &lt;&lt; evt &lt;&lt; ":\n";
        for (int i =0; i &lt; event.size(); i++)  {
            std::cout &lt;&lt; "   param# " &lt;&lt; event[i].s_number
                &lt;&lt; " = " &lt;&lt; event[i].s_value &lt;&lt; std::endl;
        }
    }
    evt++;
}


int main (int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: evtget db-filename\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pSet = db.getSaveSet("a saveset");

    int runid = pSet-&gt;openRun(1);    <co id='evtget.open' />
    void* ctx = pSet-&gt;openEvents(runid); <co id='evtget.evts' />

    SpecTclDB::SaveSet::Event event;
    while(pSet-&gt;readEvent(ctx, event)) {  <co id='evtget.read' />
        sink(event);
    }

    pSet-&gt;closeEvents(ctx);     <co id='evtget.close' />
    delete pSet;

    exit(EXIT_SUCCESS);
}

                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evtget.sink' >
                    <para>
                        This function is a stand in for whatever
                        processing you might do on events.
                        For our toy example, it just dumps the
                        data from every 50'th event.
                    </para>
                </callout>
                <callout arearefs='evtget.open' >
                    <para>
                        <methodname>openRun</methodname>
                        accepts a run number and returns the
                        id (primary key) identifying that run
                        in the database.  This can be used in other
                        calls to retrive information about
                        event data and scalers.
                    </para>
                </callout>
                <callout arearefs='evtget.evts' >
                    <para>
                        Getting events back from the database
                        requires iteration through the result set
                        from a query.  Doing this requires
                        that some context allowing the result set to be
                        identified must be held and saved.
                        <methodname>openEvents</methodname> performs
                        the query for the events that belong to the
                        run and returns a context that refers to the
                        result set.
                    </para>
                </callout>
                <callout arearefs='evtget.read' >
                    <para>
                        <methodname>readEvent</methodname>
                        takes the result set context gotten above
                        and fills in the <parameter>event</parameter>
                        parameter with the next event for that
                        run in the database.
                    </para>
                    <para>
                        As we've seen from the previous example
                        (<filename>evtstore.cpp</filename>),
                        parameters in an event can form a sparse set.
                        The data stored for an event only consists of the
                        parameters that have data for that event.
                        <methodname>readEvents</methodname> fills
                        in an indexable container (<classname>Event</classname>)
                        which contains the parameter numbers and
                        parameter values for parameters with data
                        for an event.
                    </para>
                    <para>
                        note that this can be trivially turned into
                        a <classname>CEvent</classname> object
                        by SpecTcl. With a bit of a table lookup
                        it can also be trivially marshalled into a root tree
                        leaf.
                    </para>
                </callout>
                <callout arearefs='evtget.close' >
                    <para>
                        <methodname>closeEvents</methodname>
                        releases all resources that were associated
                        with the result set gotten from
                        <methodname>openEvents</methodname>.
                    </para>
                </callout>
            </calloutlist>
            <para>
                In addition to storing decoded event data, the
                database schema supports storing and retrieving
                the results of scaler reads.  The next pair of
                examples exercise this capability.
            </para>
            <example>
                <title>Storing scaler readouts (sclstore.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;


std::vector&lt;uint32_t&gt; getScalers()  <co id='sclstore.produce' />
{
    static uint32_t       chan1 = 0;
    std::vector&lt;uint32_t&gt; result;
    for (int i = 0; i &lt; 32; i++) {
        result.push_back(chan1*i);
    }

    chan1++;
    return result;
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage: sclstore database-name\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    time_t now =time(nullptr);
    int offset = 0;
    int runid = pS-&gt;startRun(2, "This is run 2", now);

    // simulate Read every 10 seconds 100 times:

    for (int i = 0; i &lt; 100; i++) {   <co id='sclstore.save' />
        now += 10;
        auto scalers = getScalers();
        pS-&gt;saveScalers(
            runid, 1, offset, offset+10, 1, now, 32, scalers.data()
        );
        offset += 10;
    }
    pS-&gt;endRun(runid, now);

    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <para>
                We've already seen show to record the start and
                end of run information, therefore, we won't
                repeat that discussion here.
            </para>
            <calloutlist>
                <callout arearefs='sclstore.produce' >
                    <para>
                        We need something to generate our scaler
                        data.  normally, these will come from ring items.
                        In SpecTcl event processors, the
                        <methodname>OnOther</methodname> method allows you to
                        catch and process scaler data.  SpecTcl's
                        code to write event data to the database h as an
                        implementation for this method that decodes
                        the scaler ring item and writes it to the
                        database.
                    </para>
                    <para>
                        In this case, since we are just writing a
                        sample program, we'll just generate 32
                        scaler values that change somewhat each time.
                    </para>
                </callout>
                <callout arearefs='sclstore.save' >
                    <para>
                        This loop simulates the scaler readouts
                        for a run that's 1000 seconds long with scaler
                        readouts every 10 seconds.
                        <methodname>saveScalers</methodname> takes
                        the run Id to associate the scalers with the
                        correct run.  It also takes two offset
                        values representing the start and end time into
                        the run over which the scalers counted.
                        The next parameters is a divisor. If you
                        divide the start and end times by the
                        divisor you should get the number of seconds
                        into the run for each of those values. This supports
                        offsets that have sub-second precision.
                        Following the divisor is a clock timestamp
                        indicating when this read took place.
                        The final pair of parameters is the
                        number of scalers and a pointer to them.
                    </para>
                </callout>
            </calloutlist>
            <example>
                <title>Recovering scaler readouts (sclget.cpp)</title>
                <programlisting>
#include &lt;SpecTclDatabase.h&gt;
#include &lt;SaveSet.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

                       <co id='sclget.process' />
void processScalers(const SpecTclDB::SaveSet::ScalerReadout&amp; readout)
{
    double start = readout.s_startOffset;
    start /= readout.s_divisor;
    double end   = readout.s_stopOffset;
    end   /= readout.s_divisor;
    std::cout &lt;&lt; "Scaler readout: Sid: " &lt;&lt; readout.s_sourceId
              &lt;&lt; " from " &lt;&lt; start &lt;&lt; " to " &lt;&lt; end &lt;&lt; " seconds into the run \n                  ";
    std::cout &lt;&lt; "Readout occured at: " &lt;&lt; ctime(&amp;readout.s_time) &lt;&lt; std::endl;

    for (int i =0; i &lt; readout.s_values.size(); i++) {
        std::cout &lt;&lt; "   channel " &lt;&lt; i &lt;&lt; " : " &lt;&lt; readout.s_values[i] &lt;&lt; std::                  endl;
    }
    std::cout &lt;&lt; "------------------------------\n";
}

int main(int argc, char** argv)
{
    if (argc != 2) {
        std::cerr &lt;&lt; "Usage:: sclget database-file\n";
        exit(EXIT_FAILURE);
    }
    SpecTclDB::CDatabase db(argv[1]);
    SpecTclDB::SaveSet* pS = db.getSaveSet("a saveset");

    int runid = pS-&gt;openRun(2);
    auto info = pS-&gt;getRunInfo(runid);   <co id='sclget.runinfo' />
    std::cout &lt;&lt; "Dumping scalers for run: " &lt;&lt; info.s_runNumber &lt;&lt; std::endl;
    std::cout &lt;&lt; "Title: " &lt;&lt; info.s_title &lt;&lt; std::endl;
    std::cout &lt;&lt; "Start time: " &lt;&lt; ctime(&amp;info.s_startTime) &lt;&lt; std::endl;
    std::cout &lt;&lt; "End time  : " &lt;&lt; ctime(&amp;info.s_stopTime) &lt;&lt; std::endl;

    void* ctx = pS-&gt;openScalers(runid);  <co id='sclget.open' />
    SpecTclDB::SaveSet::ScalerReadout scalers; <co id='sclget.read' />
    while(pS-&gt;readScaler(ctx, scalers)) { 
        processScalers(scalers);
    }

    pS-&gt;closeScalers(ctx);              <co id='sclget.close' />


    delete pS;
    exit(EXIT_SUCCESS);
}
                    
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='sclget.process' >
                    <para>
                        This function is a stand-in for any processing you
                        might want to do on a scaler readout.
                        In this case we just output information
                        about the scaler read and the channel
                        values to <literal>stdout</literal>.
                    </para>
                </callout>
                <callout arearefs='sclget.runinfo' >
                    <para>
                        The <methodname>getRunInfo</methodname>
                        method fetches top level information
                        about the run given its id
                        (gotten from <methodname>openRun</methodname>).
                        The run number, title, start and stop time
                        are elements of the
                        <type>SpecTclDB::SaveSet::RunInfo</type>
                        struct this method returns.
                    </para>
                </callout>
                <callout arearefs='sclget.open' >
                    <para>
                        As with getting events from the database,
                        scaler readout information is gotten by
                        iterating over the result set from a
                        query executed on the database.
                        <methodname>openScalers</methodname> executes
                        the query and returns a context that
                        can be used to iterate over the result set
                        from that query.
                    </para>
                </callout>
                <callout arearefs='sclget.read' >
                    <para>
                        The <methodname>readScaler</methodname>
                        gets the next result from the result set
                        indicated by the context parameter.
                        The information in that result are loaded
                        into the <type>SpecTclDB::SaveSet::ScalerReadout</type>
                        struct passed to it (by reference).
                    </para>
                    <para>
                        The return value of <methodname>readScaler</methodname>
                        is non zero if there was another result or
                        zero if there was no next result set
                        item.
                    </para>
                    <para>
                        All we do with the data gotten from
                        the database is call
                        <function>processScalers</function>.
                    </para>
                </callout>
                <callout arearefs='sclget.close' >
                    <para>
                        Once you are done iterating over the
                        result set, you must free the resources associated
                        with the context.   This is done by
                        calling <methodname>closeScalers</methodname>
                        passing the context.
                    </para>
                    <para>
                        It is not legal to use the context again, once
                        it has been closed.
                    </para>
                </callout>
            </calloutlist>
        </section>
        
    </chapter>
    <chapter>
        <title>SpecTcl classes that record event data</title>
        <para>
            The database can hold event and scaler data associated
            with a run. These data are placed in a saveset. SpecTcl
            records at most one run per saveset and includes in that
            save set, the analysis conditions in effect at the time
            the run was analyzed.
        </para>
        <para>
            This also allows data from a run to be recorded more than
            once, using differing analysis configurations.
        </para>
        <para>
            This section describes the classes used by SpecTcl
            to record event data.  Note that in most cases, you don't
            need to use these classes.  They are instantiated
            by the SpecTcl database GUI and automatically
            placed in the analysis and data sink piplines as
            requested.
        </para>
        <para>
            These classes are organized into two layers.
            The lowest layer provides an interface between
            runs and the database API.  The upper layer provides
            an interface between SpecTcl's flow of control
            and the lower layer.
        </para>
        <para>
            The lower layer's header is <filename>CDBEvents.h</filename>.
            The upper layer's header is <filename>Events.h</filename>.
        </para>
        <section>
            <title>Lower layer of SpecTcl's event recording/playback code.</title>
            <para>
                The lower layer of SpecTcl's event recording
                and playback system consists of a pair of classes.
                <classname>CDBEventWriter</classname>, as the
                name implies, is used to record unpacked parameters and
                scalers to the database.
                <classname>CDBEventPlayer</classname>, as its name
                implies is used to read event data back from the
                database for a run in a save set.
                <classname>CDBEventPlayer</classname> only reads
                event data.  It does not read scaler data. The
                Tcl SpecTcl interface, however, has a mechanism
                to test for the existence of scaler data and recover
                it for a run in a saveset.
            </para>
            <para>
                <classname>CDBEventWriter</classname>
                the following methods of interest:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>beginRun</methodname>
                       <methodparam>
                           <type>const RingItem* </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method must be the first one called
                        to start recording a run. It provides
                        a ring item, which must be a
                        <literal>BEGIN_RUN</literal> item.
                        It records information about the run
                        and the start time of the run
                        using data in the ring item.
                       </para>
                       <para>
                        This method handles multiple begin runs
                        (as happens in event built data) by only
                        saving information from the first
                        call.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>endRun</methodname>
                       <methodparam>
                           <type>const RingItem*   </type>
                           <parameter>pStateTransition</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        This method should be called when
                        end of run rinng items are available.
                        Note that the code is able to detect
                        multiple ends per run (as will be the
                        case in event built data) and, as with
                        the <methodname>beginRun</methodname>
                        call only saves information from the first one.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>scaler</methodname>
                       <methodparam>
                           <type>const RingItem*   </type><parameter>pScaler</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The <parameter>pScaler</parameter> parameter
                         must be a <literal>PERIODIC_SCALER</literal> ring item.
                         I is added to the scaler readouts for the run.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>event</methodname>
                       <methodparam>
                           <type>CEvent*      </type><parameter>pEvent</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds an event to the database. Note that
                        events are added in bunches for the sake of
                        efficiency.  The bunch size is set at
                        construction time and has a default value
                        that's believed to be reasonable.
                       </para>
                       <para>
                        The <parameter>pEvent</parameter> is a pointer
                        to the object that contains unpacked data from
                        SpecTcl.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>setAutoSaveSpectra</methodname>
                       <methodparam>
                           <type>const std::vector&lt;std::string&gt;&amp;</type>
                           <parameter>spectra</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        The SpecTcl code that manages saving events to the database
                        provides the capability for automatically saving the contents
                        of a set of spectra at the end of the run.
                        THese spectra are referred to as
                        <firstterm>autosaved spectra</firstterm>.
                       </para>
                       <para>
                        This method sets the names of the spectra that will be
                        autosaved from <parameter>spectra</parameter>.
                        Any spectra previously deisgnated as autosaved
                        are no longer autosaved (unless they are in the
                        <parameter>spectra</parameter> parameter).
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>addAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char*</type><parameter> name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Adds the spectrum named by <parameter>name</parameter>
                        to the list of autosaved spectra.  Existing autosaved
                        spectra are not removed from the list.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>void </type>
                       <methodname>removeAutoSaveSpectrum</methodname>
                       <methodparam>
                           <type>const char* </type><parameter>name</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        If the spectrum named <parameter>name</parameter>
                        is in the auto saved list, it is removed from
                        that list.  All other spectra in that list
                        are not affected.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>std::vector&lt;RunInfo&gt; </type>
                       <methodname>listRuns</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns information about all runs saved in the
                        database. The run information includes the
                        name of the saveset it was recorded in.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>CDBEventPlayer*</type>
                       <methodname>playRun</methodname>
                       <methodparam>
                           <type>int</type><parameter>run</parameter>
                        <initializer></initializer>
                       </methodparam>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Locates the first saveset that has the
                        requested <parameter>run</parameter> recorded in it
                        and creates a playback object for that
                        run.
                       </para>
                       <para>
                        See the description of <classname>CDBEventPlayer</classname>.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                To play back data the low level code supplies
                a <classname>CDBEventPlayer</classname>. This
                is constructed on a saveset and  the run number
                of a save set that's known to be stored in
                that saveset.
            </para>
            <para>
                The following methods are then available:
            </para>
            <variablelist>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                       <type>const SpecTclDB::SaveSet::Event&amp; </type>
                       <methodname>next</methodname>
                       <void />
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns a reference to the next event in the
                        run.  This will be an empty event if you attempt
                        to read past the last event. Note that
                        the writer class does not write empty events to the
                        database.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term>
                    <methodsynopsis>
                        <type>std::string </type>
                        <methodname>getTitle</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                   </term>
                   <listitem>
                       <para>
                        Returns the run's title string.
                       </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Upper layer of SpecTcl's event recording/playback code.</title>
            <para>
                The upper layer of SpecTcl event recording/playback code
                consists of a pair of objects that interface into
                SpecTcl's analysis system.  Specifically,
                <classname>CDBProcessor</classname> is used
                to write run starts stops and scalers to the
                database.  It is an <classname>CEventProcessor</classname>
                and will be added to the event processing pipeline
                <classname>CDBSink</classname>, on the other hand
                is a <classname>CEventSink</classname> and will be added
                to the event sink pipline.  By the time the event sink pipline
                is executed for an event, the event has been fully decoded and
                can be written to the database.
            </para>
        </section>
    </chapter>
    <chapter>
       <title>Tcl bindings to the C++ API</title>
       <para>
        The Tcl bindings to the C++ API closely mimic the C++
        API.  Tcl is a command based language. The C++ API is object
        oriented.  The standard way to do object oriented programming
        or present object oriented APIs is through
        <firstterm>command ensembles</firstterm>.
       </para>
       <para>
        A Tcl command ensemble is a command with subcommands.
        You can think of a command as a class or an object and
        the subcommand as methods (class or object level).
        You can imagine a Tcl command that represents a class.
        It might have construction subcommand that would dynamically
        generate a new command ensemble that represents an object.
        This is the approach taken by the Tcl bindings.
       </para>
       <para>
        The Tcl bindingsx are in a package called
        <literal>SpecTclDB</literal> which is stored in the
        SpecTcl Tcl package library.  There are two ways to bring that
        library directory tree into the Tcl package search path:
       </para>
       <orderedlist>
        <listitem>
           <para>
              Via an environment variable.  For example, suppose
              the environment variable SPECTCLHOME is defined and is the
              top level directory in which the version of SpecTcl
              you are using is stored.
              <command>TCLLIBPATH=$SPECTCLHOME/TclLibs tclsh</command>
              will run a Tcl shell that includes the SpecTcl Tcl library tree
              in the search path.
           </para>
        </listitem>
        <listitem>
           <para>
              Extension of the the Tcl <varname>auto_path</varname>
              variable.  Suppose, as before SPECTCLHOME is defined
              to be the top level installation directory of your SpecTcl
              version, the following script fragment will bring the
              SpecTcl Tcl packages into your search path.
           </para>
           <informalexample>
            <programlisting>
lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
            </programlisting>
           </informalexample>
           <para>
            The global <varname>env</varname> array contains
            the values of environment variables indexed by variable
            name.  The <command>file join</command> command joins file
            system path elments and <command>lappend</command>
            appends items to a list, in this case the
            <varname>auto_path</varname> search list.
           </para>
        </listitem>
       </orderedlist>
       <para>
        Our examples will use the second form.  They will mirror
        closely the examples in the C++ API section.  The examples
        are deployed in the <filename>share/dbexamples</filename>
        directory.
       </para>
       <example>
        <title>Creating an empty database in Tcl (makedb.tcl)</title>
        <programlisting>
#!/bin/sh       <co id="makedb.tcl.boilerplate" />
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs] <co id='makedb.tcl.autopath' />
package require SpecTclDB                   <co id='makedb.tcl.require' />

if {[llength $argv] != 1} {                 <co id='makdeb.tcl.args' />
    puts stderr "Usage: makedb.tcl database-file"
    exit -1
}

DBTcl create [lindex $argv 0]           <co id='makedb.tcl.create' />

        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='makedb.tcl.boilerplate' >
            <para>
                This bit of boilerplate is a recommended way to prefix
                executable Tcl scripts.  It starts the
                <command>/bin/sh</command> shell, which is almost always
                a legal shell and then some continuation line
                magic executes the Tcl interpreter passing the
                file back to itself as a parameter.  The
                <literal>\</literal> in the line before the
                <command>exec</command> command ensures that line
                is not seen by the Tcl intepreter as it continues the
                comment line.  The Tcl interpreter then continues
                to interpret the script in the remainder of the file.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.autopath' >
            <para>
                As described previously, this line appends the
                SpecTcl Tcl library directory tree to the
                <command>package require</command> search path.
            </para>
        </callout>
        <callout arearefs='makedb.tcl.require' >
            <para>
                Brings the <literal>SpecTclDB</literal> package into the
                script. This defines the command ensemble that
                makes up the package.
            </para>
        </callout>
        <callout arearefs='makdeb.tcl.args' >
            <para>
                The <varname>argv</varname> list contains
                the command parameters that follow the command.
                Note that the command itself is not included. 
            </para>
        </callout>
        <callout arearefs='makedb.tcl.create' >
            <para>
                Creates the database file specified by the first
                command argument and initializes it to contain the
                SpecTcl database Schema.
            </para>
        </callout>
       </calloutlist>
       <para>
        The next example shows how to make a save set in an
        existing database file. We'll learn how to form a connection
        to a database and what that means. We'll then use that
        connection to create a new saveset.
       </para>
       <example>
        <title>Creating savesets in a database (makesaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {    <co id='mkset.catch' />
    set db [DBTcl connect [lindex $argv 0]]  <co id='mkset.connect' />
    set saveset [$db createSaveset "a saveset"] <co id='mkset.crset' />
    $saveset destroy                         <co id='mkset.destroy' />
    $db      destroy
} msg]

if {$status} {
    puts "Error: $msg"       <co id='mkset.errors' />
    exit -1
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='mkset.catch' >
            <para>
                This program demontsrates very simple error handling.
                The Tcl <command>catch</command> command
                performs the commands in the script passed as its
                first argument.  If there is an error, it returns
                1, if not, 0.  This value is captured in the
                <varname>status</varname> variable.
            </para>
            <para>
                The optional second argument to <command>catch</command>
                is the name of a variable.  If the command is successful,
                this will hold the result of the script.  If not,
                it will hold the error message associated with the
                failure.
            </para>
        </callout>
        <callout arearefs='mkset.connect' >
            <para>
                The <command>DBTcl connect</command> command
                creates a new command ensemble that can perform
                operations on the database file passed to the
                <command>DBTcl connect</command> command.
                This is analagous to constructing a new  object.
                The subcommands of the command captured in the
                <varname>db</varname> variable are analogous to
                object methods.
            </para>
            <para>
                This command ensemble is referred to as a
                <firstterm>data base instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.crset' >
            <para>
                Similarly the <command>createSaveset</command>
                subcommand of the databae instance command
                creates a new save set and returns another
                newly created command ensemble whose ensemble
                commands operate on the save set. As you might imagine,
                this command, captured in the <varname>saveset</varname>
                varible is called a <firstterm>saveset instance command</firstterm>.
            </para>
        </callout>
        <callout arearefs='mkset.destroy' >
            <para>
                All instance commands have a <command>destroy</command>
                ensemble command.  This destroys the command and
                releases any resources it might have.  This command
                is analogous to a destructor method
            </para>
        </callout>
        <callout arearefs='mkset.errors' >
            <para>
                This part of the script executes if any errors
                are detected by the <command>catch</command>
                command.  To see what it does, try running
                the script twice on the same database.  The secone
                time the attempt to make a saveset will fail
                because the save set already exists.
            </para>
        </callout>
       </calloutlist>
       <example>
        <title>Listing savesets in a database (lssaveset.tcl)</title>
        <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: makesaveset.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]

    puts "Savesets in [lindex $argv 0]"

    foreach name [$db listSavesets] {  <co id='lssavesets.tcl.list' />
        puts $name
    }
    $db destroy
} msg]

if {$status} {
    puts "Error: $msg"
}
        </programlisting>
       </example>
       <calloutlist>
        <callout arearefs='lssavesets.tcl.list' >
            <para>
                The <command>listSavesets</command> subcommand
                of the database instance command returns a
                properly formatte Tcl list of savesets contained
                by that database. This
                <command>foreach</command> loop outputs them
                to stdout.
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining parameters (pardef.tcl)</title>
            <programlisting>
#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}


lappend auto_path [file join $::env(SPECTCLHOME) TclLibs]
package require SpecTclDB

if {[llength $argv] != 1} {
    puts stderr "Usage: pardef.tcl database-file"
    exit -1
}

set status [catch {
    set db [DBTcl connect [lindex $argv 0]]
    set saveset [$db getSaveset "a saveset"]   <co id='pardef.tclgetsaveset' />
    
    $saveset createParameter p1 100            <co id='pardef.tclcreate' />
    $saveset createParameter p2 101 -10.0 10.0 100 "cm"
    
    puts "Parameters defined:"
    foreach param [$saveset listParameters] {  <co id='pardef.tcllist' />
        puts [dict get $param name]
    }
    
    $saveset destroy                            <co id='pardef.tcldestroy' />
    $db destroy
} msg]


if {$status} {
    puts stderr "error: $msg"
}                
            </programlisting>
       </example>
       <para>
        This example program creates two parameters named
        <literal>p1</literal> and <literal>p2</literal>.
        Parameter <literal>p2</literal> has full metadata.
        After creating the parameters the names of all parameters
        in the saveset are listed to stdout.
       </para>
       <calloutlist>
        <callout arearefs='pardef.tclgetsaveset' >
            <para>
                The <command>getSaveset</command> subcommand of
                a database instance command ensemble, looks up the
                named save set (in this case <literal>a saveset</literal>)
                and, if found creates a command ensemble that can
                manipulate that saveset.  If the saveset does not exist,
                an error is thrown.
            </para>
            <para>
                The command ensemble that
                <command>getSaveset</command> produces, is called a
                <firstterm>save set instance command</firstterm> and
                is captured in the <varname>saveset</varname>
                variable.
            </para>
        </callout>
        <callout arearefs='pardef.tclcreate' >
            <para>
                The <command>createParameter</command> subcommand
                of the saveset instance command ensemble creates
                new parameter definitions in the databsase.
                Mirroring SpecTcl, there are two types of parameters that
                can be created.  Raw parameters make a correspondence between
                parameter name and parameter number (in SpecTcl, parameter number
                is the index into a <classname>CEvent</classname>)
                object at which the parameter should be stored and retrieved.
                Tree parameters have additional metadata.
            </para>
            <para>
                The first command creates a raw parameter named
                <literal>p1</literal>.
                The second command creates  a tree parametr with
                metadata.  The metadata provides hints to both the
                user and SpecTcl GUI scripts about how to define axes
                of spectra that depend on this parameter.
                In this case a range of [-10.0..10.0) with 100 bins
                is recommended.  In addition, the units of measure
                of the parameter are documented as centimeters
                (<literal>cm</literal>).
            </para>
        </callout>
       </calloutlist>
       <example>
            <title>Defining Spectra (specdef.tcl)</title>
            <programlisting>
                
            </programlisting>
       </example>
       <example>
        <title>Defining gates (gatedef.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>
       <example>
        <title>Applying gates to spectra (applydef.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>
       <example>
        <title>Saving and recovering tree variables (vardef.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>         
       <example>
        <title>Storing event data (evtstore.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>         
       <example>
        <title>Recovering event data (evtget.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>         
       <example>
        <title>Storing scaler readouts (sclstore.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>         
       <example>
        <title>Recovering scaler readouts (sclget.tcl)</title>
        <programlisting>
            
        </programlisting>
       </example>         
    </chapter>
    <appendix>
        <title>Reference material</title>
        <section>
            <title>Database schema.</title>
            <para>
                Database schema are divided into tables.  Each table
                usually has a field called its <firstterm>primary key</firstterm>.
                The value of the primary key is a unique identifier for
                records in the table.  It is normally very quick to look up
                a record by its primary key.
            </para>
            <para>
                In a relational databae, such as sqlite3, it is normal
                for records in one table to refer to records in another table.
                This reference is expressed by having fields that contain
                <firstterm>foreign keys</firstterm> to the other table.
                A foreign key is a field whose values are primary keys in
                another table.
            </para>
            <para>
                Foreign keys express a belonging/ownership relationship.
                The ownership, in turn may express a 'has many' or a
                 'has one' relationship depending on the multiplicity of the
                 relationship.   This multiplicity is defined by the
                 logic that populates the database.
            </para>
            <para>
                This appendix will describe the set of tables
                defined by a daq database and their relationships.
            </para>
            <para>
                The top level table is the <literal>save_sets</literal>
                table.  It contains one entry for each save set in the
                database. All other tables are owned either directly or indirectly
                by a row in the <literal>save_set</literal> table.
                The schema of this table is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS  save_sets 
            (id  INTEGER PRIMARY KEY,
             name TEXT UNIQUE,
             timestamp INTEGER)
                </programlisting>
            </informalexample>
            <para>
                The fields have the following meaning:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>id</structfield></term>
                    <listitem>
                        <para>
                            The primary key for the row.  Our convention is
                            that each table's primary key is an integer named
                            <literal>id</literal> and is the first field
                            declared in the table.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the save-set.  Sqlite3 does
                            not require us to declare lengths of text items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> timestamp</term>
                    <listitem>
                        <para>
                            The time at which the record was created.
                            This is a unix timestamp.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The primary purpose of save sets is to store the analysis
                configuration of SpecTcl.  This consists of parameter/treeparameter
                definitions, Spectrum definitions, gate definitions,
                gate applications and tree variables.  At present,
                pseudo parameter definitions are not stored. If there
                is a need for that, please contact us as these can be
                added.
            </para>
            <para>
                Parameter definitions require a single table:
                <literal>parameter_defs</literal>.  This table
                contains the base SpecTcl parameter definition as well
                as any optional metadata supplied by a treeparameter that
                might wrap it.  If a tree parameter is not wrapping
                the parameter, then the metadata values are NULL.
            </para>
            <para>
                Here's the table definition for the <literal>parameter_defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS parameter_defs
            (id      INTEGER PRIMARY KEY,                    
             save_id INTEGER NOT NULL,  -- foreign key to save_sets.id
             name    TEXT NOT NULL,
             number  INTEGER NOT NULL,
             low     REAL,
             high    REAL,
             bins    INTEGER,
             units   TEXT)
                </programlisting>
            </informalexample>
            <para>
                As with all tables, by convention, <structfield>id</structfield>
                is the primary key and is an integer.  Here are the
                definitions for the remaining fields of the table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type> <structfield>save_id</structfield></term>
                    <listitem>
                        <para>
                            This is a foreign key that contains the
                            <literal>id</literal> of the <literal>save_set</literal>
                            to which this parameter definition belongs.
                            We can say that a parameter definition belongs
                            to a save set and a save set has many
                            parameter definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            This field contains the name of the spectcl
                            parameter.  It is never null as all SpecTcl
                            parameter must have unique names.  The
                            field is not marked as unique because different
                            save sets may have parameter definitions with the
                            same name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> number</term>
                    <listitem>
                        <para>
                            This is the SpecTcl parameter number.
                            Each parameter in SpecTcl has a unique number
                            that defines it's slot in <classname>CEvent</classname>
                            objects containing unpacked event data.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>low</structfield></term>
                    <listitem>
                        <para>
                            This field is not null if there is a tree
                            parameter wrapping of the parameter.  In that
                            case, the field will contain the tree parameter's
                            suggested low limit for the parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type> <structfield>high</structfield></term>
                    <listitem>
                        <para>
                            As with <structfield>low</structfield>, is
                            not null if the parameter is wrapped by a tree
                            parameter.  In that case, this field contains
                            the suggested high limit for this parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type> <structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped with  a tree parameter,
                            this contains the suggested binning for this
                            parameter.  Otherwise, this field is null.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>units</structfield></term>
                    <listitem>
                        <para>
                            If the parameter is wrapped by a tree parameter,
                            this field contains the units of measure of that
                            parameter.  It can be an empty string as well as
                            NULL.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The next set of tables hold information about spectrum definitions
                and spectrum contents.  These tables are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>spectrum_defs</literal></term>
                    <listitem>
                        <para>
                            The top level (or <firstterm>root</firstterm>) table
                            for spectrum definitions.  This table has
                            one entry per spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>axis_defs</literal></term>
                    <listitem>
                        <para>
                            Depending on the dimensionality of the spectrum,
                            each record in <literal>spectrum_defs</literal>
                            will have one or two records in this table.
                            Each entry describes a spectrum axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_params</literal></term>
                    <listitem>
                        <para>
                            Each spectrum depends one or more parameters.
                            Thus <literal>spectrum_defs</literal> has many
                            <literal>spectrum_params</literal> each
                            describing a parameter the spectrum depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>spectrum_contents</literal></term>
                    <listitem>
                        <para>
                            If a spectrum has contents stored, this
                            table will contain the spectrum contents.
                            There will be a record in this table for
                            every non-zero channel in the spectrum.
                        </para>
                        <para>
                            Note in the special case were an empty spectrum
                            is being saved, there will be one record for
                            the spectrum with a channel value of 0.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's look at these tables in detail.
            </para>
            <para>
                <literal>spectrum_defs</literal> is the top level table
                for capturing spectrum definitions and contents.  All of
                the other tables involved in spectrum definitions have
                foreign keys linking them back to this table.  This
                table, in turn, has a foreign key that links it back
                to the save set it belongs to.
            </para>
            <para>
                The defintion of <literal>spectrum_defs</literal> is:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS spectrum_defs
            (id      INTEGER PRIMARY KEY,
             save_id INTEGER NOT NULL,     -- Foreign key to save_sets.id
             name    TEXT NOT NULL,
             type    TEXT NOT NULL,
             datatype TEXT NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                Besides the <structfield>id</structfield> which is the
                usual primary keh and the <structfield>save_id</structfield>
                which is the foreign key pointing back to the
                <literal>save_sets</literal> table, the following fields
                are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type> <structfield>name</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl's name for the spectrum.  Each spectrum
                            in a save set has a unique name. Usually
                            humans refer to the spectrum using that name.
                            While SpecTcl assigns an integer number to that
                            spectrum, that number is actually not used
                            at all externally or internally and is, therefore,
                            not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type> <structfield>type</structfield></term>
                    <listitem>
                        <para>
                            Each spectrum has a type that determines how
                            it is incremented by the parameters it depends on.
                            In SpecTcl, these types are represented by short
                            textual type codes.  This field contains the
                            type code for the spectrum.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>datatype</structfield></term>
                    <listitem>
                        <para>
                            Histograms storing a spectrum have a data type
                            that can be one of
                            byte (uint8_t), word (uint16_t) or
                            long (uint32_t).  This field captures that
                            datatype.  By default, given that memory is much
                            cheaper than when SpecTcl was originally written,
                            a spectrum's data type is long.  Regardless,
                            this field explicitly stores the spectrum's
                            datatype.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Each spectrum has one or two axes (SpecTcl does not support 3d
                spectra).  These axes are described in the
                <literal>axis_defs</literal> table.   When fetching from
                this table, it's important to order the results by the
                <structfield>id</structfield> field.  When this is done,
                the first (or only) axis for a spectrum is the X axis
                and the second, if it exists is the Y axis definition.
            </para>
            <para>
                Here is the definitino of the <literal>axis+defs</literal>
                table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS axis_defs
            (
                id           INTEGER PRIMARY KEY,
                spectrum_id  INTEGER NOT NULL,  -- FK to spectrum_defs.id
                low          REAL NOT NULL,
                high         REAL NOT NULL,
                bins         INTEGER NOT NULL
            )
                </programlisting>
            </informalexample>
            <para>
                As usual, <structfield>id</structfield> is the primary
                key.  It also serves to order axis definitions for a spectrum.
                <structfield>spectrum_id</structfield> is a foreign key
                to the <structfield>id</structfield> field of the
                <literal>spectrum_defs</literal> table.  Its value
                indicates which spectrum in the <literal>spectrum_defs</literal>
                table, a record in this table belongs to.
            </para>
            <para>
                The remaining fields in this table are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>real</type><structfield>low</structfield></term>
                    <listitem>
                        <para>
                            The low limit of the axis.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>real</type><structfield>high</structfield></term>
                    <listitem>
                        <para>
                            The high limit of the axis.  The axis is
                            considered to run over the interval
                            [low, high).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>bins</structfield></term>
                    <listitem>
                        <para>
                            Number of bins into which the axis is divided.
                            Note that in SpecTcl bins are all equal sized.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Spectra are defined on  parameters.  The values of parameters
                in an event can increment a spectrum depending on that
                spectrum's type and whether or not parameters needed are
                present.  The number of parameters a spectrum may have
                are dependent on may be anywhere from 1 to unbounded depending
                on the spectrum type (e.g. gamma spectra). 
            </para>
            <para>
                 Where parameter
                ordering is important, ordering the retrieval of parameters
                from the <literal>spectrum_params</literal> table
                recovers that ordering.  
            </para>
            <para>
                The contents of this table consist of the primary key
                <structfield>id</structfield>, and two foreign keys:
                <structfield>spectrum_id</structfield> which ties the
                record back to the spectrum it belongs to and
                <structfield>parameter_id</structfield> which ties the
                entry back to the parameter in the
                <literal>parameter_defs</literal> table that defines
                the parameter.
            </para>
            <para>
                In this way, it is not necessary to actually repeat
                the parameter definitions.  This point is an important
                concept in database design. This sort of table is also
                sometimes called a <firstterm>join table</firstterm>
                because you can use the SQL join operation to marry the
                <literal>spectrum_defs</literal> table to the
                <literal>parameter_defs</literal> table through this
                table.
            </para>
            <para>
                Finlly,
                If the contents of the spectrum have been saved in a
                save set there will be several entries in the
                <literal>spectrum_contents</literal> table to
                represent this.  With the exception of the special case
                of a spectrum with no counts, the table will contain one
                entry for each  non-zero channel.  If the spectrum is empty,
                it will contain a single entry for a valid channel in the
                spectrum containing a value of zero.
            </para>
            <para>
                The table contains the usual <structfield>id</structfield>
                primary key column.  It also has a
                <structfield>spectrum_id</structfield> foreign key into the
                <literal>spectrum_defs</literal> table that ties each
                record back to a spectrum definition which, in turn, ties the
                entry back to a save set.
            </para>
            <para>
                The remaining fields are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>integer</type><structfield>xbin</structfield></term>
                    <listitem>
                        <para>
                            This value is a bin number on the X axis
                            of the spectrum.  If the spectrum is one-dimensional,
                            this value is the only coordinate needed
                            to specify a spectrum bin.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>ybin</structfield></term>
                    <listitem>
                        <para>
                            If the spectrum is two dimensional (for this purpose,
                            summary spectra are two dimensional),
                            this value is the y bin coordinate of a channel
                            in the spectrum.   If the spectrum is
                            one dimensional, the value  of this field is NULL.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>integer</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            This field is the value that was stored in the
                            channel designated by the
                            <structfield>xbin</structfield> and possibly
                            <structfield>ybin</structfield> fields.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                SpecTcl provides a very rich set of gate types.  For database
                definition purposes, these actually fall into three categories:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        <firstterm>Parameter/point</firstterm>; these gates
                        depend on parameters and points in parameter space.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Parameter/mask</firstterm>; these gates
                        depend on parameters and a bitmask.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <firstterm>Compound</firstterm>; these gates depend on
                        other gates.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                There are also the special cases of True and False gates
                that depend on nothing.
            </para>
            <para>
                This richness in gate types and dependecies leads to a root
                <literal>gate_defs</literal> table and quite a few
                subordinate tables some of which are used and other not used
                for any given gate type:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>gate_defs</literal></term>
                    <listitem>
                        <para>
                            This is the root table.  Every gate has an
                            entry in this table.  All subordinate tables
                            have foreign keys pointing back to this table.
                        </para>
                        <para>
                            Note that if you fetch gate definitions from this table
                            ordered by primary key, the API ensures that
                            you will not encounter a gate definition that
                            for a compound gate that depends on a gate you
                            have not already seen previously in the
                            retrieval.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>gate_points</term>
                    <listitem>
                        <para>
                            This table is used by Parameter/point gates to
                            store the points that define the region of
                            interest that makes up the gate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>component_gates</literal></term>
                    <listitem>
                        <para>
                            This table is used by Compound gates to store the
                            gates a compound gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_parameters</literal></term>
                    <listitem>
                        <para>
                            This table stores the parameters a Parameter/point
                            or Parameter/mask gate depends on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>gate_masks</literal></term>
                    <listitem>
                        <para>
                            This table stores the mask values for
                            Parameter/mask gates.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Let's starg going over the contents of each of these
                tables one at a time.  The
                <literal>gate_defs</literal> table, as expected,
                has the <structfield>id</structfield> primary key
                and <structfield>saveset_id</structfield>  foreign key
                fields, uniquely defining the entry and which save set
                the gate definition belongs to.
            </para>
            <para>
                Additionally, each record of this table has the following
                fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Each gate has a unique name.  This
                            field contains that name. While SpecTcl
                            assigns gates numbers, these numbers are not
                            used internally or externally and, therefore,
                            are not stored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>type</structfield></term>
                    <listitem>
                        <para>
                            SpecTcl uses short textual strings to
                            describe the gate type.  This field
                            stores that gate type.  The gate type
                            is going to determine which other tables
                            have data for this gate.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                For Parameter/Points gates, the <literal>gate_points</literal>
                table defines a region of interest in parameter space in
                which the gate is true.  These gates will also have
                entries in the <literal>gate_parameters</literal> table.
                Where point ordering is important (e.g contours and bands),
                ordering the retrieval by <structfield>id</structfield>
                recovers that order.
            </para>
            <para>
                In addition to the <structfield>id</structfield> primary
                key, this table contains a
                <structfield>gate_id</structfield> field which is a
                foreign key into the <literal>gate_defs</literal> table
                identifying the gate each point belongs to.
            </para>
            <para>
                Real <structfield>x</structfield> and possibly
                null <structfield>y</structfield> fields identify the
                point coordinates.  One dimensional regions of interest
                (e.g. slices) have null y values.
            </para>
            <para>
                Compound gates require a list of dependent gates.
                These are stored in the join table
                <literal>component_gates</literal>.  In addition to the
                <structfield>id</structfield> primary key and
                <structfield>parent_gate</structfield> foreign key back to the
                <literal>gate_defs</literal> table indicating the gate
                each record belongs to, a <structfield>child_gate</structfield>
                foreign key back to the <literal>gate_defs</literal>
                table points to the dependent gate.
            </para>
            <para>
                Compound gates need not have ordering, however for some
                gate types (and, or gates), the ordering could be chosen
                to improve the efficiency of gate computation if the
                frequency with which a dependent gate is satisfied is known.
                This s because these gates do short-circuit evaluation,
                where possible to avoid checking all dependent gates.
                Once more retrieving from this table ordered by
                <structfield>id</structfield> will recover the original
                order of dependent gates.
            </para>
            <para>
                Parameter/point and parameter/mask gates require
                entrie(s) in the <literal>gate_params</literal> table.
                This is a join table with primary key
                <structfield>id</structfield> and
                <structfield>parent_gate</structfield> pointing to
                the owning gate in the <literal>gate_defs</literal> table
                and <structfield>parameter_id</structfield> pointing to the
                parameter in the <literal>parameter_defs</literal> table.
            </para>
            <para>
                As usual, retrieving the data from this table ordered by
                primary key will recover any required ordering of these parameters
                (for example band aand contour gates require the first
                parameter be the X parameter and second the Y).
            </para>
            <para>
                Finally, the <literal>gate_masks</literal> table stores the
                mask values for gates Parameter/Mask gate types.
                This table, in addition to the primary key
                <structfield>id</structfield>, and foreign key
                <structfield>parent_gate</structfield> that refers
                back to the <literal>gate_defs</literal> table
                has an integer <structfield>mask</structfield> parameter
                that contains the mask value.
            </para>
            <para>
                Defined gates can be applied to a spectrum in SpecTcl.
                When applied, that gate acts as a condition that is
                checked, event by event, and must be true for the
                spectrum to be incremented.  Actually all spectra
                have gates applied to them. When a spectrum is created
                it has a True gate applied to it so that it is always
                incremented.
            </para>
            <para>
                Gate applications are captured in a join table called,
                <literal>gate_applications</literal> in addition to the
                primary key <structfield>id</structfield>, this table
                has two foreign keys:
                <structfield>spectrum_id</structfield> that indicates which spectrum
                is being conditionalized by the gate that is
                indicated by <structfield>gate_id</structfield>.
            </para>
            <para>
                The final analysis cofiguration item we need to describe
                in the database are tree variables.  These map to Tcl
                variables and <classname>CTreeVariable</classname> objects
                that are used to steer computations performed by the
                user's event analysis pipeline.
            </para>
            <para>
                Tree variable definitions are captured in the
                <literal>treevariables</literal> table:
            </para>
            <informalexample>
                <programlisting>
    CREATE TABLE IF NOT EXISTS treevariables (
                id             INTEGER PRIMARY KEY,
                save_id        INTEGER NOT NULL,
                name           TEXT NOT NULL,
                value          DOUBLE NOT NULL,
                units          TEXT
            )
                </programlisting>
            </informalexample>
            <para>
                In addition to the <structfield>id</structfield> primary
                key and <structfield>save_id</structfield> foreign
                key into the <literal>save_sets</literal> table,
                the following fields are present in this table:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>text</type><structfield>name</structfield></term>
                    <listitem>
                        <para>
                            Contains the name of the tree variable.  This
                            is also the name of the Tcl global variable
                            the tree variable maps to.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>double</type><structfield>value</structfield></term>
                    <listitem>
                        <para>
                            Contains the value of the tree variable.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>text</type><structfield>units</structfield></term>
                    <listitem>
                        <para>
                            Contains the units of measure metadata for
                            this tree variable.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <section>
                <title>Storing event data</title>
                <para>
                    The event data for a single run can also be
                    stored in a save-set. At present, only
                    run state transitions, event data and scaler
                    readouts can be stored.
                </para>
                <para>
                    The SpecTcl code that
                    can write event data into the database creates
                    a new save set when the run begins, and saves
                    the analysis configuration.  It then puts data
                    into a set of additional tables.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>runs</literal></term>
                        <listitem>
                            <para>
                                Contains the root information for
                                event and scaler data. All event
                                like data for the run are linked back
                                to this table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>events</literal></term>
                        <listitem>
                            <para>
                                Stores the parameters for each event
                                that were produced by the user's event
                                analysis pipeline.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_readouts</literal></term>
                        <listitem>
                            <para>
                                Stores information about when a scaler
                                readout occured and on which source id
                                it occured.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>scaler_channels</literal></term>
                        <listitem>
                            <para>
                                Stores the data  from each channel
                                of a scaler ring item
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>runs</literal> table has the following definition
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS runs (    -- Runs that were saved.
                id         INTEGER PRIMARY KEY,
                config_id  INTEGER,              -- Configuration at begin of run.
                run_number INTEGER UNIQUE NOT NULL,
                title      TEXT NOT NULL,
                start_time INTEGER,
                stop_time  INTEGER              -- End of run time
            )
                    </programlisting>
                </informalexample>
                <para>
                    As expected, the <structfield>config_id</structfield>
                    is a foreign key into the <literal>save_sets</literal>
                    table indicating which save set this run was saved in.
                    <structfield>id</structfield> is a primary key which
                    provides a handle for dependent data to link back to.
                </para>
                <para>
                    In addition to these fields, we store:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>run_number</structfield></term>
                        <listitem>
                            <para>
                                The run number for the run captured
                                by this data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>text</type><structfield>title</structfield></term>
                        <listitem>
                            <para>
                                The title of the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which the
                                run begun. In Tcl this can be turned into
                                a human readable time with
                                <command>clock format</command>, in
                                C/C++ with <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type> at which
                                the run was ended. Note that if the run
                                does not have a valid end run item,
                                this will be NULL
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    The <literal>events</literal> table is a bit odd.
                    A normal database definition for it would look like
                    this:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
        id          INTEGER PRIMARY KEY,
        run_id      INTEGER NOT NULL,
        event_number INTEGER_NOT NULL,
        parameter_id INTEGER NOT NULL,
        parameter_value REAL NOT NULL
    )
                    </programlisting>
                </informalexample>
                <para>
                    Each parameter of each event would have an entry in the
                    table that would contain its parameter id
                    (foreign key to the <literal>parameter_defs</literal>
                    table), and its value.  In fact this was the first
                    try to implement this table.  What we found, however,
                    was that while this table would have made some interesting
                    queries to support data analysis possible, reconstructing
                    events from it was not time-efficient.
                </para>
                <para>
                    We therefore wound up settling on this compromise
                    definition:
                </para>
                <informalexample>
                    <programlisting>
    CREATE TABLE IF NOT EXISTS events (
                id         INTEGER PRIMARY KEY,
                run_id     INTEGER NOT NULL,   -- fk to runs(id).
                event_number INTEGER NOT NULL, -- Event number in the run.
                parameter_count INTEGER NOT NULL, -- Hints at the event blob size.
                event_data  BLOB NOT NULL
            )
                    </programlisting>
                </informalexample>
                <para>
                    As in the first attempt, in addition to the
                    primary key <structfield>id</structfield>,
                    the <structfield>run_id</structfield>, a foreign key
                    tying the event back to the run it belongs to
                    and the <structfield>event_number</structfield>,
                    which represents the trigger number in the run;
                    we have:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>parameter_count</structfield></term>
                        <listitem>
                            <para>
                                Contains the number of parameters
                                that have values in this event.  SpecTcl
                                provides a <classname>CEvent</classname>
                                data type that is an array like object
                                whose values know if they've been assigned
                                values or not.  This
                                count represents the count of parameters
                                that have been assigned values.
                            </para>
                            <para>
                                Some event processing pipelines initialize
                                all parameters to some value.
                                While this avoids having to
                                check the validity of parameters, it also
                                throws away a major SpecTcl optimization
                                at histogramming time.  This is not
                                recommended practice.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>blob</type><structfield>event_data</structfield></term>
                        <listitem>
                            <para>
                                This contains the actual parameters that
                                were given values in the event.  So first,
                                what does <firstterm>blob</firstterm> mean?
                                <literal>blob</literal> is an acronym for
                                <literal>Binary Large Object</literal>.
                                Blobs allows arbitrary binary data to
                                occupy a field in the database.
                            </para>
                            <para>
                                In this case the blob stores a sequence
                                of <structfield>parameter_count</structfield>
                                <type>DBEvent::blobElement</type> structs. Where
                                this struct contains the following fields:
                            </para>
                            <variablelist>
                                <varlistentry>
                                    <term>
                                        <type>uint32_t</type>
                                        <structfield>s_parameterNumber</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The number/id of a parameter
                                            (foreign key into
                                            <literal>parameter_defs</literal>).
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
                                        <type>double</type>
                                        <structfield>s_parameterValue</structfield>
                                    </term>
                                    <listitem>
                                        <para>
                                            The value of that parameter for
                                            this event.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                
                            </variablelist>
                            <para>
                                The SpecTclHeader
                                <filename>CDBEvents.h</filename>
                                contains a definition of the
                                <type>DBEvent::blobElement</type>
                                data type.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Scaler data is captured in two tables.
                    The first, <literal>scaler_readouts</literal>
                    contains one record per
                    <literal>PERIODIC_SCALERS</literal>
                    ring item SpecTcl sees.  The second,
                    <literal>scaler_channels</literal> contains the
                    actual values of the scaler contained by that
                    ring item.
                </para>
                <para>
                    The <literal>scaler_readouts</literal> table looks like
                    this:
                </para>
                <informalexample>
                    <programlisting>
            CREATE TABLE IF NOT EXISTS scaler_readouts (
                id            INTEGER PRIMARY KEY,
                run_id        INTEGER NOT NULL,      -- fk for runs.
                source_id     INTEGER NOT NULL,      -- Event builder source.
                start_offset  INTEGER NOT NULL,
                stop_offset   INTEGER NOT NULL,
                divisor       INTEGER NOT NULL,
                clock_time    INTEGER NOT NULL
            )                    
                    </programlisting>
                </informalexample>
                <para>
                    The <structfield>id</structfield>
                    field is the primary key
                    value and <structfield>run_id</structfield>
                    is a foreign key into the <literal>runs</literal>
                    table that indicates which run this readout belongs to.
                </para>
                <para>
                    The remainder of the fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>source_id</structfield></term>
                        <listitem>
                            <para>
                                This is the source id from the body header
                                of the ring item. In event built data
                                it indicates which event source produced
                                this scaler item.  If the scaler item
                                does not have a body header, this wil
                                contain the value <literal>0</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>start_offset</structfield></term>
                        <listitem>
                            <para>
                                Scaler data represents scaler counts over
                                some interval in the run.  This value
                                contains the time offset into the run
                                at which that interval began.  See, however
                                <structfield>divisor</structfield> below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>stop_offset</structfield></term>
                        <listitem>
                            <para>
                                Describes the time offset into the run
                                at which the counting intervale ended.
                                Again see the <structfield>divisor</structfield>
                                field below.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>divisor</structfield></term>
                        <listitem>
                            <para>
                                In order to allow for sub-second timing in
                                scaler readout, either for higher precision,
                                or for cases when readouts must happen more
                                often than once per second, this field is
                                supplied.  This field represents the number
                                of seconds per <firstterm>tick</firstterm>
                                in the start and stop offset fields.
                                That is, dividing those fields by this value
                                (in floating point) results in seconds into
                                the run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>clock_time</structfield></term>
                        <listitem>
                            <para>
                                The unix <type>time_t</type>
                                at which this scaler readout happened.
                                This can be converted to a humann readable
                                time in Tcl using
                                <command>clock format</command>
                                and in C/C++ using
                                <function>strftime</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Associated with each scaler channel in the ring item
                    that resulted in an entry in <literal>scaler_readouts</literal>
                    is a record in the <literal>scaler_channels</literal>
                    table.  This table has the usual
                    <structfield>id</structfield> primary key.
                    A foreign key pointing it back to an entry in the
                    <literal>scaler_readouts</literal> table named
                    <structfield>readout_id</structfield> and the following
                    additional fields:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>integer</type><structfield>channel</structfield></term>
                        <listitem>
                            <para>
                                The channel number of this entry.
                                This is the index into the array of scalers
                                that was readout.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>integer</type><structfield>value</structfield></term>
                        <listitem>
                            <para>
                                The number of counts in that scaler
                                channel for
                                the asssociated readout.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>
    </appendix>
</book>